Machine Code for the Oric Atmos (Part 56)   Peter N. Bragg                      ------------------------------- 
                                          
The Story so far                                                                ---------------- Recent articles have looked at some useful programming         techniques and the last issue looked at the subject of saving and loading,      to and from cassette tape.                                                                                                                                      As a postscript on that subject, I should mention that I used three tape        recorders over the years. The first was a good hi/fi machine, which turned      out to be rather unreliable for computer tapes. Perhaps the Oric doesn't        appreciate our kind of music !! I then followed advice and went out and         bought a cheap Hitachi mono tape recorder, which was much better.                                                                                               Later on I added a pocket sized Phillips Data Recorder, which I still use on    occasions. This has an automatic gain control and so you don't have to set      the volume for saving. However that automatic gain control could cause          problems. Quite often, the saving would start off at full volume and then       drop sharply after the first half second or so. I got around that problem by    using a line of Basic to save several copies of each piece of software, in      one go. If the first copy failed to load, the second copy was usually OK.       The extra copies are always useful as backups anyway.                                                                                                           The other main problem, with using cassette tapes to store software, appears    to be the ageing process. Now most computers have disk systems, the cassette    tape system, can lie unused for a year or more, in my case. As a result, old    software tapes can become difficult to load, even when the same cassette        recorder, that originally saved them, is used in the attempt to reload them.                                                                                    At first, I thought that the quality of tapes was the main cause of the         problem. However, I have also noticed a slight deterioration on some of our     older music tapes. The human ear is very adaptable, particularly when           listening to a favourite piece of music and so a small deterioration is         acceptable and at times, probably not even noticed. A computer lacks that       adaptability. For a computer, the smallest loss can mean failure to load.                                                                                       Disks tend to be more permanent because a disk has only two magnetic            recording surfaces in very close proximity to each other. A tape spool can      have hundreds of layers of magnetic recordings stacked very tightly on top      of each other. The ferrite material in those layers is not very permanent,      it would be useless for recording if it was. As a result each layer of tape     is subjected to the magnetic fields of the many other layers of tape, above     and below it and in time is bound to be so affected that the recorded data      becomes gradually more and more corrupted and blurred. On some tapes, I have    noticed that the files have deteriorated in little more than three years.                                                                                       The only real solution to this problem seems to be covered by the classic       phrase, "use it or lose it". This way, you do at least get some advance         warning of the deterioration in time to do something about it.                                                                                                  There is a new technology on the horizon, which may offer an alternative to     the traditional disks and tapes. That is the recordable "CD". Most of the       machines I have seen so far, seem to be expensive and large. No doubt that      will change. It will be interesting to see if they can provide storage          facilities for older eight bit machines such as the Oric.                                                                                                       That more or less covers the subject of cassette tape storage of software.      Now we will go on to something new to this series, the subject of interrupts.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Stop talking, when I'm interrupting !                                           ------------------------------------- An old music hall line perhaps, but       there is some truth in it for the world of computing. So, just what is an       Interrupt and how is it used ? I think that the best thing at this stage is     to have a general look at the Interrupt operation, in other words a kind of     overview, before going on to specific operations.                                                                                                               Essentially, an Interrupt provides the necessary facilities to break into a     running program and re-direct the computer to do something completely           different for a brief period, before returning to the original program and      resuming operation at exactly the same point, where that original program       was interrupted. This allows a fairly simple set-up, such as the Oric, with     it's 6502 microprocessor, to control many different operations, all             apparently taking place at the same time.                                                                                                                       The key word here is that word "apparently". The Interrupt controlled           switching from one operation to another is done so quickly, that several        different operations can be made to look as if they are all running             simultaneously.                                                                                                                                                 The computer operating system makes good use of the Interrupts. For example,    the display needs constant refreshing and updating, or it would disappear in    a fraction of a second. This can be handled by the Interrupt operation in a     way that is so fast and transparent, that the user is completely unaware of     of any interruption, to the main program in use. 
                                                                                                               A Key Operation                                                                 --------------- The very first thing that happens, when you switch on any       computer, is that it loads up and runs an operating system of some sort.        This may not be, the full operating system, but it is usually enough to         allow the computer to respond to a signal from you, the user which tells it     what to do next.                                                                                                                                                A good illustration of this is provided by the Oric system. For example,        take the Oric on it's own, with just the power pack and monitor/TV. Switch      it on and after a second or so it will settle down to give you a more or        less blank screen, apart from a couple of lines of system information. It       will then stay like this until it receives some kind of input from you.                                                                                         What has happened at this stage, is that the Oric has booted up and gone to     a set of routines, built into the ROM chip, which then loop round and round     continuously. These routines do a number of operations such as keep the         screen display going and check out the keyboard to see if a key has been        pressed. If nothing more is done, the Oric will remain in this state,           maintaining the display and checking the keyboard, etc, for as long as it is    switched on.                                                                                                                                                    Obviously the next move is to press a key. Immediately the Oric will respond    to that, by some action such as displaying that key's character if possible,    and also storing the appropiate code of the key that was pressed for future     use. The reaction appears instantaneous and any visible result is on view,      long before you can lift your finger from the key that you pressed.                                                                                             So how was it done so quickly ? The answer is quite simple. A counter/timer     in the Oric circuit counts down from 255 to zero and then starts again from     255 counting down to zero. Each time the counter reaches zero, it produces a    signal which activates the Interrupt system in the 6502 microprocessor.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         The Interrupt has an immediate effect and the computer jumps to a special       set of routines, one of which can check out the keyboard for a key press.       At the end of those routines the computer is restored to the same state that    it was in before the Interrupt system was activated and the computer then       returns to what it was doing, before it was interrupted.                                                                                                        You might think that this whole operation would take a long time, but in        fact it happens about 100 times a second and is so quick, that it is quite      transparent to the computer user. The keyboard check goes into operation on     every third time that the timer/counter activates the Interrupt system.                                                                                         So essentially, the Oric's operating system looks at the keyboard thirty        three times a second, to see if you have pressed a key and it will make this    check, irrespective of anything else that might be going on in the computer     at the time.                                                                                                                                                    A VIA chip provides the counter/timer, for the timing, but the question is,     how does it work ?                                                                                                                                              The answer is that the VIA chip software is set-up so that every time the       counter reaches zero. it sends an electrical signal down the line, into the     microprocessor, which activates the Interrupt operation, which then takes       effect immediately after the current instruction has been executed.                                                                                             We can now ignore the counter/timer and it's software set-up for the present    and just concentrate on the fact, that the Interrupt is activated by an         electrical signal into Oric's 6502 microprocessor. That electrical signal       does not have to be supplied by the VIA chip, it also can be produced by any    suitable hardware, both internal and external to the computer.                                                                                                  So to sum up what has been said so far, the Oric hardware provides the 6502     microprocessor with a regular supply of electrical signals to the Interrupt     system, in order to keep essential services, such as the keyboard and screen    display in operation. 
                                                                                                                                          Is your interruption essential ?                                                -------------------------------- In some cases the answer to that question,     might be no ! If for example, the computer software was doing something,        where speed was an essential requirement, you could gain speed by reducing      the number of keyboard scans for a short period, without too much               inconvenience. However, if you did the same to the operations that update       and refresh the display for any real length of time, you would end up with      an unpleasant flicker on the screen display.                                                                                                                    So some Interrupts are more important than others and must be done on time,     but there are others which can be temporarily ignored, in order to gain         other benefits, such as speed of operation, when required.                                                                                                      Obviously it is an advantage if you could turn the Interrupt system off, or     disable it by masking out some of the less urgent operations, without           affecting essential services such as the screen display.                                                                                                        Fortunately, there is such a facility available to the Oric. The 6502           microprocessor, can be set to ignore certain Interrupts. This facility is       provided by the Interrupt Mask bit which is located in the Status Register.                                                                                     We can have a look at this aspect of the Oric's Interrupt system next time.     ..............................................................See you then.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Machine Code for the Oric Atmos (Part 57)   Peter N. Bragg                      -------------------------------                                           

The Story so far                                                                ---------------- In the last article, we started to have a look at the          subject of Interrupts, what they are and what they can be used for.                                                                                             We found that, like most computers, the Oric makes a lot of use of the          Interrupt facility, which is provided by it's 6502 microprocessor.                                                                                              The Operating System is just one area, where the Interrupt facility is in       constant use. We had a brief look at how it is used to handle the necessary     updating operations, for the keyboard and screen display.                                                                                                       The control timing for these operations is produced by the VIA chip, which      sends an electric signal down a line into the microprocessor, at regular        intervals, which is used to activate the Interrupt system. That then causes     the computer to run a set of routines to scan and update, the necessary         items of hardware, such as the screen and keyboard etc.                                                                                                         Such operations are transparent and brief so that they can be repeated at       frequent intervals, to provide a constant service, without interfering with     the user's normal operation of the computer. 
                                                                                                                   So, Where Now ?                                                                 --------------- Once you have interrupted the microprocessor, the next          question is, how does it pass control on to those specific "interrupt"          routines. Bear in mind, that there are quite a number of eight bit computers,   apart from the Oric, that make use of the 6502 Microprocessor and they all      have very different requirements, for their hardware, such as keyboards and     displays. So, it is obviously impossible to write a single routine that         would handle these operations for all 6502 computers, including the Oric,       Apple, BBC Micro and Atari, to name just a few.                                                                                                                 The answer is to have a common address for all machines and use that as a       vector address for jumping off to the specific "interrupt" routine for each     different type of computer. That is how the 6502 Microprocessor handles the     situation. It earmarks the two highest memory locations, which are usually      located in the Operating System ROM, for this purpose. These locations are      #FFFE and #FFFF. The 6502 assumes that they hold the start address of the       "interrupt" routine. When the interrupt line becomes active, the 6502 stops     what it is doing and takes a look at the contents of those two locations for    the vector address. It will then jump to that address, in order to deal with    the required "interrupt" operations.                                                                                                                            If you look at the locations #FFFE and #FFFF in the Oric Atmos, you will        find that it is set to the vector address #0244. However, if you were to        look at the same locations (&FFFE and &FFFF) in the BBC Micro, you would        find a different vector address. The same locations in the Apple computer       hold yet another address. In each case the address is the start of that         computers "interrupt" routines.                                                                                                                                 So to summarise so far. Every time a piece of hardware such as the VIA timer,   puts an electrical pulse on the interrupt line to the 6502 Microprocessor,      it causes an almost immediate jump to a set of routines, whose address is       stored in locations #FFFE and #FFFF. That is the basic principle of how the     interrupt system works, for all 6502 computers, including the Oric. However,    it should be noted that the system needs to be a bit more versatile than        this, so let's have a closer look at the routines "start" address.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              The Second Vector                                                               ----------------- As mentioned before, the "start" address held in locations    #FFFE and #FFFF is #0244, but in fact it should be noted that the required      "interrupt routines" are built into the computers operating system ROM chip     and really start at #EE22.                                                                                                                                      The fact that the interrupt routines are in ROM could make access to the        Interrupt system, quite difficult for most users. However, this problem is      easily solved by using that second vector address in RAM, at #0244/46, which    is really a three byte jump instruction to the ROM routines. Unlike the ROM,    the second vector jump in RAM can be written to and therefore altered to        include any extra "interrupt routines" written by the user, in the system.                                                                                      Under normal circumstances, the interrupt system starts up with a jump, via     the vectors in #FFFE/FF and #0244/46 to the routines starting at #EE22.                                                                                         However, if a programmer needs to make additions to the "interrupt routines",   it can be done quite easily. All the programmer has to do, is to write a        new routine and end it with a jump to #EE22. The vector jump at #0244/46 is     then altered to point to the new routine and "hey presto !" the interrupt       operation has been extended.                                                                                                                                    Don't try that yet ! You can't alter the contents of #0244/46, by writing it    in, one digit at a time, because at the rate of a hundred interrupts a          second, you'll get one digit in before the interrupt goes active and the        Oric tries to jump to a part written address. It won't like that ! and won't    speak to you again, without a reset.                                                                                                                            That is the "how and why" of the second vector. We will have a look at how      to use it in a little while. Meanwhile, there is one other aspect of the        "interrupt" system to consider, that is the question of "masking" interrupts.
                                                                                   Interrupt Requests and Non Maskable Interrupts                                  ---------------------------------------------- So far we have looked at a       single type of interrupt, but in fact there are really three types available    to us in the 6502 Microprocessor. We can ignore one of them for the time        being as it is a simple operation, involving the Break instruction. We are      not dealing with that, at the present time.                                                                                                                     At the moment, we are only interested in the Interrupt Request and the Non      Maskable Interrupt, which are more commonly referred to as the I.R.Q. and       the N.M.I. or just IRQ and NMI, respectively. In fact, all of what we have      been looking at so far, applies to the "Interrupt Request" (IRQ).                                                                                               The obvious question is, why do we need two Interrupts and what is the          difference between them. The difference between the two is that the             "Interrupt Request" can be "disabled" or in other words, put out of action,     by "masking" it out, whereas the "Non Maskable Interrupt", as it's name         implies, cannot be "masked" out or put out of action.                                                                                                           The two types of Interrupt each have their own set of vector addresses. The     Interrupt Request uses #FFFE/FF and #0244/46 to access a routine at #EE22,      as we have already seen. The Non Maskable Interrupt uses #FFFA/FB to get it     to a vector jump in locations #0247/49, which then takes it on to a routine     at #F8B2, which is also located in the Oric's operating system ROM.                                                                                             We will be looking at how and why these two different types of Interrupt are    used, next time.................................................see you then.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Machine Code for the Oric Atmos (Part 58)   Peter N. Bragg                      -------------------------------                                          

The Story so far                                                                ---------------- The last couple of articles have been looking at the           subject of Interrupts, what they are and what they can be used for.                                                                                             To simplify things, the description so far has mainly concentrated on just      one of the Interrupt system operations, as provided by the Oric's 6502          microprocessor.                                                                                                                                                 Essentially an Interrupt is triggered by an electric signal, sent down a line   into the microprocessor, by an external or internal device, such as one of      the onboard timers for example. That electrical signal very briefly             interrupts normal operations and causes the computer to run a small set of      necessary service routines, known as the Interrupt Routines.                                                                                                    These Interrupt Routines are kept short and transparent, so that the            interrupt operation services can be repeated at frequent intervals when         required, without interfering with the user's normal operation of the           computer. The computer user is usually completely unaware, that these           essential services are taking place.                                                                                                                            The last article mainly dealt with the way the microprocessor accessed the      interrupt routines in the operating system ROM, jumping to them via two         vector addresses. One of those vector addresses is common to all "6502"         computers irrespective of manafacturer. The other vector address is specific    to the Oric itself and is located in RAM, so as to allow additions to be        written into the operating system's interrupt routines, when required.                                                                                          There are in fact, two very similar interrupt operations available to "6502"    machines such as the Oric. These are the Interrupt Request and also the         Non Maskable Interrupt. They are more usually referred to as IRQ and NMI,       respectively. Essentially they both work in the same way. The difference        between them is that the "Interrupt Request" can be disabled by "masking"       it out, whereas the "Non Maskable Interrupt", cannot be disabled.                                                                                               So the Oric provides a choice of two very similar interrupt operations,         each equipped with it's own signal line and set of vector addresses.            The only real difference is that one of them (IRQ) can be "switched off"        temporarily when required, by writing software to mask it out. 
                                                                                                 Priority                                                                        -------- The advantage of having the two separate interrupt systems can be      seen in the computer operating system. Some operations need higher priority     than others. For example the screen display is obviously a high priority        operation, it would be difficult to see what was going on without it.                                                                                           The screen display needs constant updating and refreshing some fifty times a    second. If that is subject to any kind of delay, the display output will        flicker or disappear. This is just the kind of operation that is best           handled by the "Non Maskable Interrupt" ("NMI"), which will ensure that the     display is always updated on time, irrespective of anything else that is        going on in the computer.                                                                                                                                       A printer on the other hand, would not be much affected by short delays, in     fact it is not unusual for the printer to request text in chunks, at odd        intervals and store them, while it continues to print out at a steady rate.     This kind of operation is best handled by the "Interrupt Request" ("IRQ").                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Both types of interrupt can be triggered by hardware and this has been          exploited by the hooligan element in the Oric community, who can't resist       the opportunity to have a poke around inside their computers with a hot         soldering iron. I must confess that I too have done some of that in the past.   However, much can be done with software alone, no electronics required.
                                                                                         The Interrupt Mask                                                              ------------------ Let us have a look at how the "Interrupt Request" ("IRQ")    is controlled. This is handled by something we have looked at before, the       Status Register. You may recall that the Status Register is a single byte       (8 Bits) register located in the 6502 microprocessor, which provides a home     for a number of "Flag" bits.                                                                                                                                    Although the Status Register contains one byte, each of the eight bits in       that one byte, are treated as separate items. So the Interrupt Mask bit is      used in complete isolation from the other "Flag" bits, such as the Carry        Flag and the Zero Flag bits. There are seven of these "Flag" bits in use        (the eighth bit is left unused).                                                                                                                                We have already used some of the "Flag" bits. The Carry Flag and the Zero       Flag for example are used for simple arithmetic and testing, amongst other      things.                                                                                                                                                         We found that these "Flag" bits are indicators, that can be used to show the    end result of an instruction operation, just completed. They also provide       a means of control for instructions that are next in line for execution.                                                                                        There is a set of eight one byte instructions, which can be used to set or      clear four of the "Flag" bits. Two of these instructions are for use on the     Interrupt Mask Bit. They are "CLear Interrupt Mask" (CLI) code 58h, which       clears the Interrupt Mask Bit to "0" and SEt Interrupt Mask (SEI) code 78h,     which sets the Interrupt Mask Bit to "1".                                                                                                                       The Interrupt Request operation depends on whether the Interrupt Mask Bit is    set to "1" or clear at "0".                                                                                                                                     If the Interrupt Mask Bit is clear at "0", when the IRQ line to the             microprocessor becomes active, the Interrupt operation will be vectored         through #FFFE and #0244 to the routine at #EE22 as normal. If on the other      hand, it is set to "1" when the IRQ line becomes active, nothing will happen    and the Interrupt Request will be ignored.                                                                                                                      As was the case with the other "Flag" bits in the Status Register, you will     probably find that the Interrupt Mask Bit is in constant use, so don't          expect it to remain in any one state for very long, it is always best to        preset or clear it to the required state, just before making use of it.                                                                                         Of course, none of this applies to the Non Maskable Interrupt (NMI), which      will go immediately to it's own interrupt routines, as soon as the "NMI"        line to the microprocessor has been activated. 
                                                                                                                 Interrupt Software Operation                                                    ---------------------------- We now know how the an Interrupt is initiated      and how the interrupt service routines are accessed. However, there is an       automatic sequence of events that happen at the start of any interrupt, that    has not been mentioned so far. First of all a copy of the Program Counter       and Status Register are preserved on the Stack and then the Interrupt Mask      Bit is set to "1". Why ? Well we will have to look at that next time........

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Machine Code for the Oric Atmos (Part 59)   Peter N. Bragg                      -------------------------------                                           

The Story so far                                                                ---------------- In the last few articles, we have been looking at the          subject of Interrupts, what they are and what they can be used for.                                                                                             We have seen that an Interrupt is an operation triggered on a regular basis     by an internal or external signal from computer hardware, which then runs a     set of essential service routines, in a way that is sufficently brief and       transparent, that they are virtually invisible to the computer user.                                                                                            The key words here are "brief" and "transparent". The first is easy. "Brief"    means a set of service routines that are short and quick enough to be           unnoticeable to the computer user, while in operation. We have also             encountered the second word "transparent" in previous articles and this         brings us to the point we reached at the end of the last article.
                                                                                               Transparent Interrupt Routines                                                  ------------------------------ Essentially a "transparent" set of routines      operate in a way that leaves the computer in exactly the same state, at the     finish of their operation, as it was just before they started. Obviously, it    is important that the interrupt service routines do not make changes that       would interfere with any software that the computer user is running.                                                                                            As mentioned last time, there is an automatic sequence of events that           happens at the start of any interrupt. First of all a copy of the Program       Counter and Status Register are preserved on the Stack and then the             Interrupt Mask Bit is set to "1".
                                                                                                                               "Keep it like it was"                                                           --------------------- Let's deal with the items, that are put on to the         Stack first. To refresh your memory, the Stack is an area of RAM mainly used    for temporary storage, located in "Page 01" (#0100 to #01FF). To use it, you    just push items on to, or pull items off the Stack, using very simple           instructions. You don't have to remember where you put the items, that is       automatically controlled by the Stack "pointer". You only need to remember      the order in which they went on to the Stack.                                                                                                                   The actual storage system is a type of operation known as "LIFO", which         means "Last In, First Out". The last item put on the Stack, is always the       first item retrieved from it and that is why it is essential to remember        in which order, items were put on the Stack, because the items (bytes) are      pulled off in the reverse order, to that order in which they were put on.                                                                                       In addition to instructions such as PHA (code 48) and PLA (code 68), which      you use to push and pull items on and off the Stack, you will find that         there are other operations, which make automatic use of the Stack.                                                                                              The Interrupt operation is one of these. It makes use of the Stack for          preserving the current Program Counter address and the contents of the          Status Register. It does this automatically for you, immediately the            Interrupt line becomes active.                                                                                                                                  The Program Counter address is preserved so that the computer can return        to precisely where it was, before the Interrupt operation was started.          The Status Register is also preserved for the same reason, so that it too       can be retrieved in the same state as it was before the Interrupt occurred.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Return from Interrupt                                                           --------------------- Control is handed back to the computer user's own         program, at the end of the Interrupt operation. This is not an automatic        operation, as was the case when the Interrupt line became active. It needs      to be done, using the instruction "ReTurn from Interrupt" or RTI (code 40h),    which is normally the final instruction in any Interrupt routine.                                                                                               The "ReTurn from Interrupt" instruction first of all, retrieves and restores    the original contents of the Status Register. Then it puts the original         address back into the Program Counter which returns the whole operation back    to the computer user's program and to the precise point that it left off,       before the Interrupt operation was activated. These items, a total of three     bytes in all, are all retrieved from the Stack, automatically by the "ReTurn    from Interrupt" instruction.                                                                                                                                    That is the Stack operation and it should be noted that it is the very          minimum that needs to be done, to provide a return to the computer user's       own program. However, it does not make the Interrupt routines transparent,      which we will come back to in a moment, after we have looked at Interrupt's     effect on the "Interrupt Mask Bit". 
                                                                                                                            No Interrupting Interruptions                                                   ----------------------------- It was also noted that the Interrupt sets the     Status Register's "Interrupt Mask Bit" to "1" when the Interrupt line is        activated. The reason for this, is quite simply to prevent another Interrupt    arriving while the current Interrupt is still being dealt with.                                                                                                 After the Interrupt has been dealt with, the "Mask Bit" is restored back to     it's original state by the "Return from Interrupt" instruction, which           retrieves the original Status byte from the Stack and copies it back into       the Status Register, as noted above.
                                                                                                                            More Transparency ?                                                             ------------------- The above is the very minimum that needs to be done in      order to ensure a return from the Interrupt service routines. It certainly      does not restore the contents of the Accumulator and "X" and "Y" Registers,     which may well have been corrupted by the operation of the Interrupt            routines. This will cause plenty of problems to the computer user's software,   if it is not dealt with, so it is really essential to preserve the contents     of these three registers at the start of the Interrupt routines, to prevent     them from being corrupted.                                                                                                                                      This is something we have looked at before and the solution is easy. The        contents of the Accumulator are the first item to be pushed on to the Stack.    After that the contents of Register X are copied into the Accumulator and       then pushed onto the Stack and then Register Y is copied and pushed on to       the Stack in the same way. A total of three bytes pushed on to the Stack.                                                                                       At the end of the Interrupt routines, the above procedure is reversed.          The original contents of Register Y are pulled off the Stack into the           Accumulator and copied back into Register Y. That operation is then repeated    to return the original contents of Register X. After that, the next byte to     be pulled off the Stack into the Accumulator, is the original contents of       the Accumulator, so that completes the restoration of the three Registers       and should be followed immediately by a "ReTurn from Interrupt" instruction.    Providing the Interrupt routines are fairly fast, this will return control      of the computer, well before the computer user is aware of it's brief lapse.    Thats the Interrupt operation..........Next time a crash course, perhaps !!

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Machine Code for the Oric Atmos (Part 60)   Peter N. Bragg                      -------------------------------                                           

The Story so far                                                                ---------------- The last few articles, have been looking at the subject of     Interrupts. An Interrupt operation is triggered by an internal or external      signal from computer hardware, which causes it to run a brief set of service    routines, in such a way that they are almost invisible to the computer user.                                                                                    The essential Interrupt routines are located in the Operating System ROM and    are accessed via a set vector jumps, located in Page 02 of the Oric's RAM.      We can use those vectors in Page 02 to tap into the Interrupt routines and      add our own routines to the Interrupt operation.
                                                                                                                Using Interrupts                                                                ---------------- A lot depends on what you intend to use the Interrupt          facility for. Interrupts can be triggered by external devices. A printer        or a mouse are good examples. Like most computers the Oric already has a        printer driver and a mouse really needs an extra piece of hardware such as      the VIA 6522 Expansion unit, detailed in the "Advanced User Guide" by           L. Whewell. Not everybody has access to this sort of hardware, so for the       purpose of this series, we will stick to simple software items, for the         present time.                                                                                                                                                   However, I should mention in passing, that the above mentioned Expansion        unit is an interesting and not too difficult project. It works by linking       into the Oric bus and for example, can be used to read the pulses generated     by a typical computer mouse which indicate how far and in which direction       the mouse has been moved, so that movement can be used to control a pointer     (or cursor) on the Oric screen display.                                                                                                                         The main chip in the Expansion unit is the VIA 6522, which is linked to the     Oric's Interrupt line. This allows it to activate the Oric's 6502 Interrupt     system, to tell the Oric, when the mouse is moved, so that the Oric can get     on with it's normal operation, without having to keep on checking up on the     mouse. Obviously, it also needs a small set of routines, tacked on to Oric's    Interrupt routines, to handle the mouse operation.
                                                                                                              Page 02 Vectors                                                                 --------------- So how do we install our own routine into Oric's Interrupt      system. The answer is, to use one of the vector locations in the Page 02        area (#0200-02FF). To keep things simple so far, I have only mentioned the      two locations in Page 02, used as vectors to the start of the Interrupt         routines. There is in fact a third vector, which provides the exit from         those routines.                                                                                                                                                 The first two vectors at #0244-46 and #0247-49 each hold a jump instruction,    addressed to the start of the Interrupt routines in the Oric's ROM.                                                                                             If you change either of these vector start addresses, in order to add your      own routines, you will be putting your routines before the system routines.     I personally feel that it is better to tack any additional routines on to       the end of the Operating System routines instead, in case they upset            something, where timing is critical.                                                                                                                            This can be done using the third vector. At the end of the Interrupt            operation the Operating System jumps back to Page 02 for the final "ReTurn      from Interrupt" instruction (RTI code 40) at #024A, which then terminates       the system routines. That is a good place for a jump off to your routine.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Although "RTI" is a single byte instruction, that particular instruction is     conveniently located in a reserved three byte vector area, #024A-4C, so it      is quite possible to relocate the "RTI" and put it at the end of your own       routine instead. Then all you need to do is to put a jump instruction to        your own routine into the vector at location #024A-4C, in order to link your    routine on to the end of the Operating System routines.                                                                                                         Don't forget what was said in the last issue about making your routine          transparent. The vectors only contain one instruction and do not preserve       the contents of the Accumulator and Registers X and Y. They will have been      restored to their original state before arriving at the "RTI" instruction in    vector #024A, so any routine you write, will need to preserve them as the       very first action and then retrieve them again, just before the "RTI"           instruction at the end of your routine.
                                                                                                                         The Crash Course                                                                ---------------- As I pointed out, a couple of issues ago, you cannot simply    alter a vector address, by writing a new one into the vector location.          The Interrupt routines are in constant use and the vector would be accessed     by the built in Interrupt system, long before you completed the new address,    with the result that the system would jump to the partially re-written          address and subsequently crash.                                                                                                                                 If you want to add your own routine to one of the Interrupt operations, you     will need a method that inserts the address of your own routine(s) into the     vector location extremely rapidly and of course the way to do that is to get    the Oric to do it for you.
                                                                                                                                      Setting a New Vector                                                            -------------------- Let us assume we are going to use the Interrupt exit       vector at #024A-4C. This is labelled "INTSL" and normally provides the          return from the Interrupt handling routines. It is a three byte vector,         suitable for a jump instruction, but normally it just contains the single       byte instruction, "ReTurn from Interrupt" ("RTI"). We need to replace that      with a three byte Jump instruction, addressed to our new interrupt extension    routine.                                                                                                                                                        There are several ways to do this. The simplest way is to use a short           routine to load and write the three bytes of the required Jump instruction,     one at a time, into the vector location. This should work, but it is not the    best way to do it.                                                                                                                                              A better method, is to first of all, copy and store the vector ("INTSL")        contents, in a parameter block. That same parameter block can also be used      to store a Jump instruction to the start address of our new interrupt           extension routine. Now we can use a simple copy routine to copy our Jump        instruction into the vector ("INTSL").                                                                                                                          In effect this swaps the Operating System exit vector for one that extends      the Interrupt operation to our new extension routine. The result, our new       routine immediately becomes an active part of the Interrupt operation.                                                                                          A second copy routine can be used to restore the original exit vector           contents, from the parameter block copy of those contents. That will            disconnect the extension routine, if we wish to do so.                                                                                                          That's the theory. Next time, we can have a go at some crashing for real !!     A very Merry Christmas and a Happy New Year. See you in 1997...............

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Machine Code for the Oric Atmos (Part 61)   Peter N. Bragg                      -------------------------------                                           

The Story so far                                                                ---------------- We have been looking at the subject of Interrupts in recent    articles and have seen that the Interrupt operation is triggered by an          electrical signal from the computer hardware, which activates a brief, but      essential set of service routines.                                                                                                                              We have also been looking at possible ways to gain access to the Interrupt      system, in order to allow us to make use of it, for our own purposes.           There is a vector location in Page 02 of the Oric's RAM at #024A-4C, which      we could use to extend the Operating System Interrupt routines, to include      a routine of our own. At this point, we could use a small demonstration.                                                                                        Before we start to mess about with the Interrupt system, we need a simple       test routine to show what is happening, when it happens. The routine shown      below, is not very dramatic, but it will help to give a fair idea of how        interrupts can work quickly and continously in the background. It is short      and simple, as it is only used to indicate what is happenning and is not        required for the actual access to the Interrupt system itself.
                                                                                                  Interrupt Test routine                                                          ---------------------- The test routine shown below, simply adds 01 to the      contents of a location (#BBA5) on the screen display. The location is easy      to find on the screen. Set the Oric for capital letters and the word "CAPS"     appears in the top right hand corner of the screen. The "A" of the word         "CAPS" is location #BBA5 and it will contain code 41h, the ASCII code for       that letter. The routine can be used as an indicator to show that things are    working correctly. Each call to it, will change the character displayed in      location #BBA8, to the next one up, in the ASCII code range 20h to 80h.
                                                                                         Oric                       Demo Routines                         26 Dec 96      ----                       -------------                          --------      [ CALL#8070 ]--------------[ Test Indicator ]------------------------[ / ]
         ---start---      ---Add 01 to Display Location contents---             8070:EE A5 BB : INC BBA5   : Increment location #BBA5 contents.
                          ---Test Progress so far---                            8073:AD A5 BB : LDA BBA5   : Fetch copy of #BBA5 contents for test.             8076:C9 80    : CMP #80    : Test - have contents reached 80h yet ?             8078:D0 05    : BNE"807F"  :   No - so skip to finish now.
                                Yes - so........
                          ---Reset to Code 20h---                               807A:A9 20    : LDA #20    : Load Accu with code 20h for "Space"                807C:8D A5 BB : STA BBA5   :  and copy it into location #BBA5.
                          ---Finish---                                          807F:60       : RTS        : Exit
          ---end---                                                             [------------------------------------------------------------------------] 
                                                                                     Enter the routine as listed above and then use CALL #8070 to run it.            You will find that it will do just one thing. It will change the second         letter of the word "CAPS" to "B". This is because the code for "B" is 42h,      the result of the routine adding 01 to 41.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Call the routine again, to add another 01 and you get "C" and so on. Each       time you call it, if you have that much patience (which I haven't !), you       will get the next character until you reach code 80h. At that point, the        branch instruction ("BNE") at #8078 is disabled and the code in location        #BBA5, is reset back to 20h (character SPACE). The count will start up again    from there, on the next call. Needless to say, it doesn't matter if the word    "CAPS" is on display or not, the routine will still work with code 20h, for     "Space" in that #BBA5 location.                                                                                                                                 Check that the routine works correctly. I cheated. After a couple of calls      to the routine, I poked code 7Eh into location #BBA5 and made a few more        calls to check that the BNE branch reset location #BBA5 contents back to 20h.                                                                                   The routine can now be used as an indicator to show that things are working     correctly. The idea in this example, is to tack it onto the Operating System    Interrupt routines. It will then indicate each and every Interrupt, by          changing the character displayed in location #BBA8.                                                                                                             That covers the test routine. Feel free to substitute one of your own, if       you wish, but do check that it works first and remember, keep it simple.
                                                                                        Interrupt Extension Routine                                                     --------------------------- Having got our test routine, we now need to make    it "transparent". The reason is simple. Any routine we use is bound to          corrupt one or more Registers. Our simple "test indicator" routine above,       will corrupt the Accumulator. So we need to add something like the routine      below, to ensure a safe return from the Interrupt system, for any operation.
                                                                                    Oric                       Demo Routines                         26 Dec 96      ----                       -------------                          --------      [ CALL#8060 ]--------------[ Interrupt Extension ]-------------------[ / ]
         ---start---      ---Preserve Registers---                              8060:48       : PHA        : Preserve Accumulator on the Stack.
                                                                                                 8061:8A       : TXA        : Copy Register X to Accumulator and                 8062:48       : PHA        :  then preserve it on the Stack.
                                                                                                    8063:98       : TYA        : Copy Register Y to Accumulator and                 8064:48       : PHA        :  then preserve it on the Stack.
                                                                                                    8065:20 70 80 : JSR 8070   : Call "Test Indicator" routine.

                          ---Retrieve Registers---                              8068:68       : PLA        : Retrieve Register Y item from the Stack and        8069:A8       : TAY        :  then copy it back into Register Y. 
                                                                                               806A:68       : PLA        : Retrieve Register X item from the Stack and        806B:AA       : TAX        :  then copy it back into Register X.
                                                                                                806C:68       : PLA        : Retrieve Accumulator item from the Stack.

                          ---Finish---                                          807D:40       : RTI        : Exit (& retrieve Status & Prog Counter).
          ---end---                                                             [------------------------------------------------------------------------]
                                                                                      Now we have a simple test routine. The next question is, how to link it up      with the Interrupt system. We will look at that next time.................

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Machine Code for the Oric Atmos (Part 62)   Peter N. Bragg                      -------------------------------                                           

The Story so far                                                                ---------------- We have been looking at Interrupts in recent articles          and in the last issue, we reached the stage of producing a demonstration        "indicator" routine, suitable for linking up to the Oric's Interrupt system.
                                                                                    Indicator Routine                                                               ----------------- To briefly recap, the "indicator" routine is short and        designed to indicate each call to the Interrupt system, by changing the         contents of a display location on the screen every time the Interrupt system    is activated. The display location used, is the one that normally holds the     letter "A" in the word "CAPS", which appears in the top right hand corner of    the screen when the Oric is set for capital (upper case) letters. Each time     a call is made to the routine, the code of the character displayed is           incremented. So "A" would become "B" on the first call and "C" on the next      and so on, within the ASCII display code range 20h to 7Fh.
                                                                                                      "Transparency"                                                                  -------------- Any routine, which is intended to be linked up with the          Interrupt system, must be "transparent", so with this in mind, a second         routine was produced, which preserves the Accumulator and Registers X and Y     in that order, before calling the "indicator" routine, mentioned above.                                                                                         On return from the "indicator" routine, Registers Y, X and Accumulator are      retrieved in reverse order, before making an exit, using a "ReTurn from         Interrupt" instruction ("RTI"). This "transparent" routine has to be used to    call our "indicator" operation, or indeed, any other operation/routines         intended for use with the Oric's Interrupt system. Both routines were listed    in detail last time and are repeated here in abreviated form, to complete       the listings below.                                                                                                                                             This second routine will prevent any extensions to the Interrupt system         (such as our "indicator" routine) from corrupting the microprocessor            registers. It restores them to the original state at the time the Interrupt     system was activated. If that is not done, the Oric will "crash" on return      from the Interrupt system operation.
                                                                                                                            Linking the Routines to the Interrupt System                                    -------------------------------------------- The two routines mentioned         above, can now be linked to up to the Interrupt system with a single call,      using the instruction "JMP 8060". Note that it is a plain jump instruction,     not a JSR. This because the final instruction in the routine at #8060-6D, is    a ReTurn from Interrupt ("RTI") instruction, which is quite different from      the "RTS" and "JSR" combination. The "RTI" instruction uses an address          stored when the Interrupt line went active and it also reinstates the Status    Register to the condition it was at that time.                                                                                                                  The best way to link up our routine to the Interrupt system, is to write the    instruction to call it, into the "INTSL" vector, located in RAM at #024A-4C.    Normally, this is set to #024A:40 00 00, which is an Return from Interrupt      instruction (plus two blanks !). We need to change that to #024A:4C 60 80       for "JMP 8060", to call our extension routine. The essential "RTI" in #024A     is then replaced by the one at the end of our extension routine.                                                                                                You cannot manualy write that instruction into the vector at #024A, because     the Interrupt system is in constant use and the vector would be accessed        long before you completed the job, causing the Oric to crash.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   You will have to get the Oric to write the instruction in for you, because      it can do it much faster. The routine listed below is not the most efficent     method, but it does the job, which is good enough at this point. It works by    loading the three byte "Jump" instruction, one byte at a time into the          Accumulator and then copying those bytes into the "INTSL" vector at #024A-4C.
                                                                                    Oric                       Demo Routines                         26 Dec 96      ----                       -------------                          --------      [ CALL#8026 ]--------------[ Set New Interrupt Vector ]--------------[ / ]
         ---start---                                                            8026:A9 4C    : LDA #4C    : Load Accumulator with "JMP" instruct code          8028:8D 4A 02 : STA 024A   :  and copy it into vector at #024A.
                                                                                                 802B:A9 60    : LDA #60    : Load Accumulator with instruct addr lo byte        802D:8D 4B 02 : STA 024B   :  and copy it into vector at #024B.
                                                                                                 8030:A9 80    : LDA #80    : Load Accumulator with instruct addr hi byte        8032:8D 4C 02 : STA 024C   :  and copy it into vector at #024C.

                      ---Finish---                                          8035:60       : RTS        : Exit
          ---end---                                                             [------------------------------------------------------------------------]        Interrupt Extension routine.            Test Indicator routine.
          ---start---                            ---start---                    8060:48       : PHA                     8070:EE A5 BB : INC BBA5
                                                                                                8061:8A       : TXA                     8073:AD A5 BB : LDA BBA5                8062:48       : PHA                     8076:C9 80    : CMP #80
                                        8078:D0 05    : BNE"807F"               8063:98       : TYA                                                             8064:48       : PHA                     807A:A9 20    : LDA #20
                                        807C:8D A5 BB : STA BBA5                8065:20 70 80 : JSR 8070
                                        807F:60       : RTS                     8068:68       : PLA
                                                  ---end---                     8069:A8       : TAY                     [-------------------------]
                                                                                             806A:68       : PLA              The additional two routines, listed            806B:AA       : TAX              in brief here, were more fully
                                 covered in the listings and notes
806C:68       : PLA              last time and are only included to
                                 complete the operation, described in           807D:40       : RTI              this article.
          ---end---                                                           [------------------------------------------------------------------------]     Enter the above listing into the Oric, using assembler or plain hex code,       then save it. To put it into operation, just CALL#8026. Now the "test           indicator" routine increments the second character in "CAPS", at top right      of your screen display, every time the Interrupt system goes active.
                                                                                            The operation is so fast, that the character becomes little more than a blur    and cycles through the entire range (20h to 7Fh) from "A" back to "A" again,    in about one second. That is 95 calls, which include the interrupt servicing    on each call. Our routine is just a tiny addition to that. You will see that    it will continue to run whatever you do, providing the routines remain          intact, until the Oric is switched off. It provides a simple demonstration,     but is not good software, so we will have another look, next time........... 