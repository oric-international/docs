         Machine Code for the Oric Atmos (Part 21)   Peter N. Bragg                       	   -------------------------------                                           

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming on the Oric. Part 16 of the series provided a simple machine        code programming kit consisting of a small instruction set, plus a couple of    Operating System calls to read the keyboard and write to the display screen.    Since then we have looked at sub-routines and other ways to make programming    easier. The last couple of issues have concentrated on instructions that        increment and decrement, that is adding or subtracting one from a value,        contained in a Register or memory location.                                                                                                                     

So what's it all about then ?                                                   ----------------------------- Why is the ability to add or subtract one (01)    from a value so useful ? The answer is quite simple. It is rare to use a        computer to do a single operation such as transfer one byte to a single         location. It is far more usual to copy a large number of bytes from a block     in one place to another in memory. However, the instructions that we have       used so far, are restricted to single byte operations and have to be reset      for each and every change of location and therefore every byte transferred.                                                                                     While this can be done and indeed, it was done in a copy routine early on in    the series, it is really a bit of an awkward way to handle lots of data.        Remember, data can be anything from text to graphic backgrounds and sprites.                                                                                    For example, if you are writing a game, how would you show a spaceship          flying across a rocky moonscape ? Having drawn your rocky background for the    screen display and set up a spaceship shaped sprite, it is then a case of       copying and preserving any background before it is covered by the moving        sprite and then restoring that part of the background as the sprite moves on.   Obviously this involves a lot of data being copied back an forth and it all     needs to be done quickly and as simply as possible to avoid a flickering        display. The same of course applies to any kind of software, whether serious    or games. However, as games often feature lots graphics effects, they           usually benefit most from the speed provided by machine coded programming.                                                                                      With so much data being copied/transferred to and fro, any copying routine      needs to be quick without being too complicated. Up to now instruction          addresses have been for a single location. This means that, for example, if     you wanted to put a "Z" (code 5A) into location BE00, which is the first        location in line fifteen on the screen display, you would probably load it      into the Accumulator and then use the instruction STA BE00 (code 8D 00 BE)      to place it in that location.                                                                                                                                   OK so far, but suppose you wanted to fill the whole of that line with the       letter "Z". How would you go about that. As each STA instruction deals with     just one address, you would need another thirty nine STA instructions to        cover all the remaining locations to the end of that line, one for each         address from BE01 to BE27. It would work, but it is not a good way to do it.    Of course, you could use a single STA instruction and write a short routine     to change it's address. This was done in that "Copy Routine" back in Part 8     of the series. Again, that method works, but it is not the best solution,       particularly if you are interested in speedy operation. The 6502 Instruction    Set does contain better instructions for this kind of operation, so let's       have a look and see if there is a better way.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   There are instructions that provide the means to copy/transfer data in          larger amounts. They use an automatic system called "Indexing" which allows     the instruction address to be controlled by simply altering the contents of     Register X or Register Y. This means that you can in effect, change the         address of an instruction operation, by simply incrementing or decrementing     the contents of the appropiate Register, using a single byte instruction.                                                                                       You will find that there is quite a range of "Indexed" instructions covering    all sorts of useful operations, but for the moment we will stick to those       that handle familiar operations such as LDA and STA, used for loading and       storing the Accumulator contents. The "indexed" versions of these               instructions are very similar to the Absolute LDA and STA instructions that     we have already encountered. Indeed, they can be made to operate in exactly     the same way as those LDA and STA instructions. However, there is a subtle      difference. The address in "indexed" instruction is used as a base address      for one of a range of addresses.                                                                                                                                To see how this works, let us look again at that instruction STA BE00           mentioned above. We could instead, use an "indexed" version of it, namely       STA X BE00 (code 9D 00 BE). The "X" written between STA and the address in      the label indicates that the instruction address is indexed by Register X.      If you look at the Opcode in the instruction code, you will notice that it      is now 9D (instead of 8D as for plain STA).                                                                                                                     Now, providing that Register X contains zero (00) when "indexed" instruction    STA X BE00 is used, it will have exactly the same effect as plain STA BE00      and will put the Accumulator contents into location BE00.                                                                                                       However, suppose we set Register X contents to 01 and then use instruction      STA X BE00 ? In this case, the Accumulator item will not go into BE00, it       will be copied into location BE01 instead. Increase the value of Register X     to 02 and use STA X BE00 again and the Accumulator item will now be copied      into location BE02. Increase Register X contents to 03 and the item will go     into location BE03 and so on.                                                                                                                                   This happens all the way up to Register X containing FF, which will put a       copy of the Accumulator item into BEFF. What is happenning, is that the         instruction address (BE00 in this case) is being "indexed" by having the        contents of Register X added to it. Of course, you can use any address 0000     to FFFF as a base address in the instruction. The simple single byte            instruction INX will increment or in other words add 01 to the contents of      Register X. This provides a simple and quick way to place up to 256 (100hex)    copies of a byte in the user memory, using a short routine.                                                                                                     This would be done by incrementing Register X and then using an STA X to        place the item. Those two instructions are repeated until the whole             operation is complete. Of course you need to make the neccessary                arrangements to end the operation in right place, but you always need to do     that anyway and here you can do it by simply testing the contents of            Register X.                                                                                                                                                     

Getting a Buzz !                                                                ---------------- The short demo routine "ZZZZZZ Line" shows how "indexing"      works. Register X is started off from zero and then incremented in order to     put a copy of the item "Z" into each location on the line. A new instruction,   CPX tests Register X and will disable the BNE instruction, allowing the         operation to finish, when the line of forty "Z" characters is complete.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

Oric                       Demo Routine                            19 Nov 92    ----                       ------------                            ---------    [ CALL#1010 ]--------------[ ZZZZZZ Line ]-----------------------------[ / ]
   
         ---start---      ---Initialise---                                      1010:A2 00    : LDX# 00    : Set Register X to zero                             1012:A9 5A    : LDA# "Z"   : Put code for "Z" into Accumulator

				  ---Put items into Screen Line---                      1014:9D 00 BE : STA X BE00 : Put item ("Z") into location in Line 15            1017:E8       : INX        : Increment Register X (add 01 to it)

		              ---Test for end of Line---                            1018:E0 28    : CPX# "40"  :  Test - Fortieth "Z" put into line yet ?           101A:D0 F8    : BNE "1014" :    No - so back to put next "Z" into line.
                                Yes - so finish.....

                          ---Finish---                                            101C:60       : RTS      : Exit.
           ---end---
                                                                                                                                             The CPX instruction works in exactly the same way as the CMP instruction        that we have already used. The only difference is that it tests the contents    of Register X instead of the Accumulator. It operates on the flags in the       Status Register in the same way as CMP. Here, it is used to set the Zero        Flag for the BNE instruction.                                                                                                                                   

Variations on a Theme                                                           --------------------- If you change the CPX operand from 28 to 50(80 dec)       you will find that it will do two lines and in fact it will deal with any       value from 00 to FF(256 dec). What about larger values than FF ? No problem,    we could simply increment the high address byte (BE) in location 1016, but      we will look at that later.                                                                                                                                     If you change the address in instruction 1014 from BE00 to BBA8, the            operation will start from the first line at the top of the display. The same    operation can also be done by decrementing Register X, using the instruction    DEX. To use that method, you would start with the line end address in the       STA X instruction which for our example would be BE27 and decrement             Register X down from 27 to 00. In that case, you would find that when           Register X reached zero, it would set the Zero Flag in the Status Register      automatically, so you would not need to use CPX to test for it.                                                                                                 

We have other ways !                                                            -------------------- The routine here is just a short demonstration of how      "indexing" works There are other "indexed" instructions available. The          instruction LDA X, for example, will fetch an item into the Accumulator from    an address "indexed" in the same way, as demonstrated here. So LDA X and        STA X can used together to copy one area of memory to another.                                                                                                  Likewise, the instructions LDA Y and STA Y will also operate in the same way,   but using Register Y instead.                                                                                                                                   Thats the latest from the random buzz-word generator.....so I'll buzz off !!    As this should be in the December issue, I will take the opportunity to         wish everybody a Very Happy Christmas and New Year. Have fun with the Oric      and keep the "gloom and doom" merchants away with the old RAF motto                                                       "Nil Carborundum............."                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

		Machine Code for the Oric Atmos (Part 22)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming on the Oric. Recently, we have looked at sub-routines and other     ways to make programming easier. We then went on to look at instructions        that increment and decrement, that is add or subtract one (01) from Register    or memory location contents and the reason why that is so useful.                                                                                               The last issue, in particular used a short routine to demonstrate how one       item in the Accumulator could be copied and duplicated to fill a whole line     or more, by using a simple "indexed" instruction, controlled by the contents    of Register X or Register Y.                                                                                                                                    It has been some time since our last look at the instruction set. Since then,   we have added three new operations, plus Register Y so now might be a good      time to update our "small" instruction set. The new updated instruction set     appears at the end of this article and the first thing you will probably        notice about it is, that it has grown much larger.                                                                                                              The reason for the considerable expansion is that operations such as            "indexing" can be applied to many of the instructions that we have used         earlier in the series. Those instructions can be "indexed" in exactly the       same way as the instruction STA was "indexed" for the demo routine, in the      last article (Part 21). The extra instructions mean that you can now not        only store, but also fetch, modify and test data in fairly large quantities.    The "indexed" instructions still do the same jobs as their non-indexed          counterparts, it is just that the address used in the "indexed" version is a    base address and the final address actually used, can be set and controlled     by the contents of the appropiate Register, making it easy to set up a          simple loop for repetitive operations.                                                                                                                          Hopefully, this will also show you, how understanding a single operation        like "indexing", can make a large number of extra instructions available to     you, without too much effort. You will find that this applies throughout the    Instruction Set. There are a large number of instructions, in the Set, but      in fact they only use a relatively small number of operations. It is much       easier to concentrate on understanding those few operations, rather than        trying to memorise all of labels and codes in the Instruction Set. When you     are programming in any language, it is the operation that you need, the         instruction set labels and codes are simply there to tell you what is           available and how to use it.                                                                                                                                    To illustrate this point, look at the set of Transfer instructions, in the      table below. You will see that there are four listed. This is the first         time that we have seen any of them. They all operate in the same way.           The first instruction is labelled TAX and it is a single byte instruction       (code AA), whose label is short for "Transfer a copy of the Accumulator into    Register X". It copies the contents of the Accumulator into Register X.         I should emphasise that this is a copy operation, not a swap operation.         Both Register X and the Accumulator end up with the same value, after the       instruction's operation.                                                                                                                                        With that information in mind, it should be fairly easy to work out what the    other three instructions in the set do. As they all operate in the same way,    it should not be necessary to describe them in detail, their labels and the     above description should make any further description, unnecessary              (although I have noted what they do in the listing, anyway).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Each time this small Instruction set has appeared, I have tried to keep to      the same layout so that the additions are easier to follow. The only real       changes to the layout so far, are the addition of a quick reference columm      on the right and the use of "v" and "h" to show data and address (operands).    The latter change was made to avoid confusion with Registers X and Y.                                                                                                                                                                                                

                     6502 Instruction Subset
                     -----------------------                      Info can be    

Accumulator Instructions        Absolute            Immediate     found in
                         instruct  code       instruct  code 
 Load  Accumulator             LDA  AD vv hh       LDA#  A9 vv -  Part 3
 Store Accumulator             STA  8D vv hh
 
 Add with Carry                ADC  6D vv hh       ADC#  69 vv -  Part 6
 Subtract with Carry           SBC  ED vv hh       SBC#  E9 vv 
 
 Compare Accumulator           CMP  CD vv hh       CMP#  C9 vv  - Parts 5/6
                                                                                     Register "X" Instructions       Absolute            Immediate
                          instruct  code       instruct  code
 Load  Register "X"            LDX  AE vv hh       LDX#  A2 vv -  Part 16
 Store Register "X"            STX  8E vv hh
 
 Compare Register "X"          CPX  EC vv hh       CPX#  E0 vv

Register "Y" Instructions       Absolute            Immediate   -  Part 19
                           instruct  code       instruct  code
 Load  Register "Y"            LDY  AC vv hh       LDY#  A0 vv
 Store Register "Y"            STY  8C vv hh
 
 Compare Register "Y"          CPY  CC vv hh       CPY#  C0 vv

Transfer Instructions
                          instruct  code                       -  Part 22
 Copies Accu into Reg X        TAX  AA      no operand/data
 Copies Accu into Reg Y        TAY  A8      no operand/data
 Copies Reg X into Accu        TXA  8A      no operand/data
 Copies Reg Y into Accu        TYA  98      no operand/data
                                
Increment Instructions                                          - Parts19/2
      (add 01)

                          instruct  code
 Contents of Address           INC  EE vv hh   addr operand
 Register X  contents          INX  E8         no operand
 Register Y  contents          INY  C8         no operand

Decrement Instructions                                          - Parts19/20
    subtract 01)
                          instruct  code
 Contents of Address           DEC  CE vv hh   addr operand 
 Register X  contents          DEX  CA         no operand
 Register Y  contents          DEY  88         no operand

Flag Instructions                                               -  Part 4
                          instruct  code
 Clear Carry Flag to 0         CLC  18      no operand/data    -  Part 6
 Set   Carry Flag to 1         SEC  38      no operand/data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         		6502 Instruction Subset (continued)                                             		-----------------------                                    Conditional Branch Instructions                                 -  Part 5

     Condition             instruct code    Flag set by -
 Branch if Carry Flag = 0      BCC  90 vv   No Carry
 Branch if Carry Flag = 1      BCS  B0 vv   Carry
 
 Branch if Zero Flag = 0       BNE  D0 vv   Result Not Zero    -  Part 6
 Branch if Zero Flag = 1       BEQ  F0 vv   Result Zero
 
 Branch if Negative Flag = 0   BPL  10 vv   Result Plus
 Branch if Negative Flag = 1   BMI  30 vv   Result Minus 
                                                                                                      Jump Instructions
                           instruct  code
  Jump                          JMP  4C vv hh  (address hhvv)   -  Part 10

  Jump saving return address    JSR  20 vv hh  (address hhvv)   -  Part 10

  Return/jump from SubRoutine   RTS  60        no operand/data  - Part 3 &10
                                                                                                                                                                    IMMEDIATE (#) instructions supply the required data byte        -  Part 5
                       as the operand "vv".                                                                                                                     ABSOLUTE instructions on the other hand,                        - Part 5 & 8
         don't include the data byte, instead they give
         the address of a memory location which holds it.
         The addresses are written in reverse order,
         low part in "vv" and high part in "hh".                -  Part 3                                                                                       

INDEXED  instructions also use an absolute address as above.
         However, it is a base address. The final address       -  Part 21
         actually used is controlled by adding the contents
         of the Register indicated in the instruction label,
        (eg. LDA X uses Register "X"). Indexed versions
        of frequently used intructions are listed below. 
   
   instruct  code     instruct  code     instruct  code
	LDA X  BD vv hh    LDA Y  B9 vv hh    LDX Y  BE vv hh
	STA X  9D vv hh    STA Y  99 vv hh    LDY X  BC vv hh
	ADC X  7D vv hh    ADC Y  79 vv hh    INC X  FE vv hh
	SBC X  FD vv hh    SBC Y  F9 vv hh    DEC X  DE vv hh
	CMP X  DD vv hh    CMP Y  D9 vv hh

	Apart from "indexing" all have the same operation
	as their non indexed counterparts.

Useful Operating System Calls
                                                                                                                                   Call     JSR    Operation        Effect produced is - 
                                                                                                          "GTORKB" EB78   20 78 EB 10 FB   Puts Key code into Acumulator. -  Part 11  
                                                                                     "VDU"   F77C   20 7C F7         Displays a code from Reg "X".  -  Part 15 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           		Machine Code for the Oric Atmos (Part 23)   Peter N. Bragg                      		-------------------------------

The Age of the Dinosaurs                                                        ------------------------ So the Oric was launched on an unsuspecting world,     some ten years ago. However some of us had already aquired a few battlescars    a couple of years earlier from machines such as the Microtan 65. Tangerine      advertised the Microtan as a computer for less than £70. For that price,        plus VAT, you got a circuit board and a minimum selection of components,        which was fine, if you could do without little luxuries like building and       operating instructions, a keypad (keyboard) and power unit etc. After some      fourteen hours work that ate a complete soldering iron bit and left me about    £120 lighter, I actually had a working machine, running off a set of nicad      pencell batteries !!                                                                                                                                            Now for the easy bit. All I had to do is to program it. So open the manual      and ........... Ye Gods !! look at all them weird numbers and labels !!         What the heck do they all mean ?                                                                                                                                The hexadecimal numbering system was strange at first. Remembering to count     from "0" to "9" and then on to "A", "B" etc, up to "F" and then "10" took a     little getting used too. At least, there are no complicated calculations and    you only need to learn how to do it once. It's just a matter of getting into    the habit.                                                                                                                                                      The instructions appeared to be described in inspired gibberish. I looked up    the word "operand" in a dictionary, which said "see opcode" so I looked that    up and it said "see operand", so now I know what recursion is !!                                                                                                

Phutttttt !!                                                                    ------------ The next stage was to try to get some practical experience, so     I copied a code listing as accurately as possible, into the machine. I bet      you think that it had loads of bugs in it ??...Oh Ye of Little Faith !!         You are quite wrong. What really happened ? Well I had just entered the last    of several hundred bytes, when the nicad battery pack decided that it was       bedtime and said "Bye bye" and the Microtan promptly crashed !!!!!!             Did I tell you that there was no cassette interface ? Yup ! it's all part of    life's rich pattern !! So I entered a new instruction that invited it to go     forth and multiply itself !! After that I bowed to the inevitable and added     the expansion board and the power supply, which accounted for another           soldering iron bit, not too mention another £150. Happy days !!                                                                                                 The next problem was that the manuals were written for people who understood    all the buzz-words, which cut me out. It might have been easier if I had        been able to join a computer club, however my commitments mean't very           unsocial hours so I couldn't get to a club.                                                                                                                     So, it was a case of DIY or nothing. I spent a fair bit of time while           travelling, reading up on the 6502 Instruction Set and compiling my own         brief description of how each instruction operated and what it did. Any         instruction that was difficult to understand, was tried out on the Microtan.                                                                                    

The Light Dawns                                                                 --------------- It soon became obvious that the sixty odd instructions were     in fact made up from a combination of a smaller number of fairly simple         operations. It was only necessary to become familiar with that small            collection of operations to have a key to all the programming facilities in     the computer. For me, it is much easier to remember a small number of           operations, than a much larger collection of labels and codes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  All languages, on the Oric, not just machine code, are simply products of       that small collection of operations. Once I had got to grips with most of       those operations, all I needed for programming, was a small crib card           listing the Instruction Set, plus a few addresses and other useful bits of      information.                                                                                                                                                    I also found it a lot easier to write programs in terms of operations such      as "fetching this" or "testing that" and "branching there" etc, which is why    my programming is backed up by a fair amount of descriptive notes.                                                                                              

The Instruction Subset                                                          ---------------------- The 6502 Instruction Subset published in the last        article is simply an expanded version of part of my own listing of the full     6502 Instruction Set, which I use as part of a "crib card" set.                                                                                                 The subset published in the article, is by no means, the whole of the           Instruction Set. There are still quite a few instructions, yet to be covered,   as you will see if you compare it with the full 6502 Instruction Set, which     can be found in many books and manuals, including those for the Oric.                                                                                           If you look at it you will see that the subset has been subdivided into         groups each containing a small set of instructions that are either similar      in operation (eg.Branch Instructions), or they are related in some way          (eg. Jump Instructions).                                                                                                                                        The subset is headed by three groups for the three main registers,              Accumulator, Register "X" and Register "Y" and it is easy to see that the       basic operations for these three are very similar. Hopefully, setting out       the instruction set in this way, concentrating on the operations that can be    done, will make it easier to use. You dont have to learn every label and        code. Look them up in the subset, as and when you need them.                                                                                                    

Crash Course                                                                    ------------ Hopefully, by now, you have more than enough in our small          subset to try some practical experiments of your own. Do have a try, because    you will learn far more that way, than you will ever learn, by simply           reading about it. At the very worst, you may well crash the computer, but       providing you have saved your work before you actually try it out, there is     no harm in that and you only need to reload to try again. Anything new,         seems difficult when you first try it. However, once you have tried a few       simple experiments of your own and have managed to get some of them working,    you will quickly find that it all becomes a lot easier. Sorting out a           program fault (debugging) might seem difficult at first, but you will be        surprised how much you can learn about programming in the process of finding    and correcting your mistakes.                                                                                                                                   The golden rule, as I have said before, is to keep it small. It is far          easier to write and debug a lot of short routines rather than one very long     one. After all, once you know that each routine works and will do what you      want it to do, you can then build up, by combining successful small routines,   one by one, to make up larger routines, if you really need to.                                                                                                  Programming in any language, takes a little time to get it right. Dont worry    if it does not work out first time. There are often several ways to get the     right result and the software you write, is the best software you can have.                               ...................                                   "People who say it cant be done are often interupted by people doing it"         (quote from "SAM Speaks")                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            


		Machine Code for the Oric Atmos (Part 24)   Peter N. Bragg                      		-------------------------------

The Story so far                                                                ---------------- We started out by looking at the very basic requirements       for writing machine code programs on the Oric. Gradually, as the series has     progressed, we have built up a modest collection of useful instructions.                                                                                        The collection so far, was published in the form of a small 6502 Instruction    Subset in Part 22 of the series. We also had a brief look at the Instruction    Set in terms of the operations it can do, with the aim of making it easier      to use. Essentially, it came down to writing each program routine as a list     of simple operations and then using the Instruction Subset to find a            suitable instruction for each of those operations.                                                                                                              

Keep it Simple                                                                  -------------- Of course, even if you use the full Instruction Set, you may     still find that there is no instruction for the operation that you want to      do. Assuming that you are not trying to do something that is beyond the         capabilities of the hardware, the problem is most likely to be caused by the    fact that the operation that you are trying to do, is too complex. Bear in      mind that the instructions are basically very simple operations and are best    used as building blocks to produce the more complex operations.                                                                                                 So the best way to deal with the problem, where you cannot find a suitable      instruction, is to break the operation down into a number of smaller and        simpler operations.                                                                                                                                             

Clear Off !!                                                                    ------------ Take a simple example, lets assume that we want to clear the       text screen using a machine code routine. There is a routine in the Oric's      Operating System that does this. However, lets assume that we cannot find       anything that will clear the screen for us. This means that we now have to      write our own routine to clear the display.                                                                                                                     So how do you clear a display ? Well, the best way is to put the code for       "Space", which is 20h, into every location in the screen memory area.           Now, the operation can be broken down into a sequence of several simpler        operations such as, load the code for "Space" (20h) and store in the first      screen location. Move to the second screen location and repeat the operation.   Repeat until end of screen memory area is reached. End of operation.                                                                                            Doing it this way, the "clear the screen" operation, has now been broken        down into several smaller operations, each of which can be done by an           instruction from the subset. Collect them together into a routine and you       have a "clear the screen" operation. There is not much point in going on        to produce a routine at this point and anyway, we have already covered          something very similar, back in Part 6 of the series. Here, the main idea       was to use a well known function, to illustrate how to break up a complex       operation into several smaller and simpler bits. Doing it this way, makes       the whole operation much easier to program.                                                                                                                     Of course, it always makes sense to check the manuals as far as possible        before setting out to write any routine. It is a waste of time and effort       to duplicate something that is already available for us to call up, in the      Operating System. For example, included in our Subset, but not actually part    of the 6502 Instruction Set, were two Oric Operating System calls which         allow you to read a keypress from the keyboard and also write to the Text       screen display. The keyboard reading call included a small addition.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

The Operating System Calls                                                      -------------------------- We have already made use of these two system         calls. This time lets have a look from a different point of view. First of      all, these two particular system calls are specific to the Oric Atmos and       will not work on other computers. However, you will find that there will be     an equivalent pair of operations on other machines. In fact, it is difficult    to see how any microcomputer could possibly operate without these two           functions. Of course these two operations will be called from and will have     different addresses in other computers.                                                                                                                         

Press a Key                                                                     
----------- The keyboard reading operation ("GTORKB") as noted in our           Instruction Subset is in fact a short routine of two instructions, which        when called, stops all operation until a key is pressed. The code for that      key can then be found in the Accumulator. The second instruction, a Branch      BPL, produces a loop in effect, and is needed in order to tell whether a        key has actually been pressed, otherwise the keyboard would only get a brief    test in passing and there would be no way of telling whether the Accumulator    contents were the result of a genuine keypress.                                                                                                                 This short routine mimics the same system call that I have found on all the     other computers that I have used. This is handy when converting software for    other machines (eg Apple or BBC) and produces a similar effect to the Oric      Basic GET command. Can be useful too, if you are interested in emulators.                                                                                       If you are writing a game, you will probably be more interested in a version    of the Oric Basic KEY$ command, where the keyboard is only looked at for a      brief moment, before the action continues. Again, you still need the BPL        Branch to tell you if the Accumulator contains a genuine keypress result,       however, in this case you do not need to keep looping back, the BPL Branch      can be used instead to deal with a keypress, if and when it arrives.            Probably the simplest option here would be to change the short routine          slightly to 20 78 EB 10 03 8D vv hh, to include a third instruction to put      any genuine keypress result into a storage address "hhvv".                                                                                                      To explain that in a little more detail. 20 78 EB is instruction JSR EB78       and 10 03 is the instruction Branch BPL, which operates when the Negative       Flag is cleared (no key pressed). The BPL is set to 03, which makes it skip     the third instruction, which is STA hhvv (written as 8D vv hh). However if a    key is pressed, the negative Flag will be set which disables the BPL Branch     so that the STA instruction will then store the contents of the Accumulator,    for future reference. The location "hhvv", in the STA instruction, is any       address that you care to use for storing the Accumulator contents.                                                                                              The above is a very basic approach. It is probably much better to use a JSR     instruction in place of the STA instruction and make it go to a routine set     up especially to deal with a keypresses as and when they happen. If you can,    have a look at Parts 12 and 13 of the series, which dealt with routines for     testing and sorting out specific keypresses.                                                                                                                    If you have the Oric-1 machine, you should use 20 05 E9 which is JSR E905       for the "GTORKB" system call, instead of JSR EB78, because your operating       system is slightly different. The same applies to the system call "VDU" for     displaying items on the Text screen. The call for Oric-1 is JSR F73F for        "VDU" (20 3F F7), and uses Register X for the display code, like the Atmos,     so I understand. This is different from other machines that I have used so      far, but it is not a problem................More machine-speak next time...                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           


		Machine Code for the Oric Atmos (Part 25)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We started out by looking at the very basic requirements       for writing machine code programs on the Oric and we have now built up a        modest collection of useful instructions in form of a small 6502 Instruction    Subset which appeared in Part 22 of the series. In addition to looking at       the Instruction Set, I have also tried to give an idea of some of the           programming techniques that I have found make life easier for me, when          writing software.                                                                                                                                               One technique, was that of breaking up a large operation into several           smaller operations. These smaller operations are then easier to match up to     the instructions available in the 6502 Instruction Set and can be assembled     in to a small routine, to do the required larger operation.                                                                                                     Last time, we looked at one of the two most important system calls on the       Oric. While these are not strictly part of the 6502 Instruction Set, they       are an essential part of any microcomputer operating system, so you can         expect to find similar calls to do the same operation on other machines too     I have found that there is a lot to be gained from using other computers,       with the Oric, particularly if they also use the same 6502 Instruction Set.                                                                                     

Foriegn Devils                                                                  -------------- In the last article, we looked at the call "GOTORKB" which       reads the keyboard and puts the result into the Accumulator. Before we go on    to other things, lets have a brief look at that call on other 6502 machines.                                                                                    Why bother ? Well, for a start other machines are a good source of software     and a number of Oric users appear to have a second machine, some of which       are 6502 based or have 6502 emulators.                                                                                                                          All the 6502 based machines I used so far, use a similar system call to read    the keyboard and put the result into the Accumulator. Oric's system call for    this, is in fact very similar to that used on the Microtan, Apple and BBC       computers. The only real difference is, that Oric's keyboard reading call       does need a Branch instruction added to it, to check for a keypress. However,   the two instruction set up, shown for "GOTORKB" in our small Instruction        Subset, will indeed make it work in the same way as other machines, such as     the Apple or BBC. Useful if you are writing software to run on more than one    machine.                                                                                                                                                        

Vectors                                                                         ------- The Oric's Operating System calling addresses are different from        those used by other computers of course. However, the two instructions to       read the keyboard can be made into a tiny stand alone routine by adding an      RTS instruction. This can then be put anywhere in "user memory" to provide a    "call address" of your own choosing, instead of that required by the            Operating System. This brings us to another interesting and useful point.       If you are using another 6502 based machine, you can do the same thing with     that machine and put a routine to make the same call, from the same address.                                                                                    For example, as I have mentioned before, I went from the Tangerine Microtan     to the BBC computer and the Oric followed on about a year later. Now, the       BBC has it's own idiocyncrasies. I wont go into details here. Sufficent to      say that I needed to write a small series of short routines to adapt the        Microtan software for use on the BBC computer. These routines were written      in a block and put into Page 20 (ie. 2000 - 20FF area), in the BBC machine.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     A very short "stand alone" routine called up the BBC equivalent of Oric's       GTORKB and also preserved a copy of the keypress result in memory. Just         three instructions were needed for that short routine, a JSR for the call,      an STA to preserve a copy of the result and an RTS to complete the routine.     The routine was then included in the bootup software both on tape and later     on disk and all my own software read the keyboard through the routine which     was called by JSR 202C. I should mention that there is nothing significant      about that address, it was just a convenient place to fit the routine in        among others.                                                                                                                                                   Now, when the Oric arrived on the scene, I found that it needed an extra        instruction to read the keyboard in the same way as the BBC version. This       time, the routine had to be a JSR plus a BPL Branch instruction, which was      then followed by the STA and RTS. The routine was put into the Oric, to         start at 202C again, exactly the same place as the BBC version. So once         again the keyboard reading was called up by JSR 202C, only this time it was     the Oric. This meant that all my own BBC software was completely compatable     with the Oric as far as reading the keyboard was concerned.                                                                                                     The Apple computer was slightly different again. It did not require the BPL     Branch, but it did need an extra instruction to modify the keyboard input so    that it matched the input obtained from the Oric and the BBC computers. Once    again, a short routine of four instructions, was put into the bootup            software in the same place as the BBC and Oric, so that the keyboard would      always be read by calling JSR 202C. Making it a common call for all three       machines did a lot to simplify the job of writing software, for them all.                                                                                       Now, it takes a lot more than this to make the three machines completely        compatable, even for own design software. However, some operating system        calls get heavy use when writing software. Obviously reading the keyboard is    one of those. Displaying items on the screen at the cursor position is          another. You dont have to have a BBC or Apple computer to make use of this      technique, any 6502 based machine can benefit from the same technique.          Likewise, you dont have to use the above example address. Better to use one     that suits you and your own software.                                                                                                                           This type of "call" routine is known as a vector and there are many people      who claim to have invented it !!  The main advantage becomes apparent, when     a computers Operating System is changed. An alteration to the "vector"          routine, is all that is needed to update old software and get it working        again.                                                                                                                                                          Using a few common vector calls like this has made writing software very        much easier for me to run several different machines with just one basic lot    of software. As a result, some of my BBC software was written on the Oric       and some of the Oric's was written on the BBC.                                                                                                                  Of course, the same techniques are widely used in comercial software and        firmware to produce clones of popular computers. However, this is not an        emulation and you should bear in mind the "law of diminishing returns" if       you intend to head in that direction. A few well chosen vectors, like the       above keyboard example, are fairly easy to produce and are immensely useful,    when you are writing your own software. However, as you come to the more        obscure functions, they get harder to write and are much less useful.           Of course the real limiting factor in the end, is the hardware. Have a look     at books for other eight bit machines, particularly those for the BBC and       Apple machines. it is surprising what can be achieved with a little             imagination and inspiration. Next time................A stack of Oric's !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            


		Machine Code for the Oric Atmos (Part 26)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We started out by looking at the very basic requirements       for writing machine code programs on the Oric and we have now built up a        modest collection of useful instructions in form of a small 6502 Instruction    Subset which appeared in Part 22 of the series. I have also tried to give an    idea of some of the programming techniques that make life easier for me,        when writing software.                                                                                                                                          In the last couple of articles, we looked at one of the most important          system calls on the Oric, the one that reads the keyboard input and we also     looked at the same call in use on other 6502 based computers. The reason for    looking at the same operation on other machines, was to make a wider range      of software and information available for use with our own Oric.                                                                                                

Easy Graffiti                                                                   ------------- OK so we can read the keyboard. The next thing is to be able      to display items on the screen. Like the keyboard call, we have also looked     at this display call before. However, it is worth having another look and       furthermore, it will provide the opportunity to introduce a new set of          extremely useful instructions.                                                                                                                                  First of all I will remind you that there are two ways of displaying items      on the Text Mode display. One is to poke display code directly into an          address in the screen RAM area (BBA8 - BFDF). This is OK for some purposes,     but of course you have to set up the address for each and every item.           The other way is to use the system call "VDU". This call puts each item for     display into the current cursor position and then automatically updates the     cursor position, ready for the next item.                                                                                                                       The second method is obviously easier if you are entering a long string of      display items, such as text (ASCII) codes. All you need to do is to load        each item for display, one at a time into Register "X" and follow each one      with a call to "VDU", which is JSR F77C for the Atmos. (For the Oric-1 the      call is JSR F73F.) The display location addressing is all taken care of,        automatically by the Operating System call. (See Part 15 for more detail.)                                                                                      One thing about this arrangement, that seemed a little odd to me, was using     Register "X" to hold the data item for the "VDU" display call. Now obviously    Tangerine/Oric International felt that they had a good reason for using         Register "X" for the job. However, all other 6502 computers, I have used        including the Tangerine Microtan, use the Accumulator. So does it matter ?                                                                                      Well, if you have been following the series for some time, you may have         noticed that while Register "X" and the Accumulator are very similar in some    respects, there are differences, which make each of them more suitable for      some operations and less suitable for others. Register "X" is best used as a    counter or to provide an index for the purpose of fetching and transferring     large amounts of data, whereas the Accumulator is much better for single        byte operations, such as display calls                                                                                                                          If you are writing software, it is quite likely, that you will want to use      both "X" and "Y" for other purposes. You may be using "X" as an index, in       order to fetch a lot of data items for the display. In this case you would      need to preserve the contents of "X", each and every time you used the call     "VDU" to display an item. Otherwise those items would overwrite the index.      What is needed is a nice and easy way to deal with the problem if it occurs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    A simple temporary storage system would be very useful for this sort of         problem and this gives us the opportunity to have a look at the 6502            microprocessor's Stack. So what is the "Stack" and how is it used ?                                                                                             

The Stack                                                                       --------- In brief, the Stack is a quick and easy means of temporary storage.   For example, it can be used to park the current contents of a Register,         while you use that Register to do another job. When you have finished using     that Register for other purposes, you can go back and retrieve the item that    you stored on the Stack.                                                                                                                                        The whole thing operates automatically. This means that a single one byte       instruction will store a copy of the Accumulator contents on the Stack and      another single byte instruction will retrieve that stored item and put it       back into the Accumulator again.                                                                                                                                The Stack is actually an area of the "user memory", which covers all the        addresses 0100 to 01FF, an area also known as "Page 01". It is controlled by    the Stack Register (or Pointer). This Register holds an address, but as it      "points" to Page 01 only, the top half of the address is always fixed at 01.    So the value of the Stack Register is restricted to the addresses 0100 to       01FF. In the good old computer tradition of always doing things the opposite    way to normal, the Stack starts from the top address 01FF and works it's way    downwards for storage. This is known as "top/down" operation. The actual        storage system is a type of operation known as "LIFO", which as many people     will know only too well, means "Last In First Out". The last item put on the    Stack, is always the first item retrieved from it.                                                                                                              

Push Off !!                                                                     ----------- Well push on and pull off, really. Thats how the Stack operates.    The two main instructions are PHA and PLA. There are others, of course, plus    some that make use of the Stack. If you have ever wondered where the            instruction JSR stores that "return address", ready for the RTS instruction,    look no further, it's somewhere on the Stack. At this point, I should           mention the "Golden Rule" for using the Stack is to leave it as you found it.   In other words, if you use the Stack as a temporary "parking space", remove     the item, before you leave the current routine, otherwise the "RTS"             instruction will use it as part of its return address and take a leap into      the wild blue yonder !!                                                                                                                                         Let's look at two instructions. Both of them are single byte instructions.      The first is PHA (code 48), which "Pushes" a copy of the Accumulator            contents on to the Stack. The item pushed on to the Stack, can then be          retrieved by the instruction PLA (code 68), which "Pulls" the item off the      Stack again and copies it back into the Accumulator. Simple enough and no       messing about with addresses. All you have to remember is that, if you are      preserving several items in this way, they will come off the Stack in the       reverse order. That is to say the last item on, will be the first off and       the first on will be the last off.                                                                                                                              So, it is easy to preserve the contents of the Accumulator temporarily,         while you use it for something else. There isn't an instruction to put the      contents of Register "X" on the Stack (at least, not as far as the Oric is      concerned). However, this is not a problem. If you look at our Instruction      Subset, you will find a set of four "Transfer" instructions. One of these       can be used to pass "X" (or "Y") to the Stack, via the Accumulator and that     procedure can be reversed to return the item to Register "X" again.             

More info on the Stack, next time.........................So see you then !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           


		Machine Code for the Oric Atmos (Part 27)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We started out by looking at the very basic requirements       for writing machine code programs on the Oric and we have now built up a        modest collection of useful instructions in form of a small 6502 Instruction    Subset which appeared in Part 22 of the series. Last time, we had another       brief look at the Text display call and then went on to look at the Stack.                                                                                      

"See Thru" Software !!                                                          ---------------------- I had better explain, before our editor runs his blue    pencil through this lot. You may well have heard of software described as       being "transparent". So what does "transparent" mean in computing terms ?                                                                                       Essentially, "transparent software" is software that leaves the computer in     the same state after it has been run, as it was before it was run.              For example, you run your favourite game for a while and then decide to quit    and run something else. What happens ? Does the Oric exit cleanly, so that      you can go straight on to load something new ? Or does it hang up on you and    force you to re-boot ?                                                                                                                                          A clean exit, defines the software as "transparent", as everything was          restored to what it was before the game was run. If you were not able to        exit and had to re-boot, the software was definitely not transparent.           That just illustrates the basic principle. It isn't necessary to restore        everything, I have seen software that restores the original display, but        that is really overdoing it. You only need to restore the things that you       have made use of and for machine code programs, that can be quite easy.                                                                                         To be fair, I should point out, that some software is deliberately designed     not to be "transparent" to protect it from illegal copying. Transparent         software is easy to read and copy and although that might be good for our       programming, it is the last thing that many professional writers need !                                                                                         

Transparency - Do we need it ?                                                  ------------------------------ It may be neat, but is it really necessary ?     For me, the answer is definitely yes. For the reason, I need to recap           briefly. The main aim of this series is to show how to write machine code       software in a form that is easy to follow and understand. The key word,         is "understand". That is the key to successful programming in any language.     A routine of a few bytes is fairly easy to understand, but as we get more       ambitous, it becomes more difficult to retain a complete knowledge of what      we have written and how it all works. This is a real stumbling block, even      for the professionals. If you hear someone rubbish that, just mention London    ambulances or the Taurus system. You can bet that those and other disasters     were caused by programmers losing track of the software, they were writing.                                                                                     So how do we avoid that sort of problem ? As I have said before, the best       way to write a large piece of software, is to split it up into smaller          pieces to make it easier to handle. It is a good idea to try to make each of    those small pieces into completely independent modules as far as possible,      so that they can be used as simple building blocks to construct larger and      more ambitous software without too much hassle. Each module would consist of    a number of instructions in the form of one or more routines to produce a       specific operation. All that is needed then, is a good descriptive label for    each module. The main program is then constructed by using the modules as       building blocks. I usually start off with just a few modules and write more,    as and when, they are needed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   The advantage of this programming technique is that the main program is         essentially a listing of the module labels, which of course reads more or       less as plain English. Better still, the labels dont have to be in English,     any language that suits you, would work just as well. Doing it this way         makes it all much more readable. The individual machine code listings can       also be kept fairly brief, which makes them easier, too.                                                                                                        For me, this is by far, the easiest way to write software. However, if the      modules are going to be used as simple building blocks, in this way, it is      best to make sure that they dont interfere with each other, as far as           possible. This is the reason for "transparent" software. If the modules are     transparent, they will not clash with each other.                                                                                                               

Writing Transparent Software                                                    ---------------------------- It is quite easy to do this in machine code.       Usually, all you have to do is to preserve and restore the contents of the      registers and obviously this only applies to registers actually used. We use    three main registers to do the counting, fetching and handling data, so         let's look at these first. They are the Accumulator and Registers X and Y.      Each of our routines may well use one or more of these three and may well       require that the contents of the register(s) used, are restored after use.                                                                                      So how do we go about preserving the contents of those three registers ?        Well, this is where the Stack, becomes very useful. We looked at the Stack      last time and if you remember, it provides a one byte instruction (PHA), to     preserve the Accumulator contents and another (PLA), to retrieve them and       return them to the Accumulator again.                                                                                                                           That is fine for the Accumulator, but what about Register X and Register Y ?    The Oric lacks a Stack instruction for "X" and "Y". No problem ! Look at our    small Instruction Subset and you will find that there are four, one byte,       Transfer instructions for copying the contents of Registers X and Y to and      from the Accumulator. To preserve the contents of Register X, you simply        transfer them (TXA) to the Accumulator and push (PHA) that onto the Stack.      Of course this will overwrite the contents of the Accumulator so you may        well want to preserve that too. How to do all this, is illustrated below.                                                                                       

[ JSR nnnn ]---------------[ Any Routine ]--------------------------------]
                   
        ---start---      ---Preserve Accu and Reg X---                         nnnn:48       : PHA        : Push Accumulator contents on Stack
    :8A       : TXA        : Copy Register X contents to the Accumulator
    :48       : PHA        :   and then use it to push them on to Stack.
  ...............................................................
  : Any operation that is put in here will now be "transparent" :
  :          to both the Accumulator and Register X.            :
  :.............................................................:
                         ---Finish---
                            Retrieve original Register X contents
    :68       : PLA        :  by pulling them off the Stack into Accumulator
    :AA       : TAX        :   and then copying them into Register X.
    :68       : PLA        : Now retrieve original Accumulator contents.
    :60       : RTS        : Exit (with Accumulator and Register X unchanged)
          ---end---                                                             That's how it's done.....and theres more, where that came from next time !! 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 