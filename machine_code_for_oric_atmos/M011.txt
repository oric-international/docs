Machine Code for the Oric Atmos (Part 63)   Peter N. Bragg                      -------------------------------                                           

The Story so far                                                                ---------------- We have been looking at Interrupts in recent articles and      we had reached the stage in the last article, of producing a demonstration      ("Test Indicator") routine, plus two short routines that would link that        demo routine, to the Oric's Interrupt system.                                                                                                                   The two short routines were, an "Interrupt Extension" routine, which allowed    the demo routine to be included in the system's Interrupt software without      "crashing" the system and a "Set New Interrupt Vector" routine which put the    calling address of the extension (and demo) routines, into one of the           operating system Interrupt vectors.                                                                                                                             The demo routine was just that, a demo nothing more. It could be replaced by    any other software operation you might wish to incorporate into Oric's          Interrupt system. That could then be simply called by the Interrupt             Extension routine, in the same way as the demo routine was called.                                                                                              The Interrupt Extension routine is used to ensure that any operation called     by it (ie. the demo routine), is able to make a clean entry and exit from       the Interrupt system, without corrupting any of the microprocessor's            registers. This routine is the essential minimum needed to call any software    operation that you may wish to add to the Interrupt system.
                                                                                                     Setting a New Interrupt Vector                                                  ------------------------------ This brings us to the third routine, which       was "Set New Interrupt Vector". This aimed to provide an illustration of how    to link into the Interrupt system, by writing the Extension routine calling     instruction into one of the Operating System vectors.                                                                                                           The routine simply set the Accumulator and poked the instruction, one byte      at a time, into the vector location. OK as an illustration of what is needed,   but not a good piece of software writing.                                                                                                                       It is not the best way to set the vector because it tends to be a bit of a      "one shot" affair. Once you have called it, thats it and you are stuck with     it, until you switch off the computer. There are better ways to provide the     link-up, which can provide more control and thats what we will look at next.                                                                                    Essentially, we can leave the demo and the extension routines exactly as        they are now and concentrate on improving the method of setting a new           interrupt vector.                                                                                                                                               The best way to do this is to set aside a small area of memory to use as a      parameter block and use this to store the two lots of vector contents. Now      we can start up our own Interrupt extension operation by first copying the      vector (#024A/4C) contents into the Parameter Block at #8002/04, to preserve    it for future use and then replace it with the instruction to call our own      extension routine, which can be found in the Parameter Block at #8006/08.                                                                                       The two routines that do this, are exactly the same in operation, the only      difference between them, are the addresses of the items copied and their        destinations, as noted above. The two routines "Copy Vector" JSR#8010 and       "Set New Vector" JSR#8026, are linked together into a single operation by       the short routine "Set Extension Vector" and are put into operation by the      CALL#8054. Once again this will run the Interrupt demonstration routine as      before, but in addition, it will preserve the original system vector.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Now all we need is another routine, exactly the same operation as above, to     copy and restore the original system vector, using the copy stored in the       Parameter Block. This is done by the routine "Restore Orig Vector" CALL#8040,   which, when called, will immediately restore the system to normal operation     and disable the extension (and demo) routine.                                                                                                                   So we now have the means to turn the demonstration, on or off, whenever we      wish. Simply CALL#8054 to set the Interrupt demo routine in motion and          CALL#8040 to stop it. Better still, we can do the same to any other             interrupt operation, that we may wish to substitute for the demonstration       routine (JSR#8070), in other words, it can be started up or stopped at any      time, by making those two calls, or using JSR instructions to call them         instead.                                                                                                                                                        This is not a perfect software operation as it is open to improvement. One      such improvement, might be to change the "RTI" (40h) instruction at #806D to    a jump (4C 02 80 ie JMP#8002), which would then handle any other changes        made by other software to the Operating System vector. There are others.        However, to follow them up here, would be getting away from the original aim,   which was simply to show an example of how to set up your own interrupt         operation. Just remember, there is more than one way to achieve a result.                                                                                       In the meantime, here is the complete listing, as described above, ready for    your assembler or code writer. CALL#8054 to run it and CALL#8040 to stop it.    That's about it for this set of routines.................See you next month.
                                                                                     Oric                       Demo Routines                         26 Dec 96      ----                       -------------                          --------      [--------------------------[ Param Block 8000 ]----------------------[1/2]
         ---start---                                                            8000:FF       :            : Param Block Marker (optional)

8001:         :            :   .....not used.......
                                                                                                             8002:40       : RTI        : Usual contents of "INTSL" vector as they           8003:00       :            :  would appear after being copied by                8004:00       :            :   the routine at #8010-022.
                                                                                                        8005:         :            :   .....not used.......
                                                                                                             8006:4C       : "JMP" to   : The instruction which is copied into the           8007:60       :   #8060    :  "INTSL" vector, by the routine                    8008:80       :            :    at #8026-38.
          ---end--- 
                                                                                                                                            [ JSR 8010 ]---------------[ Copy Vector ]-------------------------------]
         ---start---                                                            8010:AD 4A 02 : LDA 024A   : Load Accumulator with vector 024A item             8013:8D 02 80 : STA 8002   :  and copy it into Param 8002.
                                                                                                      8016:AD 4B 02 : LDA 024B   : Load Accumulator with vector 024B item             8019:8D 03 80 : STA 8003   :  and copy it into Param 8003. 
                                                                                                     801C:AD 4C 02 : LDA 024C   : Load Accumulator with vector 024C item             801F:8D 04 80 : STA 8004   :  and copy it into Param 8004.
                      ---Finish---                                          8022:60       : RTS        : Exit
          ---end--- 

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Oric                       Demo Routines                         26 Dec 96      ----                       -------------                          --------      [ JSR 8026 ]---------------[ Set New Interrupt Vector ]--------------[2/2]
          ---start---                                                            8026:AD 06 80 : LDA 8006   : Load Accumulator with Param 8006 item              8029:8D 4A 02 : STA 024A   :  and copy it into vector at #024A. 
                                                                                                802C:AD 07 80 : LDA 8007   : Load Accumulator with Param 8007 item              802F:8D 4B 02 : STA 024B   :  and copy it into vector at #024B.
                                                                                                 8032:AD 08 80 : LDA 8008   : Load Accumulator with Param 8008 item              8035:8D 4C 02 : STA 024C   :  and copy it into vector at #024C.
                      ---Finish---                                          8038:60       : RTS        : Exit
          ---end---                                                             [ JSR 8040 ]---------------[ Restore Orig Vector ]-----------------------]
          ---start---                                                            8040:AD 02 80 : LDA 8002   : Load Accumulator with Param 8002 item

8043:8D 4A 02 : STA 024A   :  and copy it into vector at #024A.                                                                                                 8046:AD 03 80 : LDA 8003   : Load Accumulator with Param 8003 item

8049:8D 4B 02 : STA 024B   :  and copy it into vector at #024B.                                                                                                 804C:AD 04 80 : LDA 8004   : Load Accumulator with Param 8004 item

804F:8D 4C 02 : STA 024C   :  and copy it into vector at #024C.
                      ---Finish---                                          8052:60       : RTS        : Exit 
          ---end---                                                             [ JSR 8054 ]---------------[ Set Extension Vector ]----------------------]
         ---start---                                                            8054:20 10 80 : JSR 8010   : Copy orig vector into Params 8002/04 and then      8057:20 26 80 : STA 8026   :  set new vector jump from Params 8006/08.
                      ---Finish---                                          805A:60       : RTS        : Exit
          ---end---                                                             [------------------------------------------------------------------------]        Interrupt Extension routine.            Test Indicator routine.
          ---start---                            ---start---                    8060:48       : PHA                     8070:EE A5 BB : INC BBA5 
                                                                                               8061:8A       : TXA                     8073:AD A5 BB : LDA BBA5                8062:48       : PHA                     8076:C9 80    : CMP #80 
                                        8078:D0 05    : BNE"807F"               8063:98       : TYA                                                             8064:48       : PHA                     807A:A9 20    : LDA #20
                                        807C:8D A5 BB : STA BBA5                8065:20 70 80 : JSR 8070
                                        807F:60       : RTS                     8068:68       : PLA                               ---end---                     8069:A8       : TAY                     [-------------------------]                                                                                             806A:68       : PLA              The additional two routines, listed            806B:AA       : TAX              in brief here, were more fully
                                 covered in the listings and notes
806C:68       : PLA              in Part 61 and are only included to
                                 complete the operation, described in           806D:40       : RTI              this article.
          ---end---

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Machine Code for the Oric Atmos (Part 64)   Peter N. Bragg                      -------------------------------                                           

The Story so far                                                                ---------------- We have been looking at Interrupts in recent articles and      last month we finished up with a set of routines that can be used to extend     the Oric's Interrupt System to include a piece of software of our own.                                                                                          The actual piece of software used at that time, was a single demonstration      routine, supported by four other very short and simple routines, which          enabled the demonstration routine to be linked up to the Interrupt system.
                                                                                      So what do you know ?                                                           --------------------- If you tried the brief set of routines, as published      in the last issue, you will have noticed that the result did not appear to      be very spectacular. However, the demo can tell you quite a bit about the       Interrupt system and can also be useful for other things. Let's see what we     can learn from the results.                                                                                                                                     The demo indicates each call to the Oric's interrupt system, by changing a      character on the screen display. As the demo routine is small, compared with    the rest of the Interrupt routines, it has little effect on the system and      therefore is able to give a fair indication of how often the Interrupt          system is called and how fast it is. Remember the Interrupt system is also      dealing with all the calls that keep the keyboard, screen display and other     essential services operating and updated. In fact, it is so fast that the       character used as an "indicator" on the screen, is almost a blur, because       there are so many Interrupt calls and they are serviced so quickly.                                                                                             Speed is only one aspect of the demonstration. The demo routine also shows      that the Interrupt system operates continuously in the background and           appears to be quite independent of anything that the "user" may be doing on     the computer at the same time. So you can write a program, list it and run      it, all without stopping the demonstration, providing of course, you don't      change anything in the Interrupt system, while doing so.                                                                                                        Logically enough, the only things that will affect the demo routine's           operation, will be those that make use of the interrupt system themselves.      For example, disk operations will affect it briefly as they also use the        Interrupt system, in their operations.                                                                                                                          Note that while the demonstration "Test Indicator" routine is running, it       actually part of the Interrupt system and should you do anything to corrupt     or overwrite it, the Oric will stop immediately and "hang up". This only        applies to the "Test Indicator" routine. The other four routines simply         provide the means to start up or stop the demo routine.                                                                                                         This shows why most of the important parts of the Interrupt system are put      into ROM, where they cannot be overwritten. Those of you who may have been      following this series of machine code follies, for some time will have          noticed that, whereas I normally put demo routines in and around Page10         (#1000 upwards), the routines for this Interrupt demo were put a lot higher     up in Page80 (#8000 upwards). This puts them out of harms way, while still      leaving plenty of room for other software.                                                                                                                      So much for the demo routine. The other four routines that were used to         provide the launch pad for the "Test Indicator" routine could be useful,        because they can be used to launch or terminate other interrupt software in     the same way that they were used for the demo routine.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          If you wanted to use those routines for your own interrupt software, all you    would need to do, is to load the whole demo set and then scrub out the short    "Test Indicator" routine in #8070-807F. Write your new interrupt software to    start and be called from #8070. Your own software can now be started and        stopped using the same calls as were used for the demo routine. There should    be plenty of room for any interrupt software you may wish to write. In my       own Atmos, the RAM is free up to #96FF.                                                                                                                         You may not need all that much room and could, if you wish, move the            routines up to a higher address, by changing just nine instruction addresses.   If for example, you changed all instruction address (hi bytes), that are set    to Page80, from 80 to 90 (for Page90), you could copy the routines upwards      to start at #9000, which would give you an extra 4K RAM space for other         software lower down. That would still leave half a dozen Pages of RAM for       your interrupt routines. This is a simple way to move small pieces of           software. If I need to shift software/routines for any reason, I always try     to move it in whole Page units (100h bytes), which makes shifting it easier.                                                                                    We have seen how the Interrupt system works and now have a set of routines      which will link any software which we might want to write, into that system.                                                                                    A series on machine code, would be incomplete if it didn't include some         details about the Interrupt system and as you will have gathered by now, it     requires a fair bit of explanation. You may be asking at this point, what       can it be used for ? I have used it on a couple of occasions, but in both       cases I used extra hardware, specifically the VIA 6522 extension board as       published in the "Advanced User Guide". While much of the time, the             Interrupt system is used to control hardware, it can also be used in a          purely software environment, on the Oric.                                                                                                                       For one example, there have been various pieces of software, that allow the     computer to play background music, while it is doing something completely       different. Now, I am no musician, although I do like music, there are others    who far more qualified on the Oric music scene, such as Jon Bristow.            However, if you have managed to get the hang of the above mentioned demo, it    is not hard to see how the Oric can be made to play music in the background     at the same time as it is being used for something else.                                                                                                        If you scrubbed the demo routine from the software noted above and replace      it with a call to the "PING" operation (JSR#FA9F or FA85 for Oric-1), the       Oric would go "Ping !" every time the Interrupt system was activated. In        fact, what you would get is a loud whine because the "Pings" would be so        frequent and close together, that you wouldn't be able to separate them. You    would really need some form of counter in order to arrange it so that the       "PING" call was only made once every say 100 Interrupt calls. In fact if you    tacked the "PING" call onto the end of our original demo, you would achieve     that, because the demo routine was a counter of sorts. Of course, an Oric       doing alarm clock imitations, would not make you any friends and so you         would need more software to pick out a sequence of notes, instead of just       "PING", in order to make it sound a little bit more like real music.                                                                                            A similar set up might be used to send text characters to the printer, so       that it would print in the background, instead of completely tying up the       computer. Has any Oric fan had a go at producing software of this sort, or      better still, a printer buffer ? One of these days, I might get the time to     have a shot at it. Hope springs eternal !................See you next time.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Machine Code for the Oric Atmos (Part 65)   Peter N. Bragg                      -------------------------------                                           

The Story so far                                                                ---------------- We have been looking at Interrupts in recent articles and      eventually finished up with a set of routines that could be used to extend      Oric's Interrupt System to include some of our own software. It was rather a    long explanation, but a series on machine code, would be incomplete if it       didn't include some details about the Interrupt system.
                                                                                                         Take a Break                                                                    ------------ Now lets look at an instruction that has not been covered so       far, that is the "BREAK" instruction. It is a good time to look at it,          because it has things in common with the Interrupt system which has just        been covered. It is a single byte instruction (hex code 00) and it's full       name is "Force Break (Trap or Software Interrupt)". That name is usually        abbreviated to the label "BRK", which is short for "BReaK".                                                                                                     Essentially, it is a software version of the Interrupt. The first thing it      does is to set the "Break Status Flag Bit" to "1" in the Status Register.                                                                                       It adds 02 to the Program Counter, which it then preserves on the Stack.        The Program Counter holds the address of the current instruction being          executed, so this action puts a "return address" onto the Stack.                                                                                                Having done that, it then preserves the Status Register on the Stack.                                                                                           Next, it sets the Interrupt Mask Bit in the Status Register to "1", which       disables the Interrupt Request ("IRQ") line, so that any Interrupt Request      is ignored, for as long as that remains set to "1".                                                                                                             Finally, it resets the Program Counter to vector through the address in         locations #FFFE and #FFFF. That causes the program to jump via that vector,     to the Interrupt vector at #0244 (labelled "INTFS"), which takes it on to       the Interrupt handling routines in the Oric's operating system ROM at #EE22.                                                                                    If you followed the recent articles on the Interrupt system, you may find       that much of this is familiar and indeed, it is a similar operation to that     which occurred when the "IRQ" hardware line goes active, as noted recently,     in Part 57 of the series. The main difference is that this is a software        operation that is initiated by the "Break" instruction. It doesn't need an      electrical signal down a wire into the microprocessor, as in the case of the    Interrupts that we have dealt with in the past. Now we have an instruction      which will give us a software interrupt, in addition to the hardware version    that we have covered in the last few issues.                                                                                                                    At this stage, I should say that I have never found the need to use this        particular instruction, although others have used it for such things as         setting "breakpoints" which are useful for debugging etc and it can also be     useful for important software such as disk operating systems.                                                                                                   If you do want to make use of the "Break" instruction for a software            interrupt, you will find that, what was said about the vectors and adding       extensions to the Interrupt routines, in the recent articles, also applies      to the Interrupt routines accessed by the "Break" instruction.                                                                                                  Once again, you can add your own extension routine, but you will need to        start with a short routine to sort out the software "Break" operation from      the hardware "IRQ" interrupts, which use the same vectors.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Is it really a "Break" ?                                                        ------------------------ Let's look at how to go about separating software      "Break" interrupts from the hardware ("IRQ") interrupts. The "Break"            instruction sets the "Break Status Flag Bit" to "1" in the Status Register.     That is Bit 4 in the Status Register byte. Essentially it boils down to         getting a copy of the Status Register contents and testing them to see if       Bit 4 has been set to "1". If it has been set to "1", the interrupt must        have been caused by a software "Break", not the "IRQ" line.                                                                                                     As mentioned above, the Status Register is the last item saved on to the        Stack, by the "Break" instruction, so we could retrieve a copy of the Status    Register from the Stack into the Accumulator for our test. However, we must     not forget to restore the Stack to it's original state.                                                                                                         All we need is just two instructions, "PLA" (code 68) followed by "PHA"         (code 48). These will pull the most recent item put on the Stack, off into      the Accumulator and then push it back onto the Stack. This leaves a copy of     the Status byte in the Accumulator, without changing the Stack contents.                                                                                        Providing the Stack has not been changed, since the "Break" instruction, the    item in the Accumulator will be a copy of the Status Register contents put      on the Stack by that "Break" instruction. We can now test the byte in the       Accumulator to see if the "Break Status Flag" (Bit 4) has been set to "1".                                                                                      If it is "1", it will show that the interrupt was the result of a software      "Break". The testing can be done using the instruction "AND #10", followed      by a "BNE" branch instruction. The Branch instruction could be set so that      if Status Bit 4 is set to "1", it would branch off to a specific routine to     deal with the "Break". It would follow that if Bit 4 was clear at "0" the       Branch would be disabled and the specific "Break" routine would not be used.                                                                                    There is no doubt the above operation would work, although I have to confess    that I have never used it. If and when I ever need to use a software            interrupt I would certainly concentrate more on making the operation            "transparent" as illustrated in the previous articles on interrupts. That       would make it slightly more complicated, which is why I haven't bothered to     do so here. At least the above description gives some idea of what is           involved, when making use of the software interrupt, provided by the "Break"    instruction. 
                                                                                                                                                   Drawing a Blank                                                                 --------------- It should be mentioned at this stage, that unlike other         instruction codes, the code 00 hex used for the "Break" instruction, is also    often used for other purposes. For example, many programmers use it to          terminate strings of characters or display codes. Strictly speaking, this is    using hex code 00 as data, but it is still useful at that.                                                                                                      Many have owned or used the BBC Microcomputer. The programmers for the          BBC Micro thought it a good idea to blank the entire useable memory (not a      lot of that in the old BBC Micro !). An untidy user memory cluttered up with    random patches of garbage, was not posh enough for BBC micro users !                                                                                            The BBC Micro's operating system blanks the entire memory with code 00 and      then puts code FF in the first location of each and every block of one          hundred bytes. Very tidy ! but also very useful. I wasted no time in doing      the same for the Oric Atmos. Programming and debugging are a lot easier if      you know precisely what is in every location in the user memory. Providing      you don't pirate it, a good idea is worth copying.........See you next time.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Machine Code for the Oric Atmos (Part 66)   Peter N. Bragg                      -------------------------------                                           

The Story so far                                                                ---------------- We have been looking at Interrupts in recent articles,         which included short listings of routines, that could be used to extend         Oric's Interrupt System for our own purposes. Having looked at hardware         interrupts, we finished up in the last article, by looking at the "Break"       instruction, which can be used to produce a software "interrupt".
                                                                                               Mice on the Oric !                                                              ------------------ Well, you shouldn't leave your cheese sandwiches on it !     Seriously, the subject of mouse drivers and software was raised some time       ago in the CEO Mag by Norma Wrangham and has cropped up again, recently         in the OUM. Dave Dick mentioned in his comment, that he thought that I had      been working on a mouse driver for the Oric. That is so. I built an             interface and then wrote a mouse driver for the Atmos. It works very well       and it was fairly easy to construct the interface and write the software.                                                                                       One Oric machine that can also be fitted with a mouse, is the Telestrat.        However, I don't know what software was produced for the Telestrat mouse.       I have the impression that there wasn't much. What I saw of the Telestrat       mouse itself, appeared to be very similar to the mouse provided by AMS for      their "AMX Art" package, which ran on the original BBC Micro. Later on AMS      also produced a version of the same package for Amstrad computers.                                                                                              The "AMX Art" package for the BBC Micro, was originally produced in 1984 and    included a three button mouse and a drawing package which operated in a         rudimentry "window" environment. It was a brilliant package for it's time       and we certainly enjoyed using ours. That original BBC Micro package            provides a good illustration of what could be achieved on the Oric, if we       are prepared to make use of it.                                                                                                                                 Of course things have moved on in computer hardware and software scene since    then, but at least the basic mouse system in use today, does not appear to      have changed that much over the years. What has changed, are the computer       displays and the software that makes use of that basic mouse system.
                                                                                            A Mouse Driver for the Oric Atmos                                               --------------------------------- My own mouse driver was produced for the      Oric Atmos, but I cannot see any reason why it shouldn't work on the Oric-1     as well although as I don't possess an Oric-1, I am not able to check that.     It might be necessary to change a couple of operating system addresses in       the software.                                                                                                                                                   The interface consists of five components, two of which are integrated          circuit (IC) chips, plus any sockets and plugs required to fit computer and     mouse. Anyone capable of soldering a component to one of those simple           circuit boards, available from Tandy, would have no problems making it.                                                                                         Likewise, if you have got a grip on the most recent of this series of           articles, covering the Interrupt system, you should not have much trouble       with the mouse driver software. Mouse driver software uses the interrupt        system to keep the mouse position and operation updated on the Oric's screen    display. The essential software to read the mouse only is about 1K bytes        long, but bear in mind that this just reads the mouse and uses that data        obtained to move the text screen cursor. It also reads the three mouse          buttons to give a choice of three inputs, currently set at <RETURN>,            <DELETE> and <CTRL 'A'>. All very basic, but it does work.
                                                                                                      ..........................................................................         Print picture of Oric mouse below        ..........................................................................
                                                                                                                                                                      An Oric Mouse set up                                                            --------------------                                                            Picture shows the BBC/AMX                                                       mouse plugged into the                                                          interface, which can be                                                         seen just under the top                                                         left corner of the Atmos.                                                       The ribbon connector from                                                       the Atmos expansion port,                                                       goes to the disk                                                                interface and then on                                                           to the mouse interface.                                                                                                                                                                                                                         Of course, I am quite happy to publish the necessary information to enable      other Oric users to duplicate the above mouse driver. The question now is,      where do we go from there. Obviously we need some software specifically for     an Oric mouse. If there is any available for the Telestrat mouse, that might    be a good starting point. Probably the easiest software to adapt, is games      software. A three button mouse provides control for up, down, left, right       and fire and you still have two buttons going spare. This might interest the    Oric games enthusiasts and can't be that difficult to achieve. That's a         start anyway. Next question is what kind of mouse is best ?
                                                                                                     Using a Mouse                                                                   ------------- Nearly ten years experience of "Windows" software, mostly on      the Archimedes, have inclined me to favour the three button mouse. The          mice I use came with the BBC Micro and Archimedes computers and they all        have three buttons. It is very handy to have "reverse action" and               "menu/info" buttons in addition to the usual "execute" button, in fact it is    a bit of a fiddle without them. Unfortunately, the third button hasn't been     "invented" for "PC" users yet, but I am sure that Microsoft will get it         sorted out eventually.                                                                                                                                          Strictly speaking, a Marconi Trackerball is the "mouse" I use most of the       time. It is really exactly the same thing as far as the interface and mouse     driver software is concerned and can be plugged into the same socket as the     mouse. Its advantages are that it needs less desk space and is easier to use    on graphics and games software. The disadvantages are that it is larger and     heavier and slightly less convenient for filing operations, than the genuine    mouse. However, it is easy to unplug and swap them over if needed. All this     is based on personal experience, others may feel differently. It all depends    on how you intend to use your own computer.
                                                                                                                     Mouse software for the Oric                                                     --------------------------- Obviously this depends on how much software can     be found or adapted for an Oric mouse system. A lot also depends on how much    Oric users are prepared to contribute in the way of software. As mentioned      above, one way to start, would be to adapt some of the games software for       use with a mouse. Adaptations of existing software, would be the fastest        way to build up a library of mouse oriented software. Other possibilities       include music software or filing operations. In time, some kind of drawing      or art software could be written for the Hires display. At least I can set      the ball rolling, by publishing the details of the interface and mouse          driver. Finally, it's worth mentioning that the interface itself is quite       useful, for other things apart from the mouse driver......See you next month.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Machine Code for the Oric Atmos (Part 67)   Peter N. Bragg                      -------------------------------                                           

The Story so far                                                                ---------------- Having come to the end of quite a long series of articles      on the subject of interrupts, the last article went on to something a little    bit different, the subject of using a mouse on the Oric. The Telestrat could    be fitted with a mouse, but apart from that there has only been the odd         experimental system such as that fitted to my Atmos.                                                                                                            There are two obstacles to using a mouse on the Oric computer. The first, in    respect to the Atmos and Oric-1, is the lack of a suitable interface. The       second, is the lack of software for it. If an interface became available I      cannot the see lack of software as a serious problem for long, providing, of    course that the interest is there. At least I can start the ball rolling by     providing details of my own interface, so let's have a look at that. 
                                                                                           Mouse Interface - Overview                                                      -------------------------- First of all let's look at the mouse itself.         I use the Acorn Archimedes three button type. A second hand mouse from the      old BBC Micro as shown last month, would be ideal, but as I understand it,      most computer mice work on similar principles, so obtaining a mouse for the     Oric shouldn't be a problem. As for                                             the buttons, a three button mouse                                               should be able to emulate a single,                                             or two button mouse, but the number of                                          buttons on the mouse probably doesn't                                           matter at this stage in development.                                                                                                                            The interface itself consists of                                                hardware and software. For the                                                  hardware side, there is not much hope                                           of a manafactured interface being                                               offered, so it comes down to D.I.Y. as                                          the only solution for most of us.                                               Fortunately, if you can use a small                                             soldering iron, the hardware is simple                                          to make. It also has a very low                                                 component count, so it doesn't cost                                             much, to make up.                                                                                                                                               Finally there is the software that reads the mouse data from the interface      and uses it to update the mouse position on the display screen. My own          software does that using the Text display and it also reads the buttons.        That's as far as it goes at this point in time, but at least it's a start !
                                                                                     Mouse Operation                                                                 --------------- This is the first consideration, as it is useful to have        rough idea of how a computer mouse works, in order to understand the            requirements for the hardware and software.                                                                                                                     The mouse is centred around a ball, held in a cage in contact with a couple     of rollers. One roller monitors the horizontal ("X") movement and the other     roller monitors the vertical ("Y") movement of the mouse ball, as the mouse     is moved around the mat. These rollers are set at right angles to each other    and each drive a small disk. The disks act as movement detectors. The           slightest movement of the mouse will cause the mouse ball to rotate one or      both of the small disks, depending on which direction and how far you move      the mouse. 
                                                                     
One of the roller driven disks detects left and right ("X") movement of the     mouse, the other disk detects forward and back ("Y") movement.                                                                                                  That is the mechanical side of the mouse operation. The two disks accurately    monitor mouse movement in the horizontal and vertical planes on the mouse       mat. The next thing is to convert those disk rotations into data for the        computer. That could be done electrically, using a wiper and a set of           contacts on the disk, but that system is subject to mechanical wear and tear.   A better way is to use light and a light sensor to read the disks rotation.                                                                                     Each of the two disks is slotted and is read by shining a light (usually        infra-red) through an evenly spaced set of slots that go completely around      the edge of both disks. So when the mouse is moved, one or both disks will      spin and chop their respective light beams, which are then each read by a       light sensor on the other side of the disk. Each sensor converts the light      seen through the slots into a chopped (or pulsed) electrical signal.                                                                                            Pic 1 shows the general layout, with                                            the mouse ball in it's enclosure and                                            the two roller driven disks set at                                              right angles to each other.                                                                                                                                     Both pictures show the internal parts                                           of the Acorn Archimedes mouse. Most                                             computer mice are very similar in                                               operation and construction to this.                                             Hopefully, the pictures are clear                                               enough to give an idea of how it all                                            works.                                                                                                                                                          Pic 2 is a closer view, which shows                                             the slots in one of the disks. The                                              roller is in contact with the mouse                                             ball and spins the disk when the mouse                                          moves. The light emitter LQ2 on the                                             left of the disk, is mounted so that                                            it's light shines through the slots in                                          the disk. The disk movement detector,                                           which reads the light coming through                                            the slots can be seen just behind the                                           disk. That movement detector actually                                           has two light sensors in it and so                                              does it's counterpart, which is used                                            to read other disk, for reason which                                            we will see shortly. For the moment,                                            however we will deal with only one of                                           those light sensors for each slotted                                            disk.                                                                                                                                                           The resulting two sets of electrical                                            pulses, one produced from each of the                                           two roller driven slotted disks are fed from the light sensors via the          interface, into the computer. The computer accepts those pulses as data         input and uses them to calculate exactly how far the mouse has been moved on    the mat in both the horizontal ("X") and vertical ("Y") directions.                                                                                             OK, so now we can use the movement detectors to produce a set of electrical     pulses, which monitor every movement, whenever the mouse is moved.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              This gives us an accurate measurement of mouse movement on the mouse mat,       but it still leaves us short of some vital information. The computer can now    tell precisely how far the mouse moved horizontally ("X"), but it still         cannot tell whether the mouse moved left or right ? Likewise for the            vertical ("Y") direction, it cannot tell whether the mouse was moved towards    or away from the computer user ?                                                                                                                                The answer to that problem is quite easy. Instead of one sensor on each of      the two slotted disks, the mouse now uses two sensors on each of the slotted    disks. That is two light sensors for the "X" movement disk and two for the      "Y" movement disk.                                                                                                                                              The trick is to position the two light sensors on each disk so that one         reads a slot open while the other sensor is still partially blocked off from    the slot it is reading. The result is that whenever the slotted movement        detector disk rotates it sends two sets of identical electrical pulses that     are slightly out of phase, through the interface, to the computer.                                                                                              The computer can read the two sets of pulses from the disk and can use the      slight time lag between each set of pulses, to work out which way the disk      is rotating. The same applies to the two sets of pulses produced by the         other slotted movement detector disk.                                                                                                                           The two sensors on each disk, can be set quite close to each other, they can    even read the same slot, providing they produce the required time lag that      identifies the direction of disk rotation. As a result, it isn't surprising     to see both of the sensors for one disk in a single chip, as shown above.                                                                                       Now the computer can work out which way each of the two movement detector       disks are rotating and as a result, which direction the mouse travelled and     in addition, it can calculate from the number of pulses read from each disk,    precisely how far the mouse was moved. Using that information, it can now       duplicate that mouse movement on the display screen, using the cursor or a      pointer.                                                                                                                                                        As for the buttons, they are easy. The mouse interface has a set of data        input lines. Each button is connected to it's own data input line. The state    of each line can be read from a specific location in the computer's data        memory. Push any button and it will instantly change the contents of that       memory location to indicate which button was pressed.                                                                                                           That more or less covers the mouse operation. If you are looking for a mouse    for the Oric, I would be inclined to go for a very basic simple type, such      as those used on the early machines like the BBC Microcomputer.                                                                                                 I have found that the Acorn computer mice and my Marconi "MEDL" Trackerball     all seem to operate perfectly well with all of the BBC Micro, Oric Atmos and    Acorn Archimedes 310 and A5000, so it follows that the computer mice for        Acorn machines are probably all suitable for operation with the Oric.           It is also quite likely that many of the other computer manafacturers equip     their machines with mice that would also be suitable for the Oric. The only     problem would appear to be the plugs. The BBC Micro uses a 20 pin IDC type      and the Archimedes uses the more common small 9 pin Din type. If you are        going to build an interface, you can simply clip the plug off the mouse lead    and use plugs and sockets of your own choice. As for where to obtain a mouse,   it might be best to look in second hand sales, computer fairs and boot sales,   at first. However, before you do any of that, you will need an interface and    that's what we will have a look at next time.................................
 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Machine Code for the Oric Atmos (Part 68)   Peter N. Bragg                      -------------------------------                                           

The Story so far                                                                ---------------- Having looked at the subject of interrupts, the last couple    of articles have gone on to the subject of using a mouse on the Oric. A lack    of manafactured equipment, means a DIY project is currently the only option     for most Oric users who wish to make use of a mouse. However, this has it's     good points. The interface alone is worth looking at. As a general purpose      device, it offers many other possibilities in addition to mouse operation.                                                                                      In the last article we had a closer look at the operation of a typical          computer mouse. We discovered that it's movement is monitored by two            movement detectors, which send electrical pulses to the computer, whenever      the mouse is moved. Each movement detector generates two sets of pulses,        identical except for the fact that they are slightly out of phase. In other     words, they are slightly out of step. One set of "movement" pulses arrive at    the interface slightly ahead of the other set from the same detector.                                                                                           The effect of the two sets of pulses being "out of phase", can be used by       the interface/software to indicate which direction the mouse moved. The         number of pulses generated, tell the computer how far it went in that           direction. By the way, those disks in the movement detectors, should have       been discs. Disk with a "k" tends to be automatic when I am wearing my          computer hat ! Apologies to Frank Bolton and his many fans.
                                                                                                     Where do we plug the mouse in ?                                                 ------------------------------- The reason for looking at mouse operation,      was to see what we need in order to link up a computer mouse to the Oric.                                                                                       Hopefully you now can see any interface must be able to read the pulses         generated by moving the mouse and convert them into data for use in the         computer software. Bear in mind that the mouse is likely to produce two sets,   or in other words, four such streams of electrical pulses at any time, all      of which must be read and dealt with immediately, in order to keep the mouse    pointer (or cursor) position correctly updated on the display. That means       that the interface must be able to "latch" or hold data, while it is being      dealt with and it also needs to provide access to the Interrupt system.         These facilities can be provided by the VIA 6522 interface chip.                                                                                                The Oric has a VIA 6522 chip and like other machines such as the BBC Micro,     it uses that to provide a "User Port", which is intended to allow the           computer user to link up hardware such as printers, joysticks etc and indeed    the mouse for the BBC Micro, does plug into the "User Port" on that machine.                                                                                    However, despite the fact that the Oric uses the same VIA 6522, for its         "User Port", it is a bit more limited, than those provided on other machines.                                                                                   The reason for this is that the Oric is rather a clever combination of          software and hardware, that makes a lot more use of it's internal hardware      than many other machines. For example, by combining the talents of the sound    chip GI 8912 and the VIA 6522 interface chip to handle complex operations,      it was possible to make the Oric hardware smaller, simpler and cheaper than     rival machines.                                                                                                                                                 The down side of this, is that some of the useful functions provided by the     VIA 6522 chip that would normally be available on the "User Port" for the       computer mouse operation, are now tied up in essential Oric hardware            operation and therefore, are not available to the Oric user.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    I originally bought the Oric Atmos with the intention of using it together      with Acorn's BBC Micro as a single computer system, with the Atmos providing    portability and simplicity of operation. It was certainly much better, than     the machine originally designed for that job, Acorn's own Electron computer.    The Electron's main failing, was that it couldn't emulate the BBC Micro's       popular Teletext (Mode 7) display, whereas the Atmos produced a very good       emulation of that BBC Micro display mode. The Atmos display even made the       Acorn Archimedes Mode 7 display look "weedy" by comparison.                                                                                                     The only drawback to the Atmos for me was the restricted "User Port"            facilities. The BBC Micro uses a second VIA 6522, half of which provides the    "printer port" and the other half is a fully equipped "User Port", that runs    a lot of things, including the mouse. At the recent Oric Meet, Jon Haworth      confirmed that the Telestrat also uses a second VIA 6522 to provide the         extra facilities such as computer mouse operation, so that definitely           appears to be the way to go.                                                                                                                                    There may well be a way to read and operate a computer mouse system through     the Oric's own "User Port". However, the arrival in 1984 of L. Whewell's        "Oric Advanced User Guide" provided a much easier solution in the form of       full details of how to construct a simple "expansion board".                                                                                                    This in effect, adds the second VIA 6522 interface chip to the Oric.            In fact it is a much better option, because it gives full access to all of      the VIA 6522 chip's facilities, which includes no less than two fully           operational "user ports", plus quite a lot of other very useful functions.      That is much more than many other machines such as the BBC Micro can provide.
                                                                                   The Oric Expansion Board                                                        ------------------------ I constructed the 6522 Expansion Board Project,        which is shown in detail in the "Oric Advanced User Guide", written by          Leycester Whewell, Pages 83 to 91. This provides all the necessary hardware     to run the AMX 3 Button Computer Mouse (and other projects !).                                                                                                  It is quite easy to make, providing that you are reasonably competent with a    soldering iron. The "Advanced Guide" is not easy to get hold of, but is well    worth having. Dave Dick of OUM, may know where to get a copy. If it comes to    the worst and someone wants to build the Expansion Board and can't get hold     of the book, it should be possible to photostat those pages for them.                                                                                           I use the Expansion Board with an Atmos. I do not have an Oric-1, but while     it has a different keyboard and Operating System ROM, I understand that the     Oric-1 circuit board is the same as the Atmos and so there is no reason why     the Expansion Board shouldn't work just as well with the Oric-1.                                                                                                I built two of the "Expansion Boards", both worked first time. They are         fairly cheap to produce. The VIA 6522 chip is the most expensive electronic     component at 4-59 (from Maplins). The other chip 74LS138, costs 59 pence.      The only other electronic components required, are a 100 nF ceramic             capacitor and a 2.2K ohm resistor (0.25 Watt).                                                                                                                  The project in the "Advanced Guide" suggests using "Veroboard", but I found     it easier to use one of those pre-drilled circuit boards, available from the    local electronic components store, such as Tandy. They have the same grid       pattern of pin holes to fit the components, but each hole has its own           isolated copper pad, which makes fitting and soldering the components dead      easy. The boards appear to be coated with a flux based varnish, to make         soldering easier and cost about 1-80, depending on type and board size.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Of course, you could etch your own "printed circuit" instead of using a         commercial project board, but it's hardly worth the bother.                                                                                                     It is very advisable to use sockets for the VIA 6522 chip and the 74LS138       decoder chip. The two chips could be soldered directly onto the board, but      it is a heck of a lot easier to just plug them into sockets after the           construction and even better still, you can replace them, if something goes     wrong at a later date.                                                                                                                                          Once the components have been soldered into place on the board, they can be     linked up with thin insulated wire to complete the circuit. The wire I used     for that, was solid cored and had coloured sleeving. I used different           colours for different parts of the circuit, for example, red and blue for       power links, white for the interface sockets and a couple more colours for      other parts of the circuit.                                                                                                                                     That covers the electronic components for the interface. Now we come to the     the more mundane items such as plugs, sockets and cables. These can often be    a bit expensive depending on what you decide to use.                                                                                                            You will need 12 inches of 34 way ribbon cable (as used on disk drives),        plus the plug for same, which goes into the Oric's expansion socket. Don't      make the cable much longer than that, or you may get data corruption            problems. The "Advanced Guide" suggests that the other end of the ribbon        cable should be plugged into the "Expansion Board" using another pair of the    same plug and sockets.                                                                                                                                          I did it differently and soldered that end of the ribbon cable straight into    the Expansion Board. This was done by taking the end of the ribbon cable        and splitting the last inch of it into 34 separate single leads. They were      then soldered into the board in two rows of 17 leads. One row had odd number    leads (1 to 33) and the other, even number leads (2 to 34). Eliminating that    plug and socket saved a lot of space and made it much easier to fit the         whole unit into the tiny project box, as illustrated in article 66 of this      series. It was easy to do and saved the cost of plug and socket as well !!                                                                                      The only other plugs and sockets required now are for the "input/output"        side of the Expansion Board. If you are simply using it as a computer mouse     interface, you will only need a nine pin plug and socket to link up with the    mouse and that of course will depend on what plug you have on your mouse.                                                                                       I wired mine up to two 20 pin IDC sockets in exactly the same layout as used    on the BBC Micro's "User Port". This means that anything that can be plugged    into the BBC Micro "User Port" and there is quite a lot, can also be plugged    straight into the Oric's Expansion Board Port B socket. Very useful !                                                                                           Should you get hold of the "Oric Advanced Guide" and decide to have a go at     the Expansion Board, there are a couple of points that you should be aware      of. First of all there is a small misprint in the book, page 83. Start at       pin 30 in the 6522 box, it should read downwards as, 30, 29, 28, 27, 26, 38,    37, 36, etc. The third, fourth and fifth numbers in that sequence are wrong     in the book ilustration.                                                                                                                                        Secondly, I would be inclined not to bother with the link between PB7 and       CB1, unless you want to make use of the real time clock and even then I         would check that the Expansion Board is working correctly before using the      clock. If you have the "Advanced Guide", the above notes may be useful.         More on the interface next time. In the meantime, something different !
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         A Brief Pling !                                                                 --------------- With regards to Paul Hill's query. The "!" (Pling) command      system is outlined in the Oric Manual (Page 220 "Shriek !") and apparently      allows the user to add new Basic commands. I rarely use Basic, so you won't     be surprised to learn that I have never used the "!" command system.                                                                                            By the way, note that word "command", it does not mean instruction, so you      can't use the "!" system to provide Basic program instructions, because the     "!" system as outlined in the Manual, makes use of the Oric's Input Buffer      for the parameters. A program is interpreted and therefore the only thing       that goes into the Input Buffer is the command "RUN".                                                                                                           In spite of that, I decided to have a quick look to see how it works. The       Oric Manual suggests several ways to do this, but they all boil down to the     same thing. First write the machine code to read the Input Buffer parameters    for your command and then put it's start address into locations #02F5/F6.                                                                                       Therein lies a problem. What about the address that's already in there ?        Change it and the chances are something will go "pear shaped", such as the      disk system, for example. The Cumana disk system uses the "!" for disk          commands. Even Sedoric makes some use of "!". The fact that the disk system     uses "!" commands, could cause problems. Even if you don't have a disk          system, you may want install one at a later date, so bear this in mind.                                                                                         As a result, I didn't use the suggested "DOKE" instruction for each command.    What I did instead was to swap the address in #02F5/F6 for one pointing to      my own routines and then tacked an instruction for the original address from    #02F5/F6 on to the end of my own routines to make them, in effect an            extension of the Oric's "!" system.                                                                                                                             This is a similar operation to that used in Part 63 of the series to extend     the Interrupt vector. The routines are slightly shorter, because "!" Vector     at #02F5/F6 is the address of an Indirect Jump and therefore only two bytes.    The routines provide for the installation of multiple "!" commands, without     the need to precede each one with it's own "DOKE" instruction.                                                                                                  To save having to write sprite routines, I used the two calls to the sound      effects SHOOT (JSR FAB5) and EXPLODE (JSR FACB), to check out two new Basic     commands, which were called !NORTH and !SOUTH. To keep it simple, the           routines only checked the first parameter, which appears in #0036 (in Oric's    Input Buffer) so !N or !S worked just as well as the full command. The          routines tested for the two parameters using the CMP and BNE instruction        combination, that has been used before, to test keyboard input.                                                                                                 The "!" command system certainly works, but I didn't quite finish, having       run out of time. It appears to be necessary to erase the Input Buffer           contents during the operation and then reinstate them, before returning to      Oric's operating system in order to avoid spurious error reports.                                                                                               More on this, when I have sorted out the listing. In the meantime, thanks to    Paul for his comments. I am definitely no expert on machine code. I can well    remember how hard it was to start. Some instruction manuals are good, but       many are simply large volumes, with little to offer. I hoped to make it         easier to gain knowledge on the subject and to give an insight which can be     applied to other computers. The same principles apply to 32 bit machines and    will probably apply when we get to 128 bits ! Of course, the gremlins have      occasionally put the boot in, for example, by printing out pound instead of     hash signs. All part of life's rich pattern ! ...........See you next month.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   