Machine Code for the Oric Atmos (Part 42)   Peter N. Bragg
-------------------------------                                           

The Story so far                                                                ---------------- We have been looking at machine code/assembler programming     technique and the last two issues have concentrated on producing a short and    simple utility routine that can swap the contents of two areas of memory.                                                                                       The first example produced in Part 40 of the series was aimed at providing     
 the means to preserve the entire contents of Zero Page (0000 - 00FF area).      This worked by swapping it's contents with those of another area of memory,     
so that the Zero Page facilities would be available for our own software.       Afterwards, the same swap routine could be called again, to restore the         original Zero Page contents, ready for return to Basic. The routine shown,      
was simple, but somewhat limited, in that it could only handle a maximum of     
100 bytes. OK for Zero Page, but no good, for anything larger. The main         thing at that stage was that it worked and did what it was supposed to do.                                                                                      Always concentrate on getting your software working first. Fine tuning,         improvements and efficency can come later. They are easier to achieve when      
you have the essential elements of your software working correctly. If you      
try to make your software super-efficent from the start, it will take you       
ten times as long to write and you will be fed up, long before you finish.                                                                                      However, once software is working correctly and has been put to use, it is      time to look with a critical eye and see if it is possible to make a            significant improvement. Even if it is satisfactory for the current project,    
it may be possible to extend it for other software projects.                                                                                                    

Try again, for something better ?                                               --------------------------------- This brings us to the second version of       
the "swap operation" in Part 41 of the series. This is intended to be an        improvement on the first version. It is a bit larger and now consists of two    routines. However, it is more useful, because it is no longer restricted to    
 a maximum "swap" area of 100 bytes.                                                                                                                             If speed had been a consideration, I would have dealt with the operation in     
a different way. Speed only becomes important where an operation needs to be    called many times in a brief period of time. It has a lower priority in an      operation that has longer periods of time, between each call as in this case.                                                                                   Now let's have another look at those routines (see the listing in Part 41).     Hopefully, the description in the listing is sufficent to show how the          "swap" operation works. However, there are one or two points about the          actual technique used to write them, that are worth looking at.                                                                                                 Bear in mind that we all have different ways of working and I can only          really speak for my own. Note that all the variable items are located, as       usual in a Parameter Block at the beginning of Page10. I always try to          locate these Parameter Blocks at the beginning of a Page, because it makes      
the variable items easier to find, if I need them at a later date. It does      
not make a lot of difference in a small operation like this, but in a large     piece of software containing hundreds of different operations, reserving the    same area on each Page for these items, is a valuable time saver.                                                                                               The routine, "Fetch 2 Bytes and Swap them over" (JSR 1010) is very short.       More than half of it consists of variable addresses anyway, so it is not        that much out of place, if it is considered as being located in the             Parameter Block. There is a reason for this which we will come to shortly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Now let's have a look at the other routine, "Swap Contents of Two RAM Areas"    (CALL#1020). The first part of the routine (instructions 1020 to 1041)          ensure that the operation always uses the addresses in the Parameter Block.                                                                                     The rest of the routine is a loop which goes through the two memory areas,      swapping bytes over, one pair at a time, until the end address is reached.                                                                                      Instructions 1044 to 1052, just test to see if the "swap" end address has       been reached. As this is a "built in" operation and not one requiring input     from the keyboard, a straight test for a single address is all that is          needed. When that address is reached, the "swap" operation ends.                                                                                                Instruction 1054 does the actual "swap" using JSR 1010. This only swaps a       single pair of bytes over from the two addresses as set in the four LDA/STA     instructions in the JSR 1010 subroutine. The four instruction addresses must    
be updated after each "swap" by incrementing (adding 01) to each address.       Updating is done by instructions 1057 - 1068 and instructions 106B - 107C.      
The two updating operations are basically the same, so let's look at one.                                                                                       Oric addresses are two bytes long and the value 01 is added to the low byte     first and any carry over from that result is then added to the address high     byte. The instruction "Add with Carry" (ADC) is used for the operation. The     first instruction is "CLC", to ensure that the Carry flag is clear, before      using the "ADC" instruction, because the Carry flag is included in the          addition. If it happened to be "set", it would add another "1" to the result.                                                                                   The Carry flag is also affected by the result of the "ADC" instruction. If      
the result is 00 to FF, the Carry flag will be cleared to "0". If the result    
is higher than that (ie. FF+01=100), the lowest two digits are put into the     result byte and the extra digit "1" is put into the Carry flag for use in       
the next part of the addition operation. This is how addition is handled for    large values, starting with the lowest byte and working up to the highest.                                                                                      So in theory, to update the four addresses we should add 01 to the low byte     
of each address and then add the Carry to each high byte. That's one way.       However there is a better way, that is shorter and probably quicker.                                                                                            The operation in 1057 - 1068 updates two indentical addresses. Instruction      1058 fetches the low byte from the first address and instruction 105B adds      
01 to it. That action also affects the Carry flag, so the next instruction      which is "Branch if Carry Clear" ("BCC") can be used to control what happens    
to the two address high bytes. If there is a carry from the addition, the       Carry flag will be set to "1", the Branch will be disabled and the two          address high bytes will be incremented (+01 in each) by instructions 105F       
and 1062. However, if there is no carry from the addition, the Carry flag       will be cleared to "0" and the Branch will operate so that the two increment    instructions are skipped. Finally, the two instructions 1065 and 1068 copy      
the result of the addition back into the two address low bytes. The             operation in 106B - 107C works in the same way, on the other two addresses.                                                                                     Finally, we come to the "instruction" at 107F/80, which provides the loop,      back to "test address" at 1044 again. This could have been done with an         ordinary JMP 1044 instruction. However, if you look at the routine, you will    
see that it is completely relocatable, providing that you use the artificial    jump produced by the CLC/BCC Branch combination. The Parameter Block is the     only fixed item. The main routine can be relocated and called from anywhere     
you wish, because all the "absolute" addresses used by the routine, are         located outside it. Happy New Year to all Oric Users..........See you then.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           


		Machine Code for the Oric Atmos (Part 43)   Peter N.Bragg
-------------------------------                                           

It's only money                                                                 --------------- Editor Dave's recent excursions on behalf of OUM, into the      logic of large numbers, reminds me of a time, when a friend was doing the       rounds at work, trying to flog tickets for the Directors Ball. It was hard      going, until he mentioned that they were raffle tickets, not dance tickets !!                                                                                   I am not a gambler, having never filled in a pools coupon or been in a          betting shop. However, like most people, I usually join in sweepstakes          
and club raffles. All good clean fun. However, the "Lottery" is a whole new     ball game. There is the chance of winning millions and my feelings are that     
if you are going to have fun gambling, it is best to go for the "big one".      Greedy, thats me !! My only reservation on the subject is, never ever gamble    anything you are not prepared to lose.                                                                                                                          I have not yet bought a ticket for the "Lottery", but have read all the info.   
It inspires the thought. Could one write a computer program to predict the      winning line ? We have a very easy to use computer. Would it be possible to     
use the Oric to predict a set of Lottery numbers for us ?                                                                                                       True, that is not a particularly original thought. There have been software     packages to predict racing form and football pools. How successful are they ?   Well, if they were really that successful, the writers wouldn't need to         sell their software, they would be raking far more money, by using the          software themselves !                                                                                                                                           

Flights of Fantasy                                                              ------------------ However, providing you don't take it too seriously, there    could be quite a lot of fun to had, trying to write a program to predict the    weekly lottery result. Sorry to say, that I haven't done anything myself in     this particular field, as yet, having been a little bit too busy to do much     computing in the last few months. So I haven't got a neat little machine        code routine to make us all multi-millionaires, but we can dream, can't we ?                                                                                    The question arises, surely there are programmers out there who are better      than us and machines (perish the thought !) that are faster and better          equipped than the Oric ? Surely they have a much better chance of success,      predicting Lottery numbers ?                                                                                                                                    That doesn't necessarily follow. Expert programmers are probably too busy       writing safe and saleable software packages to earn their daily crust and       
few of them would really want to spare the time for a "fun" project.            Secondly, what the Oric lacks in speed and memory, it more than makes up in     ease of programming and operation, so we have an advantage there. Don't         forget, most computer users now, have very little ability or interest in        programming anyway, where as we do. It is our interest that has kept the        Oric going so successfully for so long.                                                                                                                         

One in 14 Million                                                               ----------------- Those are the odds on winning the jackpot. So how do you      pick the numbers and how much do you stake ? First consideration, the stake.    
In theory, if you have confidence in your ability, a single £1 coin, is all     
you need, however you don't need binary code to tell you that a second £1,      will lop a cool seven million off the odds against you. Thats good value        
at £2, because if you doubled up again, it would only knock off another         three and a half million from the odds, which is less of a bargain.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             That's the easy bit providing you have the money, of course. Picking the        
the right numbers is where we need the trusty Oric. Everybody probably has      their own ideas of how to go about this. As usual, my own feelings are to       concentrate on keeping it all nice and simple. Not being experienced in this    particular field, I would probably go about it in the following way.........                                                                                    

The "White Stick" Technique                                                     --------------------------- First thing is to make a note of the most recent    results. You don't need many, say about four consecutive weeks results.         Ignoring the "Bonus" numbers leaves four sets of six winning numbers each.      Look at them in another way, to see that you have six sets of four winning      numbers in sequence and what you need is the 5th number for each of the six     sets. In theory you have a choice of 1 to 49 for each number. However, as      
 you need to choose six numbers, the lowest cannot be higher than 44 and the     highest cannot be lower than 6 and the other four numbers are restricted in     
a similar fashion, which must improve the odds somewhat.                                                                                                        Initially, I would probably make some use of Oric's Random (RND) number         routines to generate a continuous sequence of numbers. The Random number        routine is located at #E34F (or #E34B for the Oric-1). Of course, initial       experiments could be tried using Basic, but I would probably use hex values     
and assembly language. You can in fact use decimal values in machine code       programs, the instruction SED (code F8h) sets it up in the 6502 Status          Register and instruction CLD (code D8h) clears it back to hex operation         again. However, you do have careful when using Decimal operation, that          nothing in the machine (including the Operating System), clears the Status      Register back to hex operation, when you are least expecting it.                                                                                                Taking the above example of six sets of four numbers each, I would set up       
the Random number routine to generate a continuous output, with the aim of      producing a matching set of four numbers for each of the six sets of four       winning numbers. This could be done by passing the random output through a      
set of four CMP (test) and BNE (branch) instructions, in much the same way      
as we have used in the past, to look for a specific address. This would be      
set up to indicate when the Random number generator has produced a matching     
set of four numbers, at which point, the next random number that follows the    sequence of four, is the magic "5th Number" that we are looking for.                                                                                            The next thing is to repeat the above operation for each of the six sets of     four winning lottery numbers to produce a new set of six numbers (the "5th      Numbers") for the next weeks Lottery ticket.                                                                                                                    Of course, in theory the numbers should be in the same numerical sequence as    
the original six sets of four winning numbers. It means that the "5th           Number" generated for the lowest set of four should be the lowest of the new   
set of "5th Numbers" and so on, in sequence up to the highest value set,        which should produce the highest "5th Number". It might be necessary to         generate quite a few sets of the magic "5th Numbers" in order to produce the    desired sequence of values. However, it should be possible to write a           routine to test for such a sequence, which would enable the whole thing to      
be done automatically. The Oric is able to generate and test vast quantities    
of numbers, far faster than anything done by hand. It should be possible to     achieve quite a lot with comparatively simple routines.                                                                                                         OK, so it's a far out idea ! but would it really work ? I have not tried it     myself yet, but who knows ? One thing, it is a great way to gain programming    experience. As for the Lottery ticket, it is more interesting than using        birthdates or house numbers and you never know..............................                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          



Machine Code for the Oric Atmos (Part 44)   Peter N. Bragg
-------------------------------                                           

The Story so far                                                                ---------------- Last time, we indulged in a little flight of fantasy.          Sometime in the future, we must have a look at how to use the Oric to invest    
all those millions you have won on the lottery. We have also been looking       
at programming technique. In the previous couple of issues we looked at a       short memory "swap" routine, which was initially aimed at preserving            
the contents of an area of memory, by swapping them out of the way, so that     
we could make use of that area for another purpose. When finished, the          "swap" call was simply repeated to return the original memory contents to       where they came from. The original excercise was intended for use with Zero     Page, although of course the resulting "swap" routine has many other uses       
and can be easily adapted for use anywhere in Oric's memory.                                                                                                    So what is this "Zero Page" and what makes it so special ? First of all,        "Zero Page" is the first 100 bytes of computer memory starting at #0000.        
I have seen it labelled as "Zero Page" and "Page00" and even "Page Zero".       Usually I use the shortest label, but it doesn't matter much which is used.                                                                                     Hopefully the idea of dividing up the computer memory into "Pages" is a         familiar one as it has been used throughout this series                                                                                                         Each "Page" is a block of one hundred bytes (in hexadecimal), which starts      
at address #nn00 and finishes at #nnFF ("nn" is the "Page" number used).        Splitting the memory into small blocks and labelling them this way, makes       
for easier programming, which is why it has been used.                                                                                                          Another advantage of doing it this way, is that the hardware is also based      
on the same idea, so it also fits in very nicely with that.                                                                                                     For example, most of the Oric's input and output facilities are handled by      "Page03", which is the area covered by addresses #0300 to #03FF inclusive.      
In this case, Oric's system programmers set up "Page03" for that purpose.       Other computers may well use "Page03" for something completely different,       even though they use the same 6502 microprocessor, that Oric uses.                                                                                              However, there are specific areas in the computer memory, earmarked by the      6502 for it's own special use. The main area reserved for the 6502 use,         starts at #0000 and ends at #01FF, which in fact is all of Page00 and Page01.   This area is genuine RAM and you can read and write to it in the normal way.    However, it is not a good idea to use it that way. At best it is a waste,      
 at worst, you could crash the computer. Note the fact that this applies to      all computers using the 6502 chip.                                                                                                                              We have already encountered "Page01", more commonly known as the "Stack",       earlier in the series. The "Page01/Stack" occupies all of the RAM area from     address #0100 to address #01FF (100 bytes in all) and is used by several        instructions, such as JSR and PHA, as a fast way to preserve data and return    addresses.                                                                                                                                                      The other half of that reserved area is "Page00" ("Zero Page"), which           occupies all of the RAM area from address #0100 to address #01FF. It is this    "Zero Page" which we are now going to look at.                                                                                                                  Essentially "Zero Page" is a one hundred byte register, designed for fast       easy storage and access for data and addresses. It has it's own special set     
of instructions, some of which are similar to those we have already used.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Remember the instructions that we used to fetch an item from, or put an item    into an address. For example, the instruction LDA 1002 will fetch a byte        into the Accumulator from address #1002. Likewise, the instruction LDA 0002     will fetch a byte from address #0002 into the Accumulator. These are            Absolute instructions However, as the second address #0002 is located in        "Zero Page", we have the option of using a "Zero Page" instruction, instead.                                                                                    The "Zero Page" instruction LDA Z 0002 will do exactly the same as the          Absolute type instruction, LDA 0002, so why is it useful ? Well this is not     obvious until you look at the instruction hex codes, produced on assembly.      
The hex codes for instruction LDA 0002 are AD 02 00. However the hex codes      
for the "Zero Page" instruction LDA Z 0002 are A5 02, which is just two         bytes against the three bytes required by the Absolute LDA instruction.                                                                                         The Absolute type instructions that we have used in the past, can access        absolutely anywhere in memory. A "Zero Page" instruction on the other hand      only provides access to the memory in "Page00" (#0000 - #00FF). The top half    
of the address is already "built in" to all "Zero Page" instructions. The       "Zero Page" version of STA 0002 is STA Z 0002 and the code for that is 85 02,   instead of 8D 02 00. As these are commonly used instructions, it is possible    
to save a lot of programming space by making use of "Zero Page" instructions.                                                                                   There is another advantage too. These "Zero Page" instructions are a bit        faster. The plain Absolute versions of LDA and STA require four cycles each     
(4 "ticks" of the Oric clock) to complete the operation. Their "Zero Page"      equivalents only require three cycles, so there is obviously a gain in speed    
to be had, particularly when used in frequently called routines.                                                                                                Many of the instructions in the 6502 Instruction Set have a "Zero Page"         version and in addition there are a number of specialised instructions,         involving the use of the Index/Registers X and Y, which are a bit more          complicated in operation, but can be very useful.                                                                                                               Ironically, it is the fact that the "Zero Page" instructions are very useful,   that causes one of the drawbacks. The instructions are popular with the         programmers of computer Operating Systems. They obviously have "first pick"     
of the "Zero Page" facilities and as a result you can find that most of the     "Zero Page" has been hijacked for use with the Operating System.                                                                                                Fortunately, this doesn't seem to be such a problem with the Oric. I checked    
on my own Atmos (with Sedoric). I found that providing "Basic" is not in use,   there appears to be only six "Zero Page" locations in use and active.           
The rest of "Zero Page" is free for our own use. The locations to avoid are     
#000C to #000F, plus #0012 and #0013. These handle screen operations and do     
not appear to be affected by anything written into them, because anything       written in, is itself promptly overwritten by Oric's Operating System.                                                                                          At this point I should mention that it isn't essential to use "Zero Page".      
In my case I wanted my own software to run on all three at least, of the        Oric, BBC Micro and Apple machines, with little or, no modification.            That aim was achieved, for a lot of my software, but it mean't having to use    Absolute instructions, because very little of the "Zero Page" space could be    guaranteed to be free in all three machines. Absolute instructions on the       other hand can access any address in the memory and they only need a common     
area of free RAM, in the three machines, which was not hard to find.            
You pays your money and takes your choice..................More next time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           



Machine Code for the Oric Atmos (Part 45)   Peter N. Bragg 
-------------------------------                                           

The Story so far                                                                ---------------- Last time, we started to have a look at a special selection    
of machine code/assembly instructions, known as the Zero Page instructions.     
The Zero Page area is located in RAM, starting at the address #0000 and         finishing at address #00FF. In other words, it covers the first 100 hex         bytes of the computer's RAM memory area. Zero Page instructions apply to any    computer, providing that computer uses the 6502 microprocessor. So this         applies to all of the Oric machines.                                                                                                                            The first advantage of Zero Page instructions that we noticed, is that they     
are shorter. The reason for this is quite simple. They have the top half of     
the address already built into them. If you recall the Absolute instructions    that we have used in the past, you may remember that they require a two byte    address in order to operate on the contents of a particular location. This      
is because an Absolute instruction operates absolutely anywhere in memory.      
The Zero Page instruction on the other hand only operates in the first 100      bytes of RAM, so it only requires two digits (a value between 00 and FF), or    
in other words a single byte, to set any location within that single Page of    
100 bytes.                                                                                                                                                      If you look at the standard Instruction Set for the 6502 Microprocessor, you    will find that there are 21 instructions for operations on the contents of      locations in the memory. That group of 21 instructions provide a large          variety of arithmetic and logic operations and also allow you to copy data      bytes to and from data memory. Each of them has an Absolute version and a       Zero Page version. The fact that it has it's own specific set of                instructions, is what makes the Zero Page area of memory so useful.                                                                                             Basically the Zero Page instructions do same operation, as their Absolute       counterparts. For example, if we wanted to add the contents of a location in    Zero Page, say address #0040, to the Accumulator contents, we could use the     Absolute instruction ADC 0040. The instruction hex code for that is three       bytes, ie. 6D 40 00. However, as that example is located in Zero Page, we       could instead use the Zero Page instruction, which will produce exactly the     same result. That Zero Page instruction is ADC Z 0040 and it's hex code is      just two bytes, ie. 65 40.                                                                                                                                      Of course, if you are using an assembler, this is not so obvious, in fact       
the label that you type in is slightly longer. However, the end effect is       just the same and the assembler will translate the Zero Page instruction        into those two hex codes, in the same way as it will translate the shorter      Absolute instruction into the three hex code instruction.                                                                                                       

Zero Page Index Instructions                                                    ---------------------------- Like the Absolute instructions, you will find      that the Zero Page instructions can be used with Register X and Register Y,     
to provide indexed operations, in the same way we have already seen indexing    used. However, I should point out that there are more instructions that can    
 use Register X than use Register Y.                                                                                                                             The subject of indexed instructions was covered in some detail in Part 21 of    
the series, however it would probably be a good idea at this point, to          refresh our memory on the subject, particularly as indexed instructions are     very useful for handling large amounts of data. In addition Zero Page also      
has a few special indexed operations of it's own.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

Indexed Instructions                                                            -------------------- We have found that most instructions operate on a one      single byte of data at a time. However, we also found that by using an          indexed instruction, a set of single byte operations can be linked together     
in a very small routine that can handle up to a 100 bytes at a time, by         using the Registers X or Y as an index. An indexed instruction works by         automatically adding the contents of Register X (or Y) to any address           contained in the instruction code or assembler label.                                                                                                           This enables us to use a single address and access up to 100 locations in a     simple loop, by simply changing the contents of the Register (X or Y).          Changing the value of Register X or Register Y for this purpose, is normally    done by incrementing or decrementing instructions which are simple one byte     instructions, that add or subtract 01 from the value held in Register X or      Register Y, depending on which one you are using.                                                                                                               For example, if we preset Register X to 04 (LDX #04) and then use the           instruction LDA X 3000, you will find that the result will be that the          contents of location address #3004 will be loaded into the Accumulator.         
The reason for this is, that the instruction added Register X's contents (04)   
to the instruction address #3000, to make #3004, the actual address used.                                                                                       It follows, that if you take the above example and put 00 into Register X,      
the indexed instruction LDA X 3000 will fetch the contents of address #3000.    
If Register X is incremented (using instruction INX) and LDA X 3000 is          repeated it will fetch the contents of address #3001. If you continue to        increment Register X and repeat the instruction LDA X 3000, you will            eventually fetch in turn, the contents of every location between address        
#3000 and address #30FF.                                                                                                                                        We can use a couple (or more) indexed instructions together in this way to      transfer data from one area of data memory to another area of memory. A         routine of this type was shown in Part 40 of this series. That was just a       very basic copy/transfer routine, that used LDA X and STA X instructions.       
You can also include more instructions in such a routine in order to make       modifications to the data enroute, if you wish.                                                                                                                 You may wonder why the particular interest in indexed instructions, with        respect to Zero Page, particularly as the Zero Page area itself, is limited     
to an area of only 100 bytes, compared with the entire memory area which is     available to the Absolute instructions.                                                                                                                         There is a good reason for this. The Zero Page access to memory is not quite    
as limited as it appears at first sight. There are additional instructions     
 to those that Zero Page already has in common with the Absolute set. These      allow the Zero Page instructions to access the entire computer memory by        using a technique called indirect addressing, together with the indexing        operations that we have already met.                                                                                                                            

Indirect Addressing                                                             ------------------- Like most things connected with computer programming, it    
is best to deal with this in simple stages. As I said above, the indirect       addressing operations are used together with indexing. The question now         arises, what is Indirect addressing ? The easiest way to find out, is to        look at an instruction, that actually uses it and that is what we are going     
to do next.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     There is just one instruction that uses pure indirect addressing on             it's own. Although that instruction is not connected with the Zero Page         instruction set, it does provide a good illustration of how indirect            addressing works and what it is.                                                                                                                                The instruction we are going to look at is the Indirect Jump, so we will        forget Zero Page for a moment and have a look at that version of the Jump       instruction, in order to see what Indirect addressing is all about and how      
it works.                                                                                                                                                       

The Indirect Jump                                                               ----------------- We have looked at the jump instruction "JMP" and have made    quite a lot of use of it already. It is the machine code version of the         Basic GOTO command. For example, if we want to jump to the address #1050, we    would use the instruction JMP 1050, the hex code for which, is 4C 50 10.        Don't forget the address is put into the hex code in reverse order. Now         there is another version of the JMP instruction, which we have not looked at    before, in this series. This is the indirect jump, or JuMP via Indirect         address. The instruction opcode in this case is 6C instead of the more          familiar 4C opcode used in the plain JMP instruction.                                                                                                           Once again, the Indirect Jump instruction contains an address, however that     address is used in a different way. The address is used as a pointer to the     location where the actual jump address can be found. The final destination      address of the indirect jump is actually stored in the address given in the     Indirect Jump instruction. So the Indirect Jump reads the contents of the       address given in it's instruction and then uses those contents as a final       address, to which it then jumps.                                                                                                                                So how does this work in practice ? Well, if you take our original example      again, but use the Indirect version instead, the instruction now becomes        
JMP I 1050 and the hex code for that would be 6C 50 10. However, the routine    would not jump to that address, what it would do instead is jump to an          address, which is held in the location #1050. Of course location #1050 can      only hold a single byte and Absolute addresses need two bytes for the whole     address. However that's no problem. It's all taken care of by the               instruction.                                                                                                                                                    The Indirect instruction deals with it by simply "earmarking" two adjacent      locations as the storage area for the final destination address. So in fact,    
the indirect jump above, which is JMP I 1050, will use both location #1050      
and location #1051, as the storage location for the address of the jump's       final destination.                                                                                                                                              This might seem unnecessarily complicated, compared with the the simple jump,   which goes straight to the address given in the instruction. However, the       Indirect Jump does have it's uses.                                                                                                                              It allows the programmer to put jump destination addresses into Parameter       blocks, where they can be easily changed, to control the final destination      
of a jump. It allows you to have two or more different endings to a routine,    which can then be switched around according to requirements. This can be        seen in computer operating systems where system programmers have set up a       parameter block, which allows you, the end user, to divert the computer         operating system to include extra routines of your own design as part of the    computer (Oric's) operating system.                                                                                                                             That's how the Indirect operation works........Next time, where it fits in.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            



Machine Code for the Oric Atmos (Part 46)   Peter N. Bragg
-------------------------------                                           

The Story so far                                                                ---------------- Last time, we continued to look at the special group of        machine code/assembly instructions, known as the Zero Page instructions,        some of which also make use of indexed operations. Having briefly revived       memories of those, we also looked at the subject of indirect addressing.        
The Indirect Jump instruction was used as an example of this operation.                                                                                         Although the Indirect Jump is not a Zero Page instruction, it does provide a    straightforward example of indirect addressing on it's own and is the only      standard 6502 instruction to do so, which is why it was used as an example      
to illustrate the operation. The point is that Zero Page has a number of        very useful instructions, that combine indirect addressing with indexing.       Hopefully, illustrating the two operations separately this way, will make       
the combination of them both, a bit easier to understand.                                                                                                       It might help to explain Indirect addressing if we have a look at a working     example. The rather silly routine below does just that. Once again, we call     
up Oric's useful collection of noises for the demonstration.                                                                                                    

Oric                       Demo Routines                          14 May 95     ----                       -------------                          ---------     
[ CALL#1030 ]--------------[ Ratchet Racket !!]-----------------------[1/2]
                          ---Parameter Block 1000---                            1000: FF      :            : Page Marker.                                       1001: 00      :  "nil"     : Copy of Keyboard input.
                                                                                                            1002:0C       : "start     : Address LSB /  Indirect Jump Address for           1003:10       :    addr"   : Address MSB /       instruction 1024.
             ---end--- 
                                                                                                                                            [--------------------------[ The Four Sound Calls ]-----------------------]

                          ---[Shoot !]---                                       1010:20 B5 FA : JSR FAB5   : Call "Shoot" routine.                              1013:60       : RTS        :    and return.

                          ---[Ping !]---                                        1014:20 9F FA : JSR FA9F   : Call "Ping" routine.                               1017:60       : RTS        :    and return.

                          ---[Zap !]---                                         1018:20 E1 FA : JSR FAE1   : Call "Zap" routine.                                101B:60       : RTS        :    and return.

                          ---[Explode !]---                                     101C:20 CB FA : JSR FACB   : Call "Explode" routine.                            101F:60       : RTS        :    and return.
          ---end--- 

                                                                                                                                            [ JSR 1024 ]---------------[ Indirect Instruction Demo ]------------------]
                                                                                     1024:6C 02 10 : JMP I 1002 : Jump to the address as set in Params 1002/03       1027:60       : RTS        :  and then return to main routine.
          ---end---

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Oric                       Demo Routines                          14 May 95     ----                       -------------                          ---------     
[ JSR 1030 ]---------------[ Sound Call Switcher ]--------------------[2/2]
         ---start---      ---Fetch a Key---                                     1030:20 78 EB : JSR EB78   : Read Keyboard (OS "GTORKB")                        1033:10 FB    : BPL"1030"  : until key pressed.

                          ---Continue or Finish ?---                              1035:8D 01 10 : STA 1001   : Save a copy of the Key press input and then        1038:C9 1B    : CMP"ESC"   : Test - Was "ESC" key pressed ?                     103A:F0 1E    : BEQ"105A"  :  Yes - so skip to finish now.
                               No - so........

                          ---Change Address for Indirect Instruction---         103C:AD 02 10 : LDA 1002   : Fetch Indirect address LSB from Param 1002         103F:C9 1C    : CMP "1C"   : Test - Is it last address ? (ie. addr 101C)        1041:D0 05    : BNE"1048"  :   No - so skip next two instructions
                              Yes - so........                                  1043:A9 0C    : LDA #0C    : Load Accumulator with 0C and initially             1045:8D 02 10 : STA 1002   :  reset Indirect address back to addr 100C
                                                                                          1048:EE 02 10 : INC 1002   :   Increment the LSB of the Indirect                104B:EE 02 10 : INC 1002   :    instruction address four times                  104E:EE 02 10 : INC 1002   :   in order to add 04 to it, so that                1051:EE 02 10 : INC 1002   :     it is set for the next "Call".

                          ---Make a Noise---                                    1054:20 24 10 : JSR 1024   : Go and use the "Indirect Instruction Demo"         1057:18 90 D6 : BCC"1030"  :  and then go back for another key press.

                          ---Finish---                                          105A:60       : RTS        : Exit back to Basic.
          ---end---
                                                                                                                                           Enter the complete routine using your favourite assembler or hexloader.         
I usually enter the hex code in the second columm only, it's quicker, but       whatever suits you, is best in the long run.                                                                                                                    The Indirect Jump instruction has a routine all to itself (JSR 1024), with      
an RTS added, to ensure return to the main routine. You will notice the jump    instruction address is 1002, however being an Indirect Jump, it will not        jump to 1002. What it will do instead, is read the address located in 1002     
and 1003. The jump requires a full two byte (16 bit) address, so the            instruction needs to use the contents of two adjacent locations, that is the    location indicated in the instruction and the next one up, which in this        case is location 1003.                                                                                                                                          Locating the jump address in a parameter block, like this makes it easy to      modify and we can use this to change the operation. Just like one of those      rotary ratchet switches, the routine switches through each of the four Oric     sound effects, by modifying the contents of the bottom half of the jump         address, thereby selecting a different sound call each time. The main           routine does that job, by switching the jump address in Params 1002/03, from    1010 to 1014, 1018, 101C and finally back to 1010 again, so that each time      
you press a key, you get a different sound. The listing hopefully explains      
the operation. You could use JMP 1030 (4C 30 10) in instruction 1057, also      
if you prefer (Q)uit to "Escape", change instruction 1038 to code C9 51.        Call#1030 to run it and annoy the neighbours !! See you next month..........                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          



Machine Code for the Oric Atmos (Part 47)   Peter N. Bragg
-------------------------------                                           

The Story so far                                                                ---------------- Last time, we interrupted our look at the Zero Page            instructions, to look in detail at another instruction called the Indirect      Jump. As explained at the time, the reason for this diversion, was that Zero    Page instructions make use of indirect addressing and the Indirect Jump uses    
a pure form of it. That makes it easier to explain how indirect addressing      works. As a demonstration is better than an explanation, that last article      also contained a small set of demo routines, in the hope that it would make     
the operation simpler to understand.                                                                                                                            The demo routines used the four Oric sound effects and the Indirect Jump        instruction was used to switch each sound effect in sequence, so that each      time you pressed a key, you would hear the next sound effect in the sequence.   
The only exception, was the ESCAPE key, which was used to provide a means       
of escape from the routines.                                                                                                                                    If you look at those routines again, you will find that essentially, you can    ignore the JSR 1030 (1030/5A), it's sole purpose is to provide the means to     change the contents of Params 1002 and 1003. The only minor point of            interest is that the the code listing for it makes it re-locatable, because     
it uses a CLC and BCC branch, instead of a jump at instruction 1057.                                                                                            The essential routine was JSR 1024, specifically the Indirect Jump at           instruction 1024. This was set to the address 1002, which meant that            
the instruction would make the computer jump to any address, currently set      
in locations 1002 and 1003. You can see that this is so, by stopping the        routine at regular intervals and examining the contents of locations 1002       
and 1003. In this case the address in 1002/03, will always be that of one of   
 the Four Sound Calls.                                                                                                                                           This may be a fairly trivial operation, but I have used the same operation,     written in 32 bit ARM machine code for modifying and updating a readout         display. OK, so it's a different instruction set, but the essential             functions are the same and probably are for most machine code/assembly          languages, so these little routines can be useful, in all kinds of software.                                                                                    Right, so we have looked at indirect addressing and just prior to that, we      looked at the indexed addressing again. Now, let's return to the Zero Page      instructions, some of which can combine both types of addressing, to produce    
a very useful operation.                                                                                                                                        

Zero Page again                                                                 --------------- There are two types of instructions, that use a combination     
of indexing and indirect addressing. One instruction type uses Pre-Indexed      Indirect Addressing and the other uses Post-Indexed Indirect Addressing.        Quite a mouthful ! So what does it mean ?                                                                                                                       Well, we now know that an indirect address is one that can be stored in a       parameter block and used like a stepping stone, by an indirect instruction      placed somewhere else in the depths of a program routine. We also know that     
we can access a series of addresses by using Register X or Register Y added     
to a single address. That enables us to read, write, or modify the contents     
of a small area of memory with a simple routine.                                                                                                                Put those two operations together and you get some interesting possibilities,   which brings us to the Pre-Indexed and Post-Indexed Zero Page instructions.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Note that the two instruction labels are exactly the same, except for the       words "Pre-" and "Post-" that start them off. These labels indicate two         things about the instruction operation.                                                                                                                         1) "Pre-Indexed" means that the indexing operation is done BEFORE the            indirect addressing operation and that Register X is used for the indexing.                                                                                    2) "Post-Indexed" means that the indexing operation is done AFTER the            indirect addressing operation and that Register Y is used for the indexing.                                                                                    What happens is this. You may remember that Zero Page instructions use the      memory area 0000 - 00FF. If you pick an address in this area, say location      0050 for your instruction address, the instruction will earmark locations       0050 and 0051 as the place it will find the address it will use.                                                                                                Now if you use a Pre-Indexed Indirect Addressed instruction, it will add the    contents of Register X to that address 0050. So if Register X contains 08,      
the instruction will add that 08 to it's 0050 location and will then look       
for a final address in locations 0058 and 0059 and it is the final address      stored in those two locations that it will use.                                                                                                                 On the other hand, if you use a Post-Indexed Indirect Addressed instruction,    
it will add the contents of Register Y to the contents of locations 0050 and    0051. If you set the address in locations 0050 and 0051 to address 1020 and     Register Y to 08, the instruction will add 08 to address 1020 to get an         address of 1028 which is the final address it will use.                                                                                                         In effect the two labels "Pre-" and "Post-" give you two options. If you use    "Pre-", you can use Register X to select a single Absolute address from a       range of Zero Page storage locations.                                                                                                                           If on the other hand, you use the "Post-" type instruction, you can use a       single Zero Page storage location to store an Absolute base address and then    
use the Register Y to select from a range of 100h addresses based on that       Absolute address, stored in the Zero Page location.                                                                                                             

Indirect Instructions                                                           --------------------- There are eight different operations available. Each     
 one offers a "Pre-" or "Post-" version, which can be operated as detailed       above. Available operations are load (LDA) and store (STA), add (ADC) and       subtract (SBC), three logic operations AND, EOR and ORA, plus the test (CMP).                                                                                   We have met all of these operations before in this series. These new Zero       Page versions operate in exactly the same way. The only real difference is      that they offer more options for access to data in memory.                                                                                                      If you were with me, way back in the beginning of the series, you may recall    that we started by loading an item and then storing it in the data memory.      Yes, it could be done with a couple of simple instructions (LDA and STA) but,   
it was a very slow method of programming and required a new set of addresses    
for each and every item. Certainly you could write successful software that     way, but who would want to ? Later on, we found that that we could write a      simple routine to deal with larger areas of memory using Registers X and Y      
and indexed instructions. The Zero Page instructions briefly looked at above,   
now add to our programming facilities, by allowing us to remove variable        items such as addresses from program routines and store them in a more          convenient parameter block. More on the subject next time..................                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           



Machine Code for the Oric Atmos (Part 48)   Peter N. Bragg
-------------------------------                                           

The Story so far                                                                ---------------- Last time, we finished our look at the Indirect Jump           instruction and returned to the subject of Zero Page instructions.              
The reason for the slight diversion, was that Zero Page instructions use a      combination of indirect and indexed addressing and it was essential to          explain how indirect addressing works, before covering it's use in Zero Page.   This was then followed by a brief overview of the two main types of Zero        Page instructions that use a combination of indirect and indexed addressing.                                                                                    Now all that may have sounded a bit overwhelming. Perhaps this would be a       good time to remember two things.                                                                                                                               

Do we need Zero Page ?                                                          ---------------------- First of all, any series that looks at 6502 machine      code programming, would be incomplete, if it did not cover Zero Page and the    instructions that apply to it. However, that doesn't mean to say that you       have got to use Zero Page instructions. There are plenty of alternatives and    
we have seen quite a few of them in this series.                                                                                                                It is possible to write assembly/machine code programs that are perfectly       sound without ever needing to use Zero Page instructions. In fact, if you       
are making use of other 6502 computers, you may well find that most of Zero     Page has already been taken over by their operating systems, so you may have    little option in that respect, if you intend to transfer your efforts to        another machine.                                                                                                                                                

Slow down and Back up ?                                                         ----------------------- Hopefully, breaking up the whole subject of the         Zero Page into small sections and dealing with each separately, as I have       tried to do in this series, will eventually make the whole lot, easier to       understand, in the long run.                                                                                                                                    When I start to deal with something totally new, I find it easier if there      
is time to deal with it in easy stages, a bit at a time. I often come back      
to something that I have already read and go over it again perhaps several      times. I may also try a few simple experiments to see if I have really got      
the hang of it.                                                                                                                                                 This is one advantage of doing computing as a hobby, you can take your time     over it, the whole thing is supposed to be fun anyway and if you are not        enjoying it you are going about it in the wrong way.                                                                                                            

Two Options                                                                     ----------- Last time, we saw that there are two sets of special Zero Page      instructions. Each of the two sets can provide a choice of eight familiar       operations, such as load the Accumulator (LDA) or write the Accumulator's       contents into memory (STA). The operation and end result is exactly the same    
as those instructions, of the same name that we have already covered. The       only new thing about the instructions, are the two methods of addressing,       which take advantage of the special facilities offered by Zero Page.                                                                                            We started to look at these addressing modes last time. Let's continue to       expand on that to see how they are used. The two types of instruction are -     "Pre-Indexed" which uses Register X and "Post-Indexed" which uses Register Y.   They both use addresses stored in Zero Page data memory (#0000 - #00FF).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        A "Pre-Indexed" instruction allows you to select and use an address from a      range of two byte addresses, previously set up and stored in Zero Page.                                                                                         The specific address required is selected from the range of addresses, by       using Register X and the base location in Zero Page. Remember, a Zero Page      instruction is just two bytes and only one of those bytes is needed to          specify the base location in Zero Page. The contents of Register X is added     
to that base location to find the specific storage location in Zero Page.       
The instruction then reads contents of both that storage location and the       next location up, which it then uses as a two byte Absolute address. That       final Absolute address is where the instruction operation is carried out.                                                                                       A "Post-Indexed" instruction is slightly different, in that it uses a           Zero Page location to locate a single Absolute address. This time the Zero      Page instruction just reads the contents of that location and the next          location up and uses the result as a two byte Absolute address. Now it is       that address, which is indexed by adding the contents of Register Y to          produce final address where the instruction operation is carried out.                                                                                           In both cases, the final address is the so-called "indirect" address.           
The label "Pre-Indexed" indicates that the indexing is done before the final    indirect address is accessed. The label "Post-Indexed" indicates that the       indexing is done after the indirect address has been found. Some books can      
be a little confusing on this subject. Now let's have a look at how these       
instructions can be put to use.                                                                                                                                 

Pre-Indexed Addressed Instruction                                               --------------------------------- The example below loads the Accumulator       with an item from data memory, using a "Pre-Indexed LDA" instruction.           Initially, we need to set it up by putting a data item into the data memory     
and an address into Zero Page as per the example below.
                                                                                                         [--------------------------[ Any old routine/anywhere ]-------------------]
  
                          ---Fetch Data item into Accumulator---                nnn0:A2 06    : LDX #06    : Set Index/Register X to 06 and                     nnn1:A1 80    : LDA (80,X) :  then fetch data item from indirect address.
                                                                                       [--------------------------[ Address and Data Storage ]-------------------]
                          ---Parameter Block in Zero Page---                    0086: 02      :            : Two byte storage for the                           0087: 10      : "1002"     :    Indirect Address.
          ---end---
                          ---Parameter Block 1002---                            1002: 58      :   "X"      : Item of data (ie. ASCII code for letter "X")
          ---end---                                                             ---------------------------------------------------------------------------     
The instruction at nnn0 sets Register X to 06. The instruction nnn1 adds        that 06 in X, to it's own operand 80 to produce a location 86 in Zero Page.     
It uses that location to access the contents of locations 0086 and 0087,        which contain the indirect address 1002. That indirect address is then used     
to fetch the data item held in 1002. The end result is that instruction nnn1    loads the Accumulator with a copy of the data item ("X"/code 58h).                                                                                              That's the "Pre-Indexed LDA" instruction. The other eight "Pre-Indexed"         instructions are set up and addressed in exactly the same way. Next time we     will look at the "Post-Indexed" type, which for my money, is more useful.