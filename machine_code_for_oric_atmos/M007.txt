            Machine Code for the Oric Atmos (Part 35)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We have looked at essentials for machine code programming      and a small selection of useful 6502 Instructions appeared in Part 22 of the    series. Recent issues have looked at masking and shifting instructions.                                                                                         As I have mentioned before, these instructions have a number of uses.           They are useful for setting up hardware and can also be used for arithmetic,    multiplication and division. They can also be used in graphic displays.         It might be useful to look at one way, I have made use of them in the past.                                                                                     

Shifty Graphics                                                                 --------------- Some years ago I wanted to transfer some graphics from the      BBC micro to the Oric. I managed to dump a graphic image from the BBC micro     into the Oric's data memory. However, it certainly could not be put straight    into the Oric's HIRES display, because it was incompatable with the Oric's      display requirements and had to be converted first. For that, you need to       know what the differences are between the Oric and BBC graphic displays ?                                                                                       The BBC display is essentially character based and each byte in the BBC         display mode that I was using, represented eight pixels on the display.         Now, in the Oric Atmos HIRES screen, each byte represents six pixels only.      The other two bits in each screen byte are used to control the Oric's           display effects. So, if the BBC graphic was put straight into Oric's            HIRES display, the result would be that the first six BBC pixels would set      Oric pixels correctly, but the remaining two would create havoc in Oric's       display controls. That would apply to each and every byte on the Oric's         screen. Not a pretty sight ! Obviously the BBC graphic pixels had to be         re-arranged from eight bit groups, into six bit groups for the Oric.                                                                                            A complete description of how to convert BBC graphic screens to Oric HIRES      is beyond the scope of an article like this and has no interest to users of     other machines, anyway. However, a quick look at how the problem was tackled,   could be useful to most users and may also provide some useful insight into     programming technique, as well as the rotation instructions.                                                                                                    So how does one start out to write a piece of software to convert a graphic     from one machine to another ? The best way is to reduce the conversion          operation to the smallest possible unit and work it out for that unit only.     Once that has been achieved, it can be wrapped up into a program routine        which can then be repeated for the whole graphic image, reading it in bit       by bit and converting it and putting it into Oric's HIRES screen.                                                                                               The smallest unit common to the Oric and BBC computers is one horizontal        line of 24 pixels. The maths experts amongst us, will have worked out that      if the Oric display byte contains six pixels and the BBC byte contains eight,   three BBC graphic bytes are equal to four Oric HIRES display bytes, because     they both produce 24 pixels. The rest of us can now put our shoes and socks     back on !! Now, back to the rotate instructions. How can they help ?                                                                                            You may recall that the rotate instruction pushed the Carry bit into one end    of a byte, shifting all the eight bits sideways, causing the bit at the         other end to "fall out" and be copied into the Carry. This means that the       next rotate instruction will use that bit, saved in the Carry and will push     it back into the byte at the other end.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         So by repeating the same rotate instruction, you can make the entire byte       rotate through the Carry, bit by bit. This rotate operation can go in either    direction, using ROL for (ROtate Left), or ROR for (ROtate Right).                                                                                              However, it isn't necessary to restrict the operation to a single byte.         If you rotate two bytes in succession, the bit put into the Carry from the      first byte will be transferred to the second byte, by the second rotate         instruction. In effect you will have linked the two bytes with the two          instructions and by repeating the two instruction operation, you can            transfer the contents of one byte to another literally, bit by bit.                                                                                             Three instructions will link up three bytes in the same way, in fact there      really is no limit to the number of bytes that can be rotated as a single       group in this way.                                                                                                                                              Back to our BBC graphic, held in the Oric's data memory. We can link three      BBC graphic bytes plus one Oric HIRES byte together in this way and rotate      the BBC pixels, bit by bit into the Oric HIRES byte, using a simple routine.    Repeat the routine six times to put six BBC pixels into the Oric HIRES byte.    Get the next Oric HIRES byte and repeat the same operation six times to         transfer the next six pixels into the second HIRES byte. The same can be        done to the third and fourth Oric HIRES bytes, by which time the entire         collection of twenty four pixels from the three BBC graphic bytes will have     been transferred in the correct order to the four Oric HIRES display bytes.                                                                                     Of course the two Oric control bits will have been rotated out of the Oric      display bytes by the above operations, but they can be easily re-installed      with a couple of masking instructions. I used an AND #3F (0011 1111) to         clear bits 6 and 7 of each HIRES byte, followed by ORA #40 (0100 0000),         which set bit 6 to "1" in each HIRES byte (required for pixel data display).    The two masking instructions were tacked onto the end of the rotate routine.                                                                                    First of all I tried all of this, using the first three addresses of the        BBC graphic image stored in the Oric data memory and the first four             addresses on the Oric HIRES screen. A line of 24 pixels is quite small, but     it was sufficent to check that the operation worked correctly.                                                                                                  Once that was achieved, I was then able to exchange the fixed addresses of      the graphic and display bytes for a more flexible set of addresses set up in    a parameter block instead. The parameter block made it easy to change the       addresses used by the conversion routine to access the graphic image storage    area and the whole HIRES display RAM area. The conversion routine could now     be called repeatedly in a sequence, that would convert the BBC graphic image    to the Oric HIRES display, in sets of 24 pixels at a time.                                                                                                      Yes, I have over simplified the description and left a lot to imagination,      for reasons already explained. There are other solutions, some are better !                                                                                     This series is mainly aimed at those who are not too familiar with machine      code/assembly language programmming. Inevitably there will be those who say     "Gawd, I didn't understand a word of that !!". Dont worry, it's not             essential to be able to convert graphics from the BBC Micro. The main idea      was to illustrate how the rotate instructions can be used and to give some      idea how to tackle a software project. If you are still unsure about            instructions for rotating and masking, have another look at the last few        issues. Try a few experiments, using simple values for a start. Doing that      on the Oric and seeing results conveys far more than just reading about it.     So switch on and go !! .................................See you next month.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           


		Machine Code for the Oric Atmos (Part 36)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We have looked at essentials for machine code programming      and a small selection of useful 6502 Instructions appeared in Part 22 of the    series. Recent issues have looked at masking and shifting instructions and      last time we had a very superficial look at how those instructions can be       used to convert graphic screens from one machine to another.                                                                                                    It is some time since we had a working example to play with, so let's have      something that makes some practical use of what we have seen so far.                                                                                            

Take a shufti                                                                   ------------- We talk about the Accumulator or a location containing a hex      value and we can use PEEK to read that value, but that's a bit inconvenient     for most purposes. A utility that could display any value, we care to fetch,    is useful and so let's have a look at one. It may not seem very ambitious,      but bear in mind that such small utilities are very essential as building       bricks for all kinds of software. They only have to be written once and can     then be called up with a single instruction and used time and time again.                                                                                       This particular utility can be found in most computers. I wrote this version    for the Microtan as part of a core set of utilities that I subsequently         copied to and then used in the BBC micro, the Apple and the Oric, virtualy      unchanged. As you will appreciate, that saved a lot of software writing.                                                                                        

Show that Byte                                                                  -------------- The most common value used in our machines is one hex byte       (00 to FF) and we mostly work with this, or multiples of it, so this is the     value we need to be able to display. One hex byte consists of two digits,       each of which occupies four bits and is popularly known as a "nybble". When     we display a hex byte, we need two display codes, that is one for each digit.                                                                                   To distinguish between the two digits, we label them "MSB" and "LSB", which     is an abreviation for "Most Significant Bits" and "Least Significant Bits",     respectively. The "MSB" is the first (highest value) digit and the "LSB" is     the second (lowest value) digit and they both run from "0" to "F".                                                                                              Listed below, you will find a routine and subroutine, which can be entered      into the Oric in normal way, using your favourite assembler or hex loader.      If you put any hex value (00 to FF) into the Parameter Block at location        1001 and then CALL#1040, you find that the display codes for that value are     put into the Parameter Block at locations 1002 and 1003. Next time, I will      provide a simple demonstration routine to show how it can be used.                                                                                              So how does it work ? The hex byte is in the Accumulator and we start by        preserving a copy. The main routine at 1040 - 1058, then splits the hex byte    up into two separate digits, the "LSB" and the "MSB". First it deals with       the "LSB". It does this by masking out the "MSB" to remove it and leave the     "LSB" only. The subroutine at 105C - 1066 can then translate that "LSB" in      the Accumulator into the appropiate display code. For numbers "0" to "9",       the display codes run from 30 to 39 respectively, so it is only necessary to    add 30 to the "LSB" value. Display codes for "A" to "F" run from 41 to 46       respectively, hence the need to add an additional 07 for these six letters.     The "LSB" display code is then saved in Param 1003 and a fresh copy of the      original hex byte is now fetched for the "MSB" display code conversion.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         The subroutine only deals with "LSB" digits, so the "MSB" is separated, in      the main routine, by shifting it right four times so that it pushes the         "LSB" digit out and takes it's place as a psuedo "LSB". That means that it      too can be processed by the subroutine, to produce a display code, which is     saved in Param 1002. We now have both display codes for the hex byte.                                                                                           

Oric                       Demo Routines                          25 Apr 94     ----                       -------------                          ---------     [ CALL#1040 ]--------------[ Convert Hex Byte to Display Code ]-------[ / ]
				  ---Parameter Block 1001---                            1001:         :            : Copy of Hex Byte to be displayed.                  1002:         :            : MSB/1st character for display                      1003:         :            : LSB/2nd character for display

                          ---Start---
      ....        ....     : Enter with hex byte in Accumulator

				  ---Convert LSB digit---                               1040:8D 01 10 : STA 1001   : Save copy of Accumulator contents in Param 1001    1043:29 0F    : AND# 0F    :  and then remove MSB digit using binary mask
                              to leave LSB only. (mask = 0F = 0000 1111 bin)   1045:20 5C 10 : JSR 105C   : Convert remaining LSB digit to Display Code        1048:8D 03 10 : STA 1003   :  and save it in Param 1003 for later use.

				  ---Convert MSB digit---                               104B:AD 01 10 : LDA 1001   : Fetch copy of original Accumulator hex byte.       104E:4A       : LSR Accu   :  Shift MSB digit four times to the right,
   F:4A       : LSR Accu   :   so that the LSB digit is pushed out and lost     1050:4A       : LSR Accu   :   and the MSB replaces it, now as an "LSB".
   1:4A       : LSR Accu   :                                                    1052:20 5C 10 : JSR 105C   : Convert "LSB" to Display Code (for the MSB).       1055:8D 02 10 : STA 1002   :  and save it in Param 1002 for later use.

                          ---Finish---                                          1058:60       : RTS        : Exit
          ---end---

[ CALL#105C ]--------------[ Convert LSB to Display Code ](sub)-------[ / ]

                          ---Start---
      ....        ....     : Enter with hex code LSB only in Accumulator.

                          ---Convert LSB to Display Code---                     105C:18       : CLC        : Clear Carry Flag.                                  105D:69 30    : ADC# 30    : Add 30 to the LSB (OK for values "0" to "9").

105F:C9 3A    : CMP# 39+   : Test - is value outside "0" to "9" ASII range ?    1061:30 03    : BMI"1066"  :   No - so OK to skip to end of subroutine now.
                              Yes - so it must be in "A" to "F" ASCII range,    1063:18       : CLC        : so clear Carry Flag again and                      1064:69 07    : ADC# 07    :  add another 07 to value to produce
                              the ASCII display codes for "A" to "F"

                           ---Finish---                                          1066:60       : RTS        : Exit (return to main routine with display code).
          ---end---
                                                                                                                                             Next time, we can add a short demo routine to show this in operation........

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          		Machine Code for the Oric Atmos (Part 37)   Peter N. Bragg                      		-------------------------------

The Story so far                                                                ---------------- We have looked at essentials for machine code programming      and a small selection of useful 6502 Instructions appeared in Part 22 of the    series. Last time we listed a simple utility that would enable us to show       any hex byte value, by producing the required pair of display codes for it.     As promised, listed immediately below is a simple demonstration routine that    makes use of that utility, plus an abreviated repeat of the utility listing.                                                                                    

Oric                       Demo Routines                          25 Apr 94     ----                       -------------                          ---------
[ CALL#1010 ]--------------[ Demo - Display Key Code ]----------------[ / ]
                          ---Parameter Block 1001---                            1001:         :            : Copy of Hex code item in Accu (Keyboard input).    1002:         :            : MSB/1st character for display                      1003:         :            : LSB/2nd character for display

         ---start---      ---Fetch a Key---                                     1010:20 78 EB : JSR EB78   : Read Keyboard (OS "GTORKB")                        1013:10 FB    : BPL"1010"  : until key pressed.
                                                                                                                 1015:8D 01 10 : STA 1001   : Save a copy of the Key press input and then        1018:20 40 10 : JSR 1040   : convert that input (Hex Code) to Display code.

                          ---Display the Hex Byte--                             101B:8A       : TXA        : Copy Register X into the Accumulator and then      101C:48       : PHA        :  put that onto the Stack to preserve Reg X.
                                                                                        101D:AE 02 10 : LDX 1002   : Fetch MSB display code and put it into Reg X.      1020:20 7C F7 : JSR F77C   : Use OS "VDU" to display it.                        1023:AE 03 10 : LDX 1003   : Fetch LSB display code and put it into Reg X.      1026:20 7C F7 : JSR F77C   : Use OS "VDU" to display it.
                                                                                                        1029:A2 20    : LDX#"Space": load a Space code into Register X and then         102B:20 7C F7 : JSR F77C   :  use OS "VDU" to display two spaces                102E:20 7C F7 : JSR F77C   :  to separate each displayed hex value.
                                                                                             1031:68       : PLA        : Retrieve original Register X contents into Accu    1032:AA       : TAX        :  and copy them back to Register X.

                        ---Continue or Finish ?---                              1033:AD 01 10 : LDA 1001 : Fetch copy of Key input again for test.              1036:C9 1B    : CMP"ESC" : Test - Was "ESC" key pressed ?                       1038:F0 03    : BEQ"103D":  Yes - so skip to finish now.
                             No - so........

                        ---Continue---                                          103A:4C 10 10 : JMP 1010 : back to read keyboard again for next key press.

                       ---Finish---                                            103D:60       : RTS      : Exit back to Basic.
             ---end---
                                                                                                                                             The utility can produce display codes for a single hex byte, but it really      needed something to show how it could be used. The demonstration routine        listed above is limited in operation to the codes available on the keyboard,    but hopefully, it does illustrate what the utility can do and how it works.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

The listing immediately below, is for the display code conversion utility,
                               which is called by instruction 1018, in the      1040:8D 01 10 29 0F 20 5C 10   above listing. This abreviated listing is        1048:8D 03 10 AD 01 10 4A 4A   only included here, to complete the working      1050:4A 4A 20 5C 10 8D 02 10   demo, above. To understand the utility you       1058:60 00 00 00 18 69 30 C9   really need the full listing and description     1060:3A 30 03 18 69 07 60 00   which appeared in last months article.
                                                                                           The routine was written for the Atmos, so Oric-1 users should change            instruction 1010 to 20 05 E9. Also instructions 1020, 1026, 102B and 102E,      should all be changed to 20 3F F7 in order to run it on the Oric-1.                                                                                             

The small Parameter Block 1001 is the same one featured in last months          listing, the hex byte stored in location 1001 is the keyboard input. All of     the operations listed in the above demo, have been covered in past articles,    however, it is worth having a brief look at how the demo routine works.                                                                                         Once called by CALL#1010 the demo routine reads the keyboard using the          BPL Branch instruction to provide a loop which repeats the keyboard reading     until a key is pressed. As soon as that happens, the code for the key is        stored in location 1001 and the utility, covered in detail last time, is        called up by instruction at 1018 to produce the two display codes from the      key press input (hex byte). Those two display codes are then stored in the      Parameter Block, in locations 1002 and 1003, ready for use. Now we only need    to display the two codes in the correct order.                                                                                                                  The display codes must to be loaded into Register X in order to use Oric's      display call "VDU". It is not essential here, but it is a good practice to      preserve Register X before using it. This is done by instructions 101B and      101C, which in effect make the Register X operations "transparent". Make it     easier for yourself by doing things this way, because when you write larger     pieces of software, you won't have to worry about whether you are going to      corrupt Register X for something else in your software. All you have to         remember is to reverse the procedure when you have finished using Register X,   in order to retrieve the original contents. This is done in the demo routine    by instructions 1031 and 1032.                                                                                                                                  The display codes are fetched into Register X and displayed using Oric's        "VDU" call. The "MSB" is displayed first and is followed immediately by the     "LSB" display code. The demo will display the result of any number of key       presses. The individual key codes really need a couple of spaces between        each one to make them easier to read, so instructions 1029 to 102E provide a    space and display it twice to provide visual separation.                                                                                                        Now, having displayed the key code, what happens next ? The obvious course      of action is to return and read the keyboard again. That is done by the JMP     instruction at 103A, which loops back to read the keyboard again. However,      we also need to provide some way to exit from the program, when we want it.     We could always just bang the Reset Button, but that is not the best way.       What we have here, are three instructions at 1033 to 1038, that fetch           another copy of the key input and test it, to see if it is "Escape Key"         (code 1B). If the CMP instruction finds the "Escape Key " code, it will         enable the BEQ Branch at 1038 and the operation will then skip the "loop"       instruction 103A and instead will go straight to the Exit (instruction 103D).   Of course, you dont have to use the "Escape Key", to quit the program, you      could try "X" for eXit or "Q" for Quit instead.                                                                                                                 
That's it. A simple demo that can be modified for your own use.............                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          


		Machine Code for the Oric Atmos (Part 38)   Peter N. Bragg                       		-------------------------------                                           

The Story so far                                                                ---------------- We have looked at essentials for machine code programming      and a small selection of useful 6502 Instructions appeared in Part 22 of the    series. The last two articles listed a simple utility that would enable us      to display any hex byte value and then added a short demo routine, which        made use of the utility to show the codes for each key on the keyboard.                                                                                         This years Oric Meet was very enjoyable, with interesting things to see and     new software from the UK and France. A certain person, who shall remain         nameless, showed me the assembler listing of a very clever piece of software.   He only uses a bare assembly listing and doesn't make notes on how it works.    Would he remember enough about it if he wanted to make use of it in couple      of years time ? Yes, he thought he would, but I noticed a slight hesitation     there, Buddy !! If it was me, no way would I remember. Writing instructions     and entering them into the computer is the easy bit. Thinking up the program    is the hard part and it is the part that you need to preserve, preferably on    paper. So let's have a look at how to do that with the minimum of effort.                                                                                       

Programming                                                                     ----------- We have already looked at some of the techniques that I have        found, make programming easier for me. Of course a lot depends on your own      preferences and personal circumstances, but there is no doubt that the right    technique for you, can make life a lot easier when programming. So have a       look at what other people are doing and be prepared to experiment a little.                                                                                     

Listings                                                                        -------- My own software in the computer, consists entirely of hex code for     the instructions and the hex data required by them. It makes the programs       very short and easy to enter and very much less prone to typing errors.         This means that information about program operation and instruction labels      is confined to the paper listings only. I find that a listing on paper is       essential when writing software, because it is far easier to deal with, than    on the computer screen, particularly when checking for errors.                                                                                                  For very good reasons, which I will come back to later, my program listings     are written or printed out on seperate sheets of 5"x 7" notepaper. These are    are then stored in simple card folders of that size.                                                                                                            The program listings are arranged in a very similar format, to those            published in this series of articles, that is, a headed sheet with a number     of columms, one each for address, code, assembly labels and description.                                                                                        As a single routine may take up more than one sheet, each and every sheet is    headed with four essential pieces of information. These are Software Label,     Routine Label, Routine Call Address and the Date. As the listing consists of    seperate sheets, it is advisable to put these four items on all of the          listing sheets, so that they don't get muddled up with other software.                                                                                          The first two Labels are obvious, they describe the software and the            specific routine, respectively. Just keep them short and easy to pronounce.     Jaw cracking labels can be confusing and are more difficult to remember.                                                                                        Next item is the Call Address, which is normally a "JSR" address, used to       call the routine into operation. Life is easier if the Call Address and the     routine's first instruction address, are one and the same. That may seem        obvious but not all programmers do it.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Some programmers start by jumping into the middle of a routine and quite        often exit from the middle of a routine as well. That may be clever             programming, but it seems a bit haphazard to me. I prefer to start at the       beginning of a routine and exit from the end, with a clear Finish/Exit          operation. It makes the routine easier to understand.                                                                                                           The listing sheet may hold a parameter block full of data instead of a          routine, in which case, a Parameter Block address would be used for the         heading, instead of a Call Address. The location of the first data item is      used as the parameter block address.                                                                                                                            The final item at the top of every listing sheet, is the date. This is the      start date for that particular software project and it is used throughout       the software listing, even if that software project takes months to complete.   A date is more useful than a "version number" for software.                                                                                                     

Down the Tubes !                                                                ---------------- Initially, my own programming technique was very much          influenced by the fact that I had very little time to actually use the          computer, but quite a lot of time to spare, for example, sitting around in      London's Tube trains, experiencing the dubious pleasure of commuting to and     from work. It seemed a good idea to make the best use of available computing    time, by writing as much software as possible on the train and anyway it is     a good way of livening up a boring journey. A small writing case and a set      of minature crib cards, to hold the essential machine code instruction sets     plus other useful computer details, was all that was needed. The result was     usually something ready to try out when I had time to switch on and go.                                                                                         This is where it pays to split up the programming into small tasks, each of     which can be written and tested out individually, before adding it to the       latest software masterpiece. A large piece of software can be built up this     way and is more likely to be successful. It also makes programming a lot        more fun. If you don't enjoy it, there isn't much point in doing it.                                                                                            

All Change !                                                                    ------------ In the last few years the situation has changed and I now have     more time at the computer and as a result, I now use it more, for writing       programs. That has some advantages, but there are pitfalls too. Repetetive      listings are easy to write using a wordproccessor but that also makes it        easier to duplicate errors. A pencil is far more versatile than a printer       which is limited by the character set and number of columms available, but      pencilled listings are a heck of a lot slower to produce. In the end, I have    found that a mixture of word processing, plus some pencilled in items, where    more details or a sketch are required, works best for my listings.                                                                                              The 5"x 7" paper size for the pencil listings is provided by those handy        spiral backed "reporter pads". It is also possible to produce a listing         sheet of the same size, from a printer. Our MP 165 dot matrix printer can       produce a 46 line, 80 columm listing, on a 5"x 7" sheet, using "Elite".                                                                                         I have also made a lot of use of the Tandy GCP 115 printer, which is            virtually the same as the Oric MCP 40. These produce slightly narrower          sheets at 4.5" width. This is used with a dis-assembler to produce quick        listings in 80 columms ("S0" size). The necessary information about program     operation is added to the listing in pencil.                                                                                                                    That's it for this month.................more instant crash gen next time !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          


		Machine Code for the Oric Atmos (Part 39)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We have looked at essentials for machine code programming      and a small selection of useful 6502 Instructions appeared in Part 22 of the    series. Last time, we started to have a closer look at programming technique.                                                                                   

Write On !!                                                                     ----------- One can write programs with very simple tools, essentially a        pencil, notepad and rubber eraser. There are many people who try to write       programs in ink or biro in a note book with fixed pages. Inevitably, you        will make some errors and when that happens, you will find that it is much      easier to modify or correct program listings written in pencil.                                                                                                 I use a small notepad with detachable pages and most important, write on one    side only. The ability to shuffle the listing around on single-sided sheets     of paper is a tremendous help, if you need to sort out a programming problem.   The listing can be spread out and looked at in plan form. Errors can then be    corrected and modifications can be made with the minimum of effort.                                                                                             Of course, the wordprocessor provides even better facilities for alteration     and correction than the pencil and rubber eraser combination and is a lot       quicker to use. However, it does have limitations in display and printout.      This is really a matter of personal choice. I find that a combination of        handwritten and wordprocessed listings works best for me.                                                                                                       

So why bother ?                                                                 --------------- I feel that good clear listings are essential for three         reasons. First, they make it easier to sort out any errors and get the          software working, secondly, they are invaluable, when you decide to update      and improve the software and finally, listings from successful software can     save a lot of time and effort when writing new stuff.                                                                                                           It is worth making a small effort to produce some additional notes.             The traditional "REM" statement, is bit too limited to be useful in this        respect and I prefer a listing of the type used in this series of articles,     which is not much different from those found in Oric's "Advanced User Guide".                                                                                   

Assembler ?                                                                     ----------- A lot of people use Assemblers. They may be useful for entering     the machine code/assembly language, but they are no use for the actual          programming. The hardest part of programming, is to break your ideas down       into separate operations and then select the right instructions for each one    and an assembler is no good for that. They also tend to be a bit slow to use    and have more scope for errors, which is why I haven't used one for years.                                                                                      On the other hand, Assembly Language is a very useful tool. It provides a       connecting link between the drab code numbers required by the Oric and the      much more interesting program operation described in your listing.                                                                                              If you look at the listings published in this series of articles, you will      notice that they are divided into three main columms. The centre columm is      the Assembly Language columm. To the right of that is the description of        what each Assembly Language instruction is doing and why. On the other side,    to the left of the Assembly Language columm are the instruction hex codes       and data and their addresses. These are usually written in last of all after    the Assembly and program description, because at that stage, hex codes can      be easily entered using an instruction code table (on a small crib card).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       My listings usually have one instruction per line, with a blank line            separating each operation. The aim is to make the listing easy to read.         Look at the listings in this series and you will see instructions grouped       together as specific operations. The operation below is a typical example.                                                                                      This sample uses three instructions. It fetches an input, tests it and uses     the result to decide on which one of two actions, it will put into operation.   This is the way I would write it, to make the listing readable.......

                          ---Continue or Finish ?---                            1033:AD 01 10 : LDA 1001   : Fetch a copy of Key input for test.                1036:C9 1B    : CMP"ESC"   : Test - Was "ESC" key pressed ?                     1038:F0 03    : BEQ"103D"  :  Yes - so skip to finish the routine now.
                              No - so continue with next operation.
                                                                                            Other operations are listed in a similar fashion, to that shown above.          A blank line above and below each operation and possibly a brief "title",       help to separate out each operation and make the whole listing that much        easier to follow.                                                                                                                                               

Waste Paper Production !                                                        ------------------------ My listings are written or printed on single-sided     sheets for reasons given above and use a small paper size, for easy storage.    I can write and read fairly small print and so I can get quite a lot of         information on the listing sheets, which are seven and a half inches by five    inches in size (say 190mm by 125mm in metric). A spiral backed "reporter"       note pad is ideal for handwritten listings. I also make the wordprocessor       listing printouts the same size.                                                                                                                                If eyesight is a problem, it would be better to use a larger size, but keep     to a single size and only use one side of the paper and you will find that      it makes life a lot easier.                                                                                                                                     

And there's more                                                                ---------------- Inevitably, some routines run to several listing sheets        each and you may wonder how it is possible to keep track of a listing that      could consist of many routines and a very large number of loose sheets.                                                                                         The answer is simple. For a start the instruction addresses provide an          obvious sequence, which places every sheet in the right order. You may          recall from the last article that every routine is started by calling it's      very first instruction. Every listing sheet is headed by a Calling address      (usually a "JSR") and therefore there is no problem finding the start of any    particular routine. The last instruction in any routine is always clearly       labelled as the finish (ie. "RTS" and "Exit").                                                                                                                  In addition to the Calling address, each listing is headed by the software      title, the routine label and the date that particular software item was         written. Those few simple items ensure that there is no possibility of a        mix-up or missing listing sheet going un-noticed.                                                                                                               Machine code/Assembly programming is considered to be extremely difficult,      by most programmers and most seem to do things the hard way, irrespective of    computer language used. However, the simple techniques outlined above, have     made it a lot easier for me. Look at the listings that I have used in this      series and you will find that they are largely written as a "description" in    plain English. So essentially, you could say that the programming language      I use, is the language that I speak and you can't get simpler than that !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            


		Machine Code for the Oric Atmos (Part 40)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We have looked at essentials for machine code programming      and a small selection of useful 6502 Instructions appeared in Part 22 of the    series. The last couple of issues have been looking at programming technique.   Let's see some of that technique put into use.                                                                                                                  

We have letters                                                                 --------------- Nice to know that there is somebody out there reading this      stuff. One of the recent queries concerned the use of Zero Page and just how    much of it is available, when Basic is not being used. You may have seen the    reply, which was published in OUM issue 84 (Aug 94). Since writing that, I      have now had the opportunity to have a longer look at Zero Page use.                                                                                            Initially, Zero Page appeared to be completely free, when Basic is not in       use. Of course the only system that I can check on, is my own Atmos (with       Sedoric). However, after some experiments, including a complete overwrite of    Page Zero, it became obvious that six locations were still in use and active,   outside of "Basic" operation. The locations to avoid are #000C to #000F,        plus #0012 and #0013. These handle screen operations and do not appear          to be affected by anything written into them, because anything written in,      is itself promptly overwritten by Oric's Operating System.                                                                                                      So it appears that the whole of Zero Page is free for use, with the             exception of just six locations. This is definitely "one up" for the Oric,      because Zero Page is quite a useful facility and has it's own instruction       set. The instructions are shorter and offer some useful extras, which are       operated in the "Page Zero" area (0000 to 00FF). Many other 6502 computer       users find that most of this area has been earmarked for the Operating          System, leaving very little for the user, so the Oric has an advantage.                                                                                         Of course "Basic" is different, in that it does make a lot of use of Zero       Page and furthermore it expects to find Zero Page in the same condition, on     return, as it was before you called your machine code program. So if you are    going to make use of the Zero Page facilities, it is a good idea to preserve    the whole of Zero Page, while your machine code program is running. This        would make your own use of Zero Page, "transparent" to Basic operation.                                                                                         Now, we have looked at "transparent" operations before in Part 27 of the        series. That article concentrated on making use of the Stack to preserve the    contents of one or more registers. The Stack is quite adequate for that job     as you are only storing a few bytes each time. The Stack's maximum capacity     is only 100 hex/256 decimal bytes and some of it is used, automatically by      instructions such as "JSR". So it is obviously impractical to use the Stack     for preserving Zero Page, as there would be no room for anything else !         However there are other ways to make the operation "transparent".                                                                                               One way to do this is to write a short routine which will swap the area of      RAM that you wish to use, with another unused area of RAM, while your own       software is running. This would allow you to set up your own "Zero Page" in     the unused area and then swap that area with the genuine Zero Page, at the      start of your software. At the end of your program, simply repeat the swap,     to return the original Zero Page contents, ready for "Basic" use on exit.       This would make your software operation "transparent" with respect to the       Zero Page and it is what I have done, when I needed to use it.                                                                                                  Have a look at one of the routines that can be used for this purpose.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

Oric                       Utility Routines                        29 Sep 94    ----                       ----------------                        ---------    [JSR#1010]-----------------[Swap Page00 and Page30]--------------------[ / ]

         ---start---      ---Preserve Accumulator and Register X---             1010:48       : PHA        : Put Accumulator on the Stack.                      1011:8A       : TXA        : Copy Register X into the Accumulator and           1012:48       : PHA        :  and put that on to the Stack too.

                          ---Set Register X for Index/Fetch & Copy use---       1013:A2 00    : LDX# 00    : Set Register X to zero.

                          ---Fetch 2 Bytes and Swap them over---                1015:BD 00 00 : LDA X 0000 : Index/fetch byte from Page00 address and           1018:48       : PHA        :  preserve it on the Stack.                         1019:BD 00 30 : LDA X 3000 : Index/fetch byte from Page30 address and           101C:9D 00 00 : STA X 0000 :  index/copy it into Page00 address.                101F:68       : PLA        : Retrieve Page00 byte from Stack and                1020:9D 00 30 : STA X 3000 :  index/copy it into Page30 address.

                          ---Update Index and check progress---                 1023:E8       : INX        : Increment (add 01 to) Register X contents.         1024:E0 00    : CPX# 00    :  Test - is Register X (Index) at zero again ?      1026:D0 ED    : BNE"1015"  :    No - so back to "swap" another 2 bytes.
                                 Yes - so "swap" operation is now complete....

                          ---Finish---                                             1028:68       : PLA        : Retrieve original Reg X contents from Stack        1029:AA       : TAX        :  and copy them from Accu, back into Register X.    102A:68       : PLA        : Retrieve original Accumulator contents and         102B:60       : RTS        :  then Exit.
          ---end---

As you can see, the major part of the above listing is written in plain         English and if I was French, or any other nationality, the listing would be     French, or other as appropiate. So much for "high level" languages !
                                                                                            The only part of the listing that goes into the computer, is put into the       first two columms, or the third columm, if you are using an Assembler. In       theory, the description columm on the right, should be sufficent to stand by    itself. However, this will vary according to experience gained. I don't have    to write nearly as much detail as when I first started. Understanding what      the Assembly "labels" mean is a help, because they are an abrieviation of       the instruction operation and they can be read as part of the description.                                                                                      For example, the instructions 1028 and 1029 are PLA which is "PulL the          Accumulator off the Stack" and TAX which is short for "Transfer copy of         Accumulator into Register X". Now that I have gained more experience my own     listings tend to be abrieviated to something more cryptic and "PLA TAX          Retrieve Reg X", is quite sufficent to remind me, of what that was all about.                                                                                   

So what's it for, Mister ?                                                      -------------------------- In simple terms, the routine swaps the entire        contents of Page00 (Zero Page) with the entire contents of Page30 (all the      locations from 3000 to 30FF). So, if you wanted to make a lot of use of         Zero Page, you could set it up first in Page30 and then call the above          routine. When you have finished, you simply call the routine again to           restore the original Zero Page contents.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

How does it work ?                                                              ------------------ The routine starts by preserving the contents of the         Accumulator and Register X. You don't have to do this, but it is useful to      know that if you are already making use of Register X in particular, it's       contents won't be corrupted by calling this routine.                                                                                                            The routine makes use of Register X as an index for fetching and copying the    items of data from one area of memory to the other. The index allows you to     use an instruction with a single address to fetch or copy the contents of up    to 100 hex locations, including that base address. It does that by adding       the contents of Register X to the instruction address. We have looked at        "indexed" instructions in Part 21 of the series, but it will do no harm to      have a brief recap, here.                                                                                                                                       There are four "indexed" instructions in this routine, two instructions set     to a base address of 0000 (instructs 1015 and 101C), for Page00 and two set     to a base address of 3000 (instructs 1019 and 1020), for Page30. As I said,     the address actually used by these instructions will depend on the value        that is currently held in Register X.                                                                                                                           If for example, Register X contained the value 17, instruction 1015 would       fetch from the address 0017 and instruction 1019 would fetch from address       3017 and the same applies to the other two "indexed" instructions.                                                                                              In fact, the routine starts off by setting Register X to zero, so that the      "indexed" instructions all start from their base addresses. The actual          "swap" is achieved by instructions 1015 to 1020. These fetch the first byte     from Page00 and hold it on the Stack, while a second byte is fetched from       the same location in Page30 and copied into Page00 to replace the first byte.   The first byte is then retrieved from the Stack and copied into Page30 to       replace the second byte taken from there. As Register X contains 00, the        effect of the operation is to swap the first two bytes of each Page.                                                                                            It follows that, if you add 01 to the contents of Register X and repeat the     "swap" operation (instructs 1015 to 1020), it will swap over the next two       bytes in Page00 and Page30. Essentially, that is how the routine operates,      swapping each byte in Page00 with its equivalent in Page30 working through      the Pages from location 00 up to location FF.                                                                                                                   Register X can only hold a single byte, or in other words a value in the        range 00 to FF. Instruction 1023 adds 01 ("INX") to the Register X contents     and will continue to do so on each pass, until Register X contents reach FF.    At that point, adding 01 to Register X simply returns it's contents to start    again at 00.                                                                                                                                                    This means that we should test Register X contents after each "swap" for the    point at which they reach 00 again, because at that point the operation to      swap the two Pages is complete and we don't want to continue in an endless      loop. When Register X reaches 00, the test instruction ("CPX") at 1024,         tests and sets the Zero Flag which disables the Branch ("BNE") instruction      at 1026, with the result that the operation ceases to loop back to the          "swap" operation at 1015, but goes straight on to the finish instead.                                                                                           The instructions 1028 to 102A simply retrieve the items originally              preserved by the initial instructions 1010 to 1012 and then instruction 102B    provides the usual exit, via "RTS" instruction.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

Testing, Testing !                                                              ------------------ A few more points about this routine. If you are thinking    of trying it out by CALLing it from Basic, forget it ! The first thing that     Basic will look for on exit will be Zero Page, which of course will have        gone missing because you have just parked it, up in Page30. The Oric won't      like that and you will have to push the Reset Button to get it's attention      back again.                                                                                                                                                     It's always a good idea to test any routines before making serious use of       them, even if you are confident that they are OK. That makes it easy to pick    up any errors, which might have been typed in. However, if we can't call        this routine from Basic, how do we check it out ?                                                                                                               A simple answer to that, is something we have used before. There is no          specific reason why the swap has to be with Page30, or even with Page00 for     that matter. If you wanted to use any other addresses you could substitute      them in instructions 1015 and 101C for the first Page address and 1019 and      1020 for the second Page address.                                                                                                                               If you look at the addresses for the TEXT screen display in the manual, you     will find that they run from #BBA8 to #BFDF, which means there are a little     over four Pages visible on the screen in that mode. Now if you change the       addresses in the "swap" instructions and use two of those screen Pages, it      should be easy to check if the routine is operating correctly. Put the          address BBA8 into instructs 1015 and 101C, then put the address BCC0 into       instructions 1019 and 1020. Don't forget to enter the addresses in reverse      order as usual (ie. 1015:BD A8 BB : LDA X BBA8). Make sure you have a fair      amount of junk on the display screen, before you make your test call to the     routine, a blank screen will tell you nothing. Also make sure that the          cursor is not at the bottom of the display, whenever you call the routine,      otherwise the screen display will scroll and confuse the display effect.                                                                                        Using the screen addresses, means that you can now call the routine from        Basic to test it out. If the routine is operating correctly, you should see     the top half dozen lines swap places with the next half dozen lines down.       Immediately after that, make a second call to the routine and you should see    the display screen return to normal. If that happens you can be assured that    the routine is operating correctly and therefore will do the same when set      to Page00 and Page30 addresses.                                                                                                                                 A couple more points. I must confess that instruction 1024 is not really        necessary and could be omitted. When Register X is finally incremented from     FF to 00, the result also sets the Zero Flag and would disable the Branch       (instruct 1026) anyway. The reason for the "CPX #00" in instruction 1024 is     purely cosmetic and is intended to make the listing easier to read, which I     feel is an essential part of programming. The slight overhead in speed and      memory incurred, is not worth worrying about in such a small routine, that      is only called a couple of times anyway.                                                                                                                        The routine can be entered into the Oric in the usual way, as hex code from     the address and code columms, or by using an assembler. It was intended as a    demonstration of programming technique, but bear in mind, that while the        routine works, it is not the only way to achieve the result. It could be        improved and made more useful. For start the "swap" is limited to maximum of    100 hex bytes and the addressing is not that flexible. We can have another      look at that and also at those Zero Page instructions that started the whole    thing off................................................See you next month.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          


		Machine Code for the Oric Atmos (Part 41)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We have been looking at programming technique. Last time,      we looked at a short memory "swap" routine, which was initially aimed at        preserving an area of memory, such as Zero Page. However, you can really        forget about the "Zero Page" aspect. Essentially, the routine provided a        simple way to swap the contents of two areas in memory. This can be used for    a lot of things, depending on your imagination. A simple form of animation,     done by swapping sprites in the HIRES screen, is one possibility.                                                                                               Having shown how such a routine is written, the last article ended by           pointing out some the routines failings. Even if you have produced something    that works, it still pays to be critical. There is usually more than one way    to achieve the result that you require. The routine worked but it was           limited to areas of no more than 100 bytes. The new pair of routines shown      here are better. They can be reset to achieve exactly the same results, as      the routine in the last issue by simply changing the memory area addresses.     However, now there is no longer a restriction on the size of memory area.       The addresses (variables, if you wish) are located in a Parameter Block at      the start of a Page (Page10 in this case), which makes them easier to locate    and reset for any area. Use CALL#1020 or JSR 1020 to call up the operation.     The addresses set up here, swap the two halves of the Text screen. Why not      try re-setting the addresses to operate on the HIRES display ?                  The main routine is relocatable. This means that if you extend the Parameter    Block to include the small subroutine (JSR 1010), you will find that while      the Parameter Block has a fixed location, the larger main routine can be        moved and called from anywhere you like in the RAM. More next month........                                                                                     Oric                       Utility Routines                        30 Sep 94    ----                       ----------------                        ---------    [--------------------------[Parameter Block 1000]----------------------[1/2]
                                                                                    1000:FF       : "FF"       : Page Marker only (optional)                        1001:         :            :

                          ---1st RAM Area---                                    1002:A8       : "BBA8"     : Start Address Lo byte                              1003:BB       :            : Start Address Hi byte                              1004:62       : "BD62"     : End Address Lo byte                                1005:BD       :            : End Address Hi byte

                          ---2nd RAM Area---                                    1006:63       : "BD63"     : Start Address Lo byte                              1007:BD       :            : Start Address Hi byte
                                                                                                              [JSR 1010]-----------------[Swap Contents of Two Addresses]--(sub)---------]

                          ---Fetch 2 Bytes and Swap them over---                1010:AD 00 00 : LDA 0000   : Fetch byte from 1st Area address and               1013:48       : PHA        :  preserve it on the Stack.                         1014:AD 00 00 : LDA 0000   : Fetch byte from 2nd Area and                       1017:8D 00 00 : STA 0000   :    copy it into 1st Area address.                  101A:68       : PLA        : Retrieve 1st Area byte from Stack and              101B:8D 00 00 : STA 0000   :    copy it into 2nd Area address.
                          ---Finish---                                          101E:60       : RTS        : Return to main routine.
          ---end---

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Oric                       Utility Routines                        30 Sep 94    ----                       ----------------                        ---------    [CALL#1020]----------------[Swap Contents of Two RAM Areas]------------[2/2]

         ---start---      ---Set 1st Area Addrs in Instructs 1010 & 1017---     1020:AD 02 10 : LDA 1002   : Fetch Addr Lo byte from Param 1002 and             1023:8D 11 10 : STA 1011   :    put it into location 1011                       1026:8D 18 10 : STA 1018   :  and also into location 1018.                      1029:AD 03 10 : LDA 1003   : Fetch Addr Hi byte from Param 1003 and             102C:8D 12 10 : STA 1012   :    put it into location 1012                       102F:8D 19 10 : STA 1019   :  and also into location 1019.

                          ---Set 2nd Area Addrs in Instructs 1014 & 101B---     1032:AD 06 10 : LDA 1006   : Fetch Addr Lo byte from Param 1006 and             1035:8D 15 10 : STA 1015   :    put it into location 1015                       1038:8D 1C 10 : STA 101C   :  and also into location 101C.                      103B:AD 07 10 : LDA 1007   : Fetch Addr Hi byte from Param 1007 and             103E:8D 16 10 : STA 1016   :    put it into location 1016                       1041:8D 1D 10 : STA 101D   :  and also into location 101D.

                          ---Test Address in "Swap" Instruct 1010---            1044:AD 11 10 : LDA 1011   : Fetch Addr Lo byte from instruct 1010              1047:CD 04 10   CMP 1004   :  Test - is it the same as End Lo of 1st Area ?     104A:D0 08    : BNE"1054"  :    No - so skip next 3 instructions.
                                 Yes - so......                                   104C:AD 12 10 : LDA 1012   : fetch Addr Hi byte from instruct 1010              104F:CD 05 10   CMP 1005   :  Test - is it the same as End Hi of 1st Area ?     1052:F0 2E    : BEQ"1082"  :   Yes - so swap is completed, skip to finish
                                No - so .....
                          ---Swap Two Bytes---                                  1054:20 10 10 : JSR 1010   : Swap 1st Area byte with byte from 2nd Area.

                          ---Update "Swap" Addrs in instructs 1010 & 1017---    1057:18       : CLC        : Clear CARRY Flag.                                  1058:AD 11 10 : LDA 1011   : Fetch Addr Lo Byte from "swap" instruct 1010       105B:69 01    : ADC# 01    :  and add 01 to it and then                         105D:90 06    : BCC"1065"  :   skip two instructs if CARRY is still clear.      105F:EE 12 10 : INC 1012   : If CARRY not clear, add 01 to Addr Hi Bytes        1062:EE 19 10 : INC 1019   :  of both instructs 1010 and 1017.                  1065:8D 11 10 : STA 1011   : Copy updated Addr Lo Byte back to instruct 1010    1068:8D 18 10 : STA 1018   :  and also instruct 1017.

                          ---Update "Swap" Addrs in instructs 1014 & 101B---    106B:18       : CLC        : Clear CARRY Flag.                                  106C:AD 15 10 : LDA 1015   : Fetch Addr Lo Byte from "swap" instruct 1014       106F:69 01    : ADC# 01    :  and add 01 to it and then                         1071:90 06    : BCC"1079"  :   skip two instructs if CARRY is still clear.      1073:EE 16 10 : INC 1016   : If CARRY not clear, add 01 to Addr Hi Bytes        1076:EE 1D 10 : INC 101D   :  of both instructs 1014 and 101B.                  1079:8D 15 10 : STA 1015   : Copy updated Addr Lo Byte back to instruct 1014    107C:8D 1C 10 : STA 101C   :  and also instruct 101B.
                          ---Return to do another "Swap"---                     107F:18       : CLC        : Clear CARRY Flag and use it                        1080:90 C2    : BCC"1044"  :  to make a Branch back to "Test Addr" again.

                          ---Finish---                                          1082:60       : RTS        : Exit
          ---end---                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          