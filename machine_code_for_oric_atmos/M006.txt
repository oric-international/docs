         Machine Code for the Oric Atmos (Part 28)   Peter N. Bragg                       	   -------------------------------                                           

History Lesson !                                                                ---------------- Have you read "Oric - The Story So Far" ? It is a very         interesting book. Talking to the author, Jon Haworth at the Oric Meeting        
the other day, we were discussing the fact that Oric's manafacturers were       
not the only ones in trouble during that 1984-85 period. Sinclair, Acorn and    Commodore, were just a few of the names caught out by a collapsing market.      
So what happened ?                                                                                                                                              If you were interested in microcomputers at the time, in the early 1980's,      
it was all very exciting. New machines being announced every month by the       magazines. There were regular TV programs like the BBC series. Media hype       created an impression that programming would be a real doddle, dead easy.       Anyone old enough to hold a pencil could create a super video game in an        evening, a wordprocessor and spreadsheet could be produced in little more       
than a day or so.                                                                                                                                               However, good computer hardware was a bit thin on the ground for the first      
two or three years and it's absence helped to sustain the myth that             programming would be quick and easy, when that "dream machine" arrived.                                                                                         About 1983-84, the floodgates opened and good machines with colour poured       
into the shops. The general public soon found that, while it was easy enough    
to PRINT "HELLO" and play a few notes, writing real software was a different    story. The "dream machine" became a dissapointment for many. The home           computer boom collapsed and with it went companies like Oric International.                                                                                     Computer clubs shrunk and many disappeared. It was all replaced by the grey     
world of the PC clone and ready cooked software, where the user is expected     
to fit in with the machine's operating system and not the other way around.                                                                                     We can gain from experience and hindsight. The "computer boom" collapsed        because so many people had their enthusiasm and high hopes dashed by            reallity. Writing software appeared to be more difficult than they thought.                                                                                     Is it really as bad as that ? When it comes to writing software, you do not     
have to carry an entire Instruction Set in your head. A simple basic            knowledge of how instructions work and a paper list of them is all the          programming language that you need. So what is the real problem ?                                                                                               While this is essentially a series on machine code (Assembly) language          programming, it was also intended to provide some insight into how to write     programs, so it is worth looking at why people found it so difficult.                                                                                           The reason is that there are other things that are necessary for successful     program writing, that have nothing to do with the computer or language.         In particular there are two qualities that I think are essential.                                                                                               The first is imagination. Specifically, the ability to visualise the            software that you intend to write and how you are going to use it. Dont         worry if you find this aspect difficult at first. All designers start off by    copying and modifying other peoples ideas. Have a look around and see what      is that you really like and use that as a starting inspiration. Try to put      brief details and sketches on paper if your memory is as dodgy as mine.                                                                                         The second and by far the most important quality needed for programming is      time. Dont be in too much of a hurry to get big results.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Like many other constructive hobbies or pastimes, it needs a little time and    patience to get results, when writing computer software. This has always        been the main stumbling block for most people when starting out in anything     new. They buy all the gear and expect overnight results and then give up if     they dont get them straight away.                                                                                                                               So just how long does it take, to write a piece of software ? That is a         question that I find difficult to answer, particularly as I have never          written anything that I would consider as completely finished.                                                                                                  A simple utility could take a few days or so. The wordprocessor, produced a     few years back, took quite a lot of spare time over a period of a couple of     months to get to the point of being, crude but working. However, it was well    worth the effort and it is still in constant use and is frequently updated.                                                                                     When programming, I set myself a target, something that is not too ambitous.    It is more interesting when you can see some results, as you go along, even     if they are small, because this helps to make it easier, to be patient and      take the time to build up a large piece of software.                                                                                                            It is also a good idea to take a break from programming at times. "Time and     patience" are important ingredients, but dont overdo it. Be prepared to         give it a rest at times. Quite often ideas and solutions to problems occur      when you take a break and do something different.                                                                                                               I do have other interests and dont spend all my time writing computer           software. As I am not a professional programmer, I can write any software I     want in any way that I like. The only limiting factor is the computer           hardware and that leaves plenty of scope. As a hobby interest, programming      can be fun, like constructing something, or solving a puzzle. The end result,   may well be something of value to you, which will not wear out and will last    for as long as you have the computer. So now let's continue with .........                                                                                      

The Story so far                                                                ---------------- We have looked at the basic requirements for writing           machine code programs on the Oric and have now built up a modest collection     of useful instructions in form of a small 6502 Instruction Subset which         appeared in Part 22 of the series. I have also tried to illustrate some of      the programming techniques that I have found useful. Last time, we looked at    transparent routines, what they are and why they are useful.                                                                                                    At this stage, it may be a good idea to have a look to see how we can make      use of some of these techniques. Earlier in the series we looked at the         two most important of the Operating System calls. These were "GOTORKB", used    for reading input from the keyboard and "VDU" which is used to display items    on the screen. You may recall that the keyboard call required a short           routine in order to confirm that a key had actually been pressed during the     call. There is also a good reason for using a short utility routine to          intercept the display call "VDU".                                                                                                                               Like many computer users, the first thing that I do when switching on the       computer, is to boot up a small selection of useful utilities and routines,     so that they are always available, for writing software. The Oric utilities     always include several routines, which handle the fiddly bits of the            "GTORKB" and "VDU" calls. The routines are not an essential item and only       consist of a few instructions apiece. However, they are quite useful and        have the advantage that each can be called up by a single instruction,          instead of having to be written in full, each and every time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   The listing below, should give you some idea of the type of routines, that      I use. They are just for illustration, you don't have to type them in.
                                                                                          Oric                       Utility Routines                       31 Jul 93.    ----                       ----------------                       ----------    [ JSR 9010 ]---------------[ Test Keyboard Briefly ]-------------------[ / ]

         ---start---      ---Read Keyboard---                                   9010:20 78 EB : JSR EB78   : Call "GTORKB" routine, to read Keyboard.

                          ---Test - Key pressed ?---                            9013:30 02    : BMI"9017"  :  Yes - so skip next instruction only.(Flag N=1)
                              No - so                                          9015:A9 FF    : "No Key"   :     set the Accumulator to show "No Key Press".

                          ---Finish---                                          9017:8D 01 90 : STA 9001   : Save result of call in Param 9001.                 901A:60       : RTS        : Exit.
          ---end---

[ JSR 901E ]---------------[ Get Key Press ]-------------------------------+
     
         ---start---      ---Read Keyboard---                                   901E:20 78 EB : JSR EB78   : Call "GTORKB" routine, to read Keyboard.

                         ---Test - Key pressed ?---                            9021:10 FB    : BPL"901E"  :   No - so back to read Keyboard. (Flag N=0)
                               Yes - key was pressed so finish.......

                          ---Finish---                                          9023:8D 01 90 : STA 9001   : Save result of call in Param 9001.                 9026:60       : RTS        : Exit.
          ---end---

[ JSR 902A ]---------------[ Display Item ]--------------------------------+

         ---start---       : Enter with item for display in Accumulator.
                                                                                        902A:8D 02 90 : STA 9002   : Preserve Accumulator contents in Param 9002,       902D:8A       : TXA        :  then copy Register X to Accumulator and           902E:48       : PHA        :   use it to preserve Reg X on the Stack.
 
                         ---Fetch and Display item---                          902F:AE 02 90 : LDX 9002   : Fetch display item from Param 9002 into Reg X      9032:20 7C F7 : JSR F77C   :  and call "VDU" routine to display it.

                          ---Finish---                                          9035:68       : PLA        : Retrieve Reg X item from Stack into Accumulator    9036:AA       : TAX        :  then copy them back into Register X               9037:AD 02 90 : LDA 9002   :  and retrieve Accumulator item from Param 9002.    903A:60       : RTS        : Exit.
         ---end--- 
                                                                                                                                            Notice that there is a small gap between each of the three routines. Not        essential, but quite a useful habit to get into, particularly when writing      longer routines. It makes it easy to insert an extra instruction, if you        wish to make modifications to your software at a later date.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Because they are quite simple and small, the routines can be put anywhere       that you wish. The example's location in the 9001 - 903A area, is about as      far away from everything as you can get. I normally use a lower address,        which is a compromise decided by the common RAM area available on the three     quite different machines, that I have used. An alternative approach is to       put one set of the three routines in each piece of software that you write      and use them as a vector to the Operating System calls.                                                                                                         There are only five instructions in the routines, that are sensitive to         location. They are the LDA, LDX and three STA instructions. The addresses       for these depend on where you put your tiny Parameter Block, which only         requires two locations. The addresses 9001 and 9002 (not listed) are used       for the Parameter Block in this example.                                                                                                                        

Keyboard Reading Routines                                                       ------------------------- Doing things in a logical order, we shall look at     this first. As you will know from using Basic, there are two ways to read       the keyboard. One is the quick test for a keypress, which briefly interrupts    program operation and then allows it to continue, irrespective of whether a     key is pressed or not. This type of keyboard read is useful for games.          The second type of keyboard read, will stop program operation completely and    wait for a key to be pressed.                                                                                                                                   The routines for these two are quite short. Both routines end up with a key     press (code) input in the Accumulator, but notice that the routine also         saves a copy of that input in a storage location (Params 9001). This is         useful if you are not going to use the keypress straight away, because the      copy stays there until the next keyboard read. It's useful for debugging too.                                                                                   In the case of the first routine, a key may not be pressed in the time that     the keyboard is read and if so, it is a good idea to register that fact.        This can be done, as shown, by loading the Accumulator with a code that         indicates "no key pressed" and saving that instead. Obviously, it would be      best to use a code that cannot be obtained from the keyboard, for that job.                                                                                     A keypress will make the Negative (N) Flag in the Status Register change        from N=0 to N=1. That affects the operation of the BMI and BPL Branches.        BMI will only operate when N=1, but the opposite affects BPL. These two         Branches are used in the two routines to detect when a key is pressed.                                                                                          

Display Item Routine                                                            -------------------- When we looked at the display call "VDU", I noted the      fact that the call uses Register X, to hold the item for display. Tangerine     may well have had good reasons to use Register X in this way, but it seems,     from personal experience, that the Accumulator would be a much better choice    for the job. The Accumulator is the most versatile of the two and more          suited to handling single bytes of data, as used by the display call.           Register X on the other hand, is more suited for the job of transferring        large quantities of data, to and from the data memory.                                                                                                          The routine for "VDU" shown here, changes the register used for the display     call, from Register X to the Accumulator and I find that it is a lot more       useful than the direct "VDU" call. The main thing about the routine, is that    it is transparent, so the registers (Accumulator and Register X) have           exactly the same contents coming out of the routine as they had going in.       This means that you can use Register X to fetch a series of data items for      display, without it losing count of them, when using this routine.              That's it for this time...............Get tapping for those winter evenings !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         


		Machine Code for the Oric Atmos (Part 29)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming. A small selection of useful 6502 Instructions appeared in          Part 22 of the series. I have also tried to illustrate a few programming        techniques that I have found useful. Last time, we looked briefly at a          couple of simple utility routines. Now for something a little different.                                                                                        

Two Bits Worth                                                                  -------------- Programs are no longer written in binary code, thank goodness.   So far in this series, I have deliberately kept a low profile on the subject    of binary numbers, because many of us find all those "1's" and "0's" a bit      intimidating and I did not think that it was a good way to start out.           As far as I know, Binary Code is no longer in use for programming. However,     you will soon notice if you do a fair bit of program writing, even in Basic,    that binary numbers do crop up occasionally and can be very useful. Before      we go on to look at specific instructions, it may help to have a brief look     at the binary system and why it was used in the first place.                                                                                                    

Switch ON !                                                                     ----------- So why do computers use such an awkward system, like binary ?       The reason, is that it simplifies computer design and manafacture. Computers    need to use and store large amounts of data, in the form of numbers, which      are then used to produce the action, words and pictures that we require.        The easiest way to store the numbers which make up all the raw data, is to      use an ordinary common ON/OFF switch.                                                                                                                           We are all familiar with the common household light switch. The idea that       an array of simple electrical switches could be used as a memory chip, may      seem a bit far fetched, but in fact there is a fair chance that you have        actually programmed one, using binary code in the process !                                                                                                     How come ? Well, if you have a printer, it's a fair bet that you have had to    set the "dip switches", when you used it for the first time.                                                                                                    Take a close look at one of these sets of "dip switches" and you will find      that it is a row of small, but very ordinary electrical ON/OFF switches in a    single block, mounted on a circuit board just like any RAM chip. In fact it     is a memory chip, a sort of finger operated ROM.                                                                                                                It is also possible to go even smaller and produce microscopic switches         using transistor technology, to put many thousands on a tiny silicon chip.      These too, can be flipped ON and OFF. They are too small to be operated by      hand, so the job is done by an electrical signal, produced automatically for    us by the computer electronics, when required. Each and every switch on a       silicon memory chip, can be separately set to either ON or OFF by the           computer user. This means that a computer memory chip, is just a vast array     of tiny transistorised ON/OFF switches. Such a chip has the advantage of        being extremely cheap to produce. That helps to make it easier and cheaper      to manafacture microcomputers, capable of handling large amounts of data.       However it does raise the question, how do you store large numbers on an        array of simple ON/OFF switches. This brings us to binary numbers.                                                                                              Each switch can store one of two digits. When it is OFF it is considered to     be at "0" and when it is ON, it is considered to be set to "1". So each can     in effect, store one binary number and for this reason each of the tiny         transistor switches is referred to as one "Bit".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Programming individual bits, using binary digits, is a quick way to go          bananas. A better way is to group the switches on the memory chip into sets     of four. Each set of four will give sixteen different switch combinations,      from all four switched off, to all four switched on. This covers the numbers    0 to 15 inclusive, but as it is much easier to use a single digit for each      number we use the letters "A" to "F" instead of numbers 10 to 15. This is       the basis of the Hexdecimal numbering system, that we have been using for       our programs.                                                                                                                                                   So four bits in a computer memory chip are in effect, four switches and can     store one hex digit. Alternatively, you can look at it the other way round      and say that one hex digit can be used to program those four bits to any        combination of four binary digits (0000 to 1111). Hex digits are much easier    to handle than binary digits and hex code listings are much smaller, so         hex code is the main basis of all programming and also most high level          languages such as "C" and Basic etc. The majority of early microcomputers,      such as the Oric, handled data in eight bit lots, written as two hex digits.    We normally refer to this as one byte.                                                                                                                          So there you have it, computer memory is just an enormous binary array of       ON/OFF switches, grouped in sets of four and programmed initially in hex        code, to produce the necessary languages and software.                                                                                                          

Show the Flag                                                                   ------------- OK, so we do not need binary code for programming any more,       but we do need to use the odd binary number, even in Basic. So why is that ?    For the explanation, let's stay with simple ON/OFF switches for a moment.       A switch actually does two things. First of all, it acts as an indicator.       It is best to put in a light bulb, when the power is off. How do you know       that the power is off ? ...... Simple, you just look at the switch toggle !     Once the light bulb is installed, the switch can be used for its second         function, which is to turn the light on and off.                                                                                                                OK, so that is a little elementary, but it does illustrate how the computer     uses binary numbers. Firstly, individual memory bits can also be used as        indicators by setting them to "1" or clearing them to "0" in just the same      way as we use the position of the light switch toggle to indicate whether       the power is ON or OFF.                                                                                                                                         In the computer, bits used as indicators are usually referred to as "Flags".    We met a set of these, way back when we looked at the Status Register. That     holds eight bits (one byte), seven of which are used as "Flags". These          "Flags" indicate the result of many operations and can then be used for         various purposes such as controlling the operation of Branch instructions.      Set a bit to "1" to make one Branch instruction active. Clear the bit to "0"    to disable that instruction and make another active instead.                                                                                                    Secondly, individual memory bits can be real electrical switches. A lot of      the hardware is actually mapped into the computer memory. These have memory     locations that can be written to. They are genuine arrays of ON/OFF switches,   that control items such as the sound chip, disk drive and the screen display.                                                                                   Of course, many of the above items are automatically controlled by the          built-in software, in particular the ROM that holds the Operating System.       However, there is plenty of scope for anybody who feels like experimenting,     particularly with any new hardware item.                                                                                                                        Next time, we can have a look at some easy ways to make use of binary values.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         


		Machine Code for the Oric Atmos (Part 30)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming. A small selection of useful 6502 Instructions appeared in          Part 22 of the series. Also illustrated were a few programming techniques       that I have found useful. Last time, we started to look at binary and how       it is used in computers. Data memory "bits" were compared with the common       household electric light switch. Switch OFF = "0" and switch ON = "1".          This meant that as well as storing data, individual memory bits could also      be used as indicators (Flags), or as a real electrical ON/OFF switch for the    computer hardware items. If in doubt, take a look at Part 29 of the series.                                                                                     

So what use is it ?                                                             ------------------- Binary is useful for those of us who have made hardware     additions to our Orics in the form of modems or expansion boards etc.           Setting up such hardware, usually requires a little binary to deal with the     necessary flags and circuit switches.                                                                                                                           Binary is also used for the display. This is not so obvious because a fair      number of text and graphics commands allow us to do a lot using Basic only.     However, there are always those who want to go that much further.               Observe our friends from CEO, who are transferring graphics from other          machines to the Oric. Knowledge of the binary makeup of the HIRES display is    a must for writing this sort of software.                                                                                                                       

Conversion Table                                        decimal hex  binary     ---------------- The first thing that we need is an        0     0    0000      easy method of converting hex code into binary and the     1     1    0001      table on the right is all you need for that. In fact,      2     2    0010      you don't even need the decimal part, as decimal is        3     3    0011      not very practical for the purpose. The Atmos Manual       4     4    0100      lists 00 to FF, but if you look at it's hex/binary         5     5    0101      conversion you will find that it is sixteen repeats of     6     6    0110      this table. Conversions are simple. For example -          7     7    0111
                                                           8     8    1000        To convert 93 hex to binary, just look up the binary       9     9    1001         for 9 and then look up the binary for 3                   10     A    1010             and put them together like so -                           11     B    1011
                                                          12     C    1100        9 hex is 1001 in binary and 3 hex is 0011 in binary,      13     D    1101          so 93 hex is 1001 0011 in binary.                         14     E    1110
                                                          15     F    1111 
                                                                                     The table converts either way, hex to binary or binary to hex. The largest      value you are likely to use on the Oric is a single byte, which is two hex      digits or eight binary digits. Hex code and binary are used by most computer    systems, so it is worth mentioning a small point. If you ever have to deal      with large binary values, you will find it much easier if you split the         value up into groups of four digits, starting from the right hand side of       the value. For example - 1010101110111010 in binary, looks a bit horrendous !   However, it can also be written as 1010 1011 1011 1010 which makes it easier    to handle and convert into hex. This particular value converts into a well-     known ancient Scandinavian four byte group !! However, I should stress that     you are only likely to need single bytes on the Oric.                                                                                                           For an example of the effect of binary code operation, you don't have to        look any further than the screen colours to see binary code at work.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

A Splash of Colour                                                              ------------------ The Oric uses eight colours numbered in a sequence, from     "0" for black, to "7" for white and you will find the same sequence in use,     whether you are using Basic or machine code. All the colours on the screen      are produced by just three colour guns in the TV (or monitor) tube. There is    a "gun" each, for Red, Green and Blue. If you take the eight colour numbers     "0" to "7" as hex digits and convert them to binary, using the table above      and also list their respective colours, you will see how Oric controls the      colour guns. Bit 0 controls the RED gun, Bit 1 controls GREEN and Bit 2         controls BLUE. So for example, take colour number 5. That is 0101 in binary.    Ignore the left hand digit (that is used for something else). The remaining     101 is Blue ON, Green OFF and Red ON and that should produce Magenta, which     in fact is what we get for colour number 5 (ie. INK5, PAPER5 etc).                                                                                              Hopefully, all this has given you some idea of how binary code operates. The    table above is a useful item to put with your instruction set, preferably on    a "crib card", so that it is handy when you come across a binary instruction.                                                                                   

Binary Bashing                                                                  -------------- Essentially, there are two types of instruction that can         handle binary data. They are Logical Instructions and the Shift Instructions.                                                                                   Logical instructions have the effect of combining a data byte with an           instruction operand byte to produce a single byte result. This type of          instruction makes it easy to change any selected bits in a byte without         affecting other bits in that particular byte, quite useful if you want to       deal with specific pixels on the display screen, or set up a joystick, etc.                                                                                     Shift instructions on the other hand, affect the whole of the data byte.        They treat a data byte as if it were in a tube. In effect they push a new       bit into one end of the data byte which shunts all the other bits along one     space, causing the bit at the other end to "fall out" of the data byte. So      for example, if you shift a data byte one bit to the left, all the bits will    shift, bit 0 will go into bit 1 position, bit 1 will go into bit 2 position     and so on, up to bit 7, which will fall off the end. A shift to the right       goes the other way and it is bit 0 that falls off the end, this time. The       bits that "fall off the end" are not necessarily lost, they can be saved and    pushed back into the data byte at the other end, during the Shift operation.    This allows all the bits in a data byte to be "rotated", if you want that.                                                                                      

Logical Mr Spock ?                                                              ------------------ Let's have a look at Logical instructions first. We have     a choice of three. They are AND, ORA and EOR. All three are used in the same    way, so once you know how to use one of them, you will be able to use all       three. The only difference is the final effect. To keep it simple, I will       concentrate on the effect of the instructions rather than go into the           details of logical operations. Remember we are operating on single data         bytes, which consist of eight bits. For each bit, we have three options.        (a) We can make it "0" or (b) we can make it "1" or (c) we can simply           change it from its current state to the other state, in other words, from       "1" to "0" or from "0" to "1". The AND instruction will provide option (a),     ORA provides option (b) and EOR provides option (c).                                                                                                            This appears to be a long explanation for the benefit of a mere handful of      binary instructions, that are not used that often anyway. However, most of      what has been said in these last two articles applies to all computers, not     just the Oric, so it is useful to know, even if it is a long way from being     a complete description of binary operation. Next time...some instructions !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           


		Machine Code for the Oric Atmos (Part 31)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming. A small selection of useful 6502 Instructions appeared in          Part 22 of the series. A few programming techniques, have also been covered.    The last couple of issues have concentrated on the subject of binary code,      specifically, how and why it is used, in the hope of making it a bit easier     to understand.                                                                                                                                                  

Bits and Pieces                                                                 --------------- Up to now, we have usually operated on data in eight bit        lumps, that are normally referred to as data bytes. However, as I have          pointed out, there are occasions when it is necessary to deal with              individual bits in a data byte. We might, for example, want to use a sprite     from another computer system. If you look at the Oric HIRES display, you        will find that it takes eight bits to control six pixels. That is six bits      for the pixels and two for other facets of the display, such as the colour      control. So if you want to copy a graphic item from another system, you         would have to pick out the actual pixel bits and then copy them into the        Oric's six bit format, without disturbing Oric's two display control bits.                                                                                      Of course, the above is just an example, but it does raise the question, how    do you pick out individual bits in a data byte and copy them into another       data byte, without altering anything else ? The answer lies in "masking".                                                                                       

Masking                                                                         ------- If you are involved in photography, you will be familiar with           masking. Likewise, if you have done any painting or decorating, you will        also have used masking techniques to make a neat job and place the wet paint    precisely where it is needed and nowhere else. The masks for photography and    painting etc are usually made up with sticky tape and pieces of card or         similiar materials and are cut to shape in order to shield protected areas.                                                                                     A similar masking effect can be produced in a computer too. In this case it     is much easier, because as we are operating with data bytes. This means         that any masking operation only needs to deal with eight bits at a time.        The instructions that produce the masking effect are Logical instructions       AND, ORA and EOR. We looked at these briefly last time and you may recall       that they could be used to set any bit in a data byte to either "1" or "0"      or just change it from one state to the other. We will come back to that in     a moment, after we have looked at the masking side of the operation.                                                                                            All three instructions have an Immediate version, which is an instruction       consisting of just two bytes and it is probably easiest to use this type of     instruction to illustrate the masking operation. The first byte in an           Immediate instruction is always the opcode, the second is the operand, which    in the case of the three Logical instructions, is used as the mask. All         three of the Logical instructions operate on data held in the Accumulator.                                                                                      The instruction operand, which strictly speaking is really another data byte,   is used as a mask, to mask out any bits that we do not want affected by the     instruction. The actual data byte to be operated on, is held in the             Accumulator and the instruction puts the result of the masking operation,       back into the Accumulator, overwriting the original data byte in the process.   We need to look at the data byte in the Accumulator and the mask byte in the    operand in terms of eight binary bits, in the first place. We covered the       subject of converting between hex and binary, in the previous issue.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Hex/binary conversion is quite easy, using the small table, shown last time.    Next time, I hope that we can see it again for real, in a practical example.                                                                                    The (operand) mask is made up of individual bits set to "0", each of which      block the effect of the instruction, to that same bit in the Accumulator.       On the other hand, bits set to "1" in the mask, will be transparent and         allow the instruction to operate on that particular bit in the Accumulator.                                                                                     This means that if you set the operand byte so that all eight bits are set      to "0", you will have masked off all of the data item in the Accumulator and    the instruction will have no effect at all. If on the other hand, the mask      is set so that all eight bits are at "1", instruction will affect all eight     bits of the data item in the Accumulator.                                                                                                                       So, if we want to limit the effect of the instruction to a few bits only, we    need to set the mask so that it has a "1" in the bit positions that we want     the instruction to affect and an "0" in the bit positions that we want to       protect from the instruction effects.                                                                                                                           

A Load of Boolean !                                                             ------------------- Let's look at the Logical instructions. Now, a logical      instruction takes each bit from the mask and compares it with the same bit      in the Accumulator. It then replaces that bit in the Accumulator, with a bit    which is the result of that comparison. So bit 0 of the mask is compared        with bit 0 of the Accumulator and then bit 1 with bit 1 and so on up to and     including bit 7. Each bit in the Accumulator is replaced by the result of       the comparison. All three Logical instructions AND, ORA and EOR, work in        the same way in this respect. The difference between them lies in the actual    result of that comparison.                                                                                                                                      The "AND" instruction requires the two bits compared in the mask and the        Accumulator to be both at "1" and it will then set the result in the same       bit of the Accumulator to "1". If either one or both bits are at "0", that      Accumulator bit will be cleared to "0" as a result. In effect, a mask bit       at "0" will have a blocking effect on the instruction operation.                                                                                                The "ORA" instruction is the other way around. It requires the two bits         compared in the mask and the Accumulator to be both at "0" and it will then     result in the same bit of the Accumulator being cleared to "0". If either       one or both bits are at "1", that Accumulator bit will be set to "1" as a       result. In effect, this instruction reverses the mask, so that a mask bit       that is set to "1" will have a blocking effect on the instruction operation.                                                                                    The "EOR" instruction has a different effect. It compares the mask bit and      the Accumulator bit as before. If the mask bit is "0", the Accumulator bit      is left unchanged. However if the mask bit is at "1" the same Accumulator       bit is inverted. That means that it will be set to "1" if it was "0" or         alternatively, it will be cleared to "0" if it was "1".
       Binary      Hex                  The example shown left, shows the       Data   1010 0101 = A5 in Accu before.   result of using "AND". If "ORA" is
                                        used instead the result puts BD in      Mask   0011 1100 = 3C in Operand.       the Accu. "EOR" would put 99 in the
                                        Accu, for the same mask and data.       Result 0010 0100 = 24 in Accu after.    So why is that, I wonder ?? 
                                                                                            In the meantime, I have been "excused boots" over Christmas, so I will leave    you with best wishes for the festive season and a very Happy New Year.......                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          


		Machine Code for the Oric Atmos (Part 32)   Peter N. Bragg                      		-------------------------------                                           

Here we are, back again after the Christmas break. Have you broken all those    New Year resolutions, yet ? Are you like me ? As ever, full of plans and        good intentions, many of which will still be waiting to see the light of day,   when the Christmas tree goes up again. The New Year period is a good time       for exhibitions and the opportunities to get out and see what the rest of       the world does with it's spare time and cash (if there is any available).       The "Computer Fair" and the "Model Engineer" were worth visiting.               Interesting items included computerised tools and flight simulators, but        whatever happened to the CD ROMs we have heard so much about. Plenty of CD      players and hardware, but still not much choice in the way of CD disk           material after all these years. Ah well, on with the motley !                                                                                                   

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming. A small selection of useful 6502 Instructions appeared in          Part 22 of the series. A few programming techniques, have also been covered.    The last couple of issues have concentrated on the subject of binary code       and we looked at three instructions that can be used to mask out specific       items of data. I left you with a brief illustration of a masking instruction.                                                                                   The instruction used was "AND" and that example is repeated below, together     with the same setup using "ORA" and "EOR" instructions. Later on, we will       see how this sort of instruction can be made to do something useful. In the     meantime, take a look at the examples below and note how each instruction       has a different effect, when using the same data and mask.

       Binary      Hex                  This example shows the effect of        Data   1010 0101 = A5 in Accu before.   using "AND". The four bits at "0" in
                                        the mask, block the data bits above     Mask   0011 1100 = 3C in Operand.       them, thereby putting "0" into those
                                        bits in the result.                     Result 0010 0100 = 24 in Accu after.

       Binary      Hex                  This example shows the effect of        Data   1010 0101 = A5 in Accu before.   using "ORA" and in effect reverses
                                        the mask. The four bits at "1" block    Mask   0011 1100 = 3C in Operand.       the data bits above them, thereby
                                        putting "1" into those bits in the      Result 1011 1101 = BD in Accu after.    result.

       Binary      Hex                  This example shows the effect of        Data   1010 0101 = A5 in Accu before.   using "EOR". The four bits at "1" in
                                        the mask, reverse the four data bits,   Mask   0011 1100 = 3C in Operand.       before putting them in the result.
                                        The mask bits at "0" leave their        Result 1001 1001 = 99 in Accu after.    data bits unchanged in the result.
                                                                                      Theory is OK up to a point, but things are easier to understand when you can    actually see them work on the Oric, for real. Below is a short routine,         which demonstrates the "AND" instruction operation above, using an Immediate    version of the instruction. The end result of the masking operation is          copied into location 1002 and you can look at that address after you have       run the routine, to confirm that the results are indeed, those shown above.     To change the operation to "ORA" or "EOR" you only need to change the           instruction opcode in location 1013 from 29 for "AND" to 09 for "ORA", or 49    for "EOR" and once again you can confirm the result by PEEKing location 1002.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Oric                       Demo Routine                           19 Jan 94     ----                       ------------                           ---------     [ CALL#1010 ]--------------[ Data Masking ]---------------------------[ / ]
                          ---Parameter Block 1001---                            1001:A5       : "sample"   : Item for masking (binary value 1010 0101).         1002:         : "result"   : Storage for item produced by the instruction.
                          ---Load Item & Mask it---                             1010:AD 01 10 : LDA 1001   : Load Accu with sample from location 1001 and       1013:29 3C    : AND# 3C    :     then mask it with binary value 0011 1100       1015:8D 02 10 : STA 1002   :     and store the result in location 1002.
                         ---Finish---                                          1018:60       : RTS        : Exit (at which point location 1002 contains 24).
          ---end---
                                                                                                                                             The routine above, can be entered using your own favourite assembler or the     Hexloader program from Part 7 of the series. As it consists of just nine        bytes it could even be POKEd into the memory, one byte at a time.
                                                                                               The data, mask and final result bytes, were           Conversion Table          all converted to and from binary and hex using    hex  binary   hex  binary     the table shown again here. For example the        0    0000     8    1000      mask is 0011 1100. Notice that it is written       1    0001     9    1001      as two groups of four digits, rather than one      2    0010     A    1010      group of eight. That is not important, but it      3    0011     B    1011      does make binary numbers easier to handle.         4    0100     C    1100
                                                   5    0101     D    1101      Using the conversion table, the first group        6    0110     E    1110      0011 converts to 3 and the second group 1100       7    0111     F    1111      converts to C. Put them together and you get                                    3C for the mask in instruction 1013 operand. The results are converted in       the same way. The "AND" operation produces 24. The 2 in binary is 0010 and      the 4 is 0100, which put together as one byte is 0010 0100, for 24 hex.                                                                                         

Capital Punishment ?                                                            -------------------- These masking operations really come into their own        with graphics, but they are also used for setting up hardware such as           Input/Output ports. They can have other uses. Have you ever fallen foul of      "CAPS LOCK". The Oric has an "on screen" CAPS indicator, but other machines     are not so well endowed. Software is often controlled by pressing lettered      keys, usually capital letters. If the software requires you to press key "A",   you will find that keying little "a" will not do. It's very annoying when a     computer "hangs up" because you forgot to set the CAPS LOCK correctly,          before running the software. Keying "Caps Lock" while running may not solve     the problem, because the software may prevent you from doing that and anyway    strange though it may seem, it is not always obvious what the problem is, in    the heat of the moment. It is a much better idea to incorporate a routine       into your software that in effect, automatically disables the "Caps Lock" so    that the problem cannot occur in the first place.                                                                                                               Take a look at the ASCII character code (listed in most computer manuals)       you will find that the only difference between small (lower case) letters       and capital (upper case) lies in Bit 5 of each character code, which is set     to "1" for small letters and cleared to "0" for capitals. A simple masking      routine will ensure that the keyboard only produces capital letter codes.       More about that next time.......In the meantime, a party political message !                                                                                    Surely John Major wouldn't have had all that trouble if he had used                     assembly language, instead of going "Back to Basics" all the time !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          


		Machine Code for the Oric Atmos (Part 33)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We have looked at essentials for machine code programming      and a small selection of useful 6502 Instructions appeared in Part 22 of the    series. A few programming techniques, have also been covered. The last few      issues have concentrated on the subject of binary code and we have been         looking at instructions that can be used to mask out specific items of data.                                                                                    It is easier to grasp how things work, if you can see an example of them in     action. As I have already mentioned, masking instructions come into their       own, in graphics or when used to set up hardware.                                                                                                               The main thing that I have used masking instructions for on the Oric has        been setting up the Expansion Board, which is featured as a project in the      Oric "Advanced User Guide". The Expansion Board is a very interesting item      and there are quite a number of functions on it, that I have yet to try,        but of course, not many people have this piece of hardware.                                                                                                     In this series, I try to avoid the use of extra hardware and keep to the        essential Oric-1/Atmos setup. It is also a good thing to keep practical         examples of instructions as small and simple as possible. This bring us to      the subject that we looked at briefly last time. That involved control of       software from the keyboard and the problems that can be caused if the "CAPS     LOCK" has not been set correctly. This is not a serious problem, but it does    provide an opportunity to illustrate a simple use of a masking operation.                                                                                       First of all, the problem. This is caused by the difference between the         codes for small (lower case) letters and capital (upper case) letters.          If your keyboard is set to produce small letters and your software expects      capitals, the chances are that your program may "hang up".                                                                                                      The reason is simple. The code for a small letter is different from that        used by it's capital letter, so the software doesn't recognise it. However      there is a relationship. Look at the ACII character code set (listed in most    computer manuals) and you will see that the codes for capital letters "A" to    "Z" run from from 41 to 5A in hex. For the small letters, "a" to "z", it is     61 to 7A. If you look at these codes and convert a few samples from each set    into binary values and look specifically at Bit 5 in each case, you will        find that it is Bit 5 that controls whether the code is for an upper case       (capital) letter, or a lower case (small) letter.                                                                                                               For a small letter, Bit 5 is always set to "1", but in the code for it's        capital letter, Bit 5 is always cleared to "0". That is the only difference.                                                                                    This is where we can make use of a masking instruction. If you use an AND       instruction with a mask set to 1101 1111 (DF hex) on any data byte, you will    find that it will clear Bit 5 to "0" in that data byte, unless Bit 5 is         already clear. If the data byte is a code for a letter, masking with that       value, will have no effect on the capital letter codes, but it will change      the small letter codes to capital letter codes. So in effect if you are         reading the keyboard for control input, your software will only see capital     letters, irrespective of whether the "CAPS LOCK" is set, or not.                                                                                                If you are only using letter codes, it is simple enough to pass all of them     through an AND masking instruction, with the mask set to 1101 1111 in binary.   Look at the small hex/binary conversion table published in the last issue of    OUM and you will find that binary value 1101 1111 of the mask, is DF in hex.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    I should mention that there is one thing to watch out for. If you are simply    using the letter keys for control, you can pass all input from the keyboard     straight through an "AND" instruction. However, if you are also making use      of other ASCII codes such as numbers and punctuation marks, you may well        need to confine the masking instruction to the letter codes only. The           routine listed below will do the trick, if called up to vet keyboard input.                                                                                     

Oric                       Sample Routine                         10 Feb 94     ----                       --------------                         ---------     [ JSR 1210 ]---------------[Convert L/Case only, to U/Case]-----------[ / ]

              :            : Enter with input item in Accumulator.

         ---start---      ---Filter Out Lower Case Codes---                     1210:C9 61    : CMP# "a"   : Is item 61 ("a") or higher code value ?            1212:30 06    : BMI"121A"  :    No - so skip to finish now ("N" Flag = 1).
                                Yes - so test for "z" plus one.                  1214:C9 7B    : CMP# "z+1" : Is item a higher code value than 7A ("z") ?        1216:10 02    : BPL"121A"  :   Yes - so skip to finish now ("N" Flag = 0).
                               No - so item must be in "a" to "z" range and
                                     therefore lower case, so convert it. 

                          ---Change Lower Case to Upper Case---                 1218:29 DF    : AND# DF    : Mask Bit 5 to "0" (DF hex = 1101 1111 binary)

                          ---Finish---                                          121A:60       : RTS        : Exit
          ---end--- 
                                                                                                                                            [ CALL#1010 ]--------------[Any Old Software]-------------------------[ / ]

         ---start---      ---Fetch a Key Press---                               1010:20 78 EB : JSR EB78   : Read keyboard (using GTORKB) and then
                               test to see if key pressed ?                     1013:10 FB    : BPL"1010"  :    No - Key not pressed, read keyboard again.
                                Yes - Key was pressed so...

1015:20 10 12 : JSR 1210   : Convert any Lower Case input to Upper Case
                               using routine listed above)

   and carry on from there, to use the keyboard input for controls etc....
                                                                                      [-------------------------------------------------------------------------]

The above is just a sample The addresses shown here, are only used to           illustrate how the above listing works. The routines can be relocated to any    available address, you wish to use.                                                                                                                             The main operation, is the masking instruction, shown here at address 1218.     That clears Bit 5 of the item in the Accumulator, in the way illustrated in     the last couple of articles. We want the masking instruction to operate on      lower case letter codes only, so the first four instructions, 1210 to 1216,     are used to ensure that any other codes, skip the masking instruction. Those    four instructions sidetrack the unwanted higher and lower values past the       mask instruction, by using CMP to set the "N" flag which controls the two       Branch instructions. The calling routine, starting at 1010, illustrates one     way to incorporate the operation into software.                                                                                                                 Next time, we look at the other main binary operation, Rotate instructions.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           


		Machine Code for the Oric Atmos (Part 34)   Peter N. Bragg                      		-------------------------------                                           

The Story so far                                                                ---------------- We have looked at essentials for machine code programming      and a small selection of useful 6502 Instructions appeared in Part 22 of the    series. The last few issues have concentrated on the subject of binary code     and how it can be of use, on the Oric.                                                                                                                          Essentially, there are two types of useful binary operations available to us    on the Oric. One of them, the masking operation, has already been covered in    the last couple of issues. The other useful binary operation, is the Shift      operation and this is what we are going to look at now.                                                                                                         

Shift about a bit                                                               ----------------- So what is a shift ? and what does it do ? Well, if you       look at any single byte anywhere in the memory, you probably know by now,       that while it is usually written as a two digit hex number, it is really an     abreviation for an eight digit binary number or eight bits for short.                                                                                           Consider those eight bits for a moment, as if the byte itself was open at       both ends and capable of holding just eight bits. Think of the byte as a        tube with eight bits like eight "ping pong" balls with "0" or "1" written on    each of them. Now suppose you take a ninth "ping pong" ball with "0" written    on it and push it into the "tube" at one end. What would happen ? Well,         obviously all the "ping pong" bits would shift along the tube and the last      one at the other end would fall out and be discarded.                                                                                                           That is just what happens in a shift operation. The shift instruction pushes    a single bit into one end of the byte and causes the eight bits already in      there, to shift sideways one place. As the byte can only hold eight bits,       the sideways shift, causes the last bit at the other end to "fall out" and      be discarded.                                                                                                                                                   The shift can be either direction, left or right. An extra bit is just          pushed into one end of the byte by the shift instruction and the last bit at    the other end is simply "lost" from the byte, which has gained the bit          pushed in, instead.                                                                                                                                             

Shift Work                                                                      ---------- There are four instructions for shift operations on the single       bytes, which can be held in the Accumulator, or stored in memory. Two of        them are plain shifts, one for shift left and one for shift right. The          remaining two are slightly extended versions of the first two and can make      the shift into a complete "rotation" when shifting either left or right.                                                                                        Let's look at the two plain shift instructions, first. These are ASL for        "shift left" and LSR for "shift right". Their full titles are Arithmetic        Shift Left (ASL) and Logical Shift Right (LSR). They can be used as Absolute    instructions on the contents of locations in memory, or they can be made to     operate on the contents of the Accumulator.                                                                                                                     The two Accumulator instructions are the easiest to use. They are single        byte instructions and simply shift the Accumulator contents one bit to the      left or one bit to the right, depending on which one of them you use.                                                                                           To give an example, let's imagine that the Accumulator contents have been       set to the value 01 hex (which is 0000 0001 binary). The instruction to         shift left is ASL, which is a single byte instruction (hex code 0A).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            If we used the ASL to shift the Accumulator left once only, we would find       that it would change the Accumulator contents to the value 02. Shift it         twice to the left and the value in the Accumulator would be 04. Shift it        three times left and the value becomes 08. So what is happening ? The answer    lies in the binary values of those hex results. See list on the left, below.
                                                                                     Start value  01 hex = 0000 0001 binary   Notice that each shift left, moves
  1st shift  02 hex = 0000 0010 binary   the binary "1" one bit to the left.
  2nd shift  04 hex = 0000 0100 binary   This would continue into the
  3rd shift  08 hex = 0000 1000 binary   second half of the byte, so the
                                         next shift left would produce         10 hex and the shift after that, 20 hex and so on. This shift effect of         course works on all eight bits, so the eighth bit (furthest left) is            discarded by each shift. This means that if you do eight shifts to the left,    you will end up with zero (00), because you will have shifted and discarded     all eight bits of the byte, which then becomes binary value 0000 0000.                                                                                          That was the plain shift left operation as done by the instruction ASL.         The shift right operation is exactly the same except that it goes in the        oposite direction. So if you started off with 01, the very first shift right,   would discard the bit on the right, making the value zero (00) from then on.    Of course if you started with the value 80 hex, which is 1000 0000, the         first shift right would change that to 40, which is 0100 0000 in binary.        These two instructions have a number of uses, the obvious one is the ability    to halve or double values. It can also be used, for example, together with      masking to split up a value consisting of several hex digits, in order to       use those digits for display purposes.                                                                                                                          

A shift around                                                                  -------------- Shifts could be used to move a "sprite" across the screen,       but of course here we hit a snag. Like most computers, the Oric's display       screen is many bytes wide. We need some way to pass on the bits which are       discarded, into the next screen byte in line. This brings us to the other       two shift instructions which can provide a "rotate" operation.                                                                                                  These two instructions are ROL, which is short for "ROtate Left" and ROR        which is short for "ROtate Right". Although these are called "rotate"           instructions their operation is exactly the same as that described for the      shift instructions, above. However, there is one small addition which makes     all the difference. Remember the bit pushed into the plain shifted byte and     also the bit "lost" from the other end of it ? Well, the difference in these    two "rotate" instructions is that they use the Carry flag for those two bits.   (You may remember that the Carry flag was used by addition and subtraction      instructions to carry the overflow from one sum to another.)                                                                                                    The "rotate" instructions shift in the same way as plain shift instructions,    but instead of pushing a zero bit into one end of the shifted byte, the         Carry is pushed in and the bit, normally "lost" off the other end of the        shifted byte is copied into the Carry flag. So in effect, the Carry flag        provides a ninth bit for the shift and turns the operation into a complete      rotation. Nothing is "lost" because the bits that "fall off" one end of the     shifted byte are picked up by the Carry flag and pushed back in at the other    end, by the next rotate instruction. All this is done automatically by the      instruction. Rotating a single byte like this has some use, but "Rotate"        instructions really come into their own, when you open the operation out, to    include more than one byte and use the Carry flag to pass the contents of       one byte to another smoothly, bit by bit, as you would when moving "sprites"    around the screen........................More shifty business, next time !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  