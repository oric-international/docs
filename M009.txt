Machine Code for the Oric Atmos (Part 49)   Peter N. Bragg                      -------------------------------                                           
It is now the end of the Summer and a lot has happened since the last issue.    The Oric Meet took place in sizzling temperatures. If you didn't go, you        missed a good day. "Magnetix" by Jon Bristow, the Internet by Jon Haworth       and a lesson on how to print gibberish from Peter Thornburn. Hope you           managed to sort out one of those printers, Peter ? There was also an amusing    demonstration on how to store cigarette ash in the Oric keyboard, by our        expert gamester.                                                                                                                                                The Internet demo by Jon Haworth was very interesting. It is now a very         tempting proposition, particularly with the real prospect of being able to      contact fellow enthusiasts, anywhere in the world. A phone on its own is a      very limiting form of communication. The enormous coverage and freedom of       the Internet opens up all sorts of possibilities. Recent articles in the OUM    and CEO mags have provided an illustration of what can be achieved, in their    reports on the Oric sites. I never thought that I would consider the old        steam driven PC as a future computer. Of course, the PC now comes with real     "Windows", just like my old Acorn Archimedes. The only problem is the cost      of the kit, required to get started. I really need to win the Lottery. 
                                                                                         The Story so far                                                                ---------------- It is two months since the last issue, which is a long time.   Hopefully, you will remember that we were continuing with our look at the       Zero Page instructions.                                                                                                                                         The Zero Page instructions use a combination of indirect and indexed            addressing and previous issues covered these operations before going on to      look at their use in Zero Page. The last issue then looked at one of the two    main types of Zero Page instruction. First off, was the Pre-Indexed             addressed type which was illustrated by using a LDA (Load Accumulator)          instruction as a working example.                                                                                                                               The Pre-Indexed instructions use Register X to index addresses. We can store    a number of two byte addresses in Zero Page (0000 - 00FF) area and select       any one we require for use by simply setting Register X to the appropiate       value. The two byte addresses that are stored in Zero Page do not have to be    in any sequence or connected in any way. They can be locations, literally       scattered at random anywhere in memory.                                                                                                                         This allows you to select isolated locations in memory for Zero Page            operations. In all there is a choice of eight operations covered by Zero        Page instructions. Have another look at the last issue for more detail.
                                                                                         Post Indexed Addressed Instruction                                              ---------------------------------- As I said then, there are two types of       Zero Page instruction. We have looked at the Pre-Indexed type. Now, lets        have a look at the Post-Indexed instruction. This has always seemed to me to    be the more useful of the two types.                                                                                                                            There is a significant difference between "Pre-" and "Post-Indexed"             instructions. The Pre-Indexed type always uses Register X whereas the           Post-Indexed type always uses Register Y for it's operations.                                                                                                   Once again the indirect address for Post-Indexed instructions is stored as      two bytes in Zero Page. However in this case there is just the one indirect     address, so it's location in Zero Page, is all that is needed to select it      and the index can be used for other purposes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   So now we find that the index is applied after indirect address has been        found, which is why this type of instruction is called a "Post-Indexed"         instruction. The contents of the index (Register Y) are added to the address    in Zero Page to produce the final address, which is where the instruction       operation is carried out. Lets have a look at another example, once again       using a LDA (Load Accumulator) instruction. If you look at the example in       the last issue and compare it with this one, you should be able to see the      difference in the two types of instruction 
                                                                                                                     The Example                                                                     ----------- below loads the Accumulator with an item from data memory, using    a "Post-Indexed LDA" instruction. Again, we need initially to set it up by      putting a data item into the data memory and an address into Zero Page as       per the example below
.                                                                                                                                          [--------------------------[ Any old routine/anywhere ]-------------------]
 
             ---Fetch Data item into Accumulator---
nnn0:A0 06    : LDY #06    : Set Index/Register Y to 06 and                     nnn1:B1 80    : LDA (80),Y :  then fetch data item from indirect address.
                                                                                       [--------------------------[ Address and Data Storage ]-------------------]

                          ---Parameter Block in Zero Page---
0080: 02      :            : Two byte storage for the                           0081: 10      : "1002"     :    Indirect Address.
          ---end---
                          ---Parameter Block 1002---                            1008: 58      :   "X"      : Item of data (ie. ASCII code for letter "X")
          ---end---                                                             ---------------------------------------------------------------------------     The instruction at nnn0 sets Register Y to 06. This is followed by the          "Post-Indexed" LDA instruction at nnn1. If you look at the previous example     in the last issue you will see that there is a slight change in the format      of the instruction label, the index Register appears outside the brackets to    show that this time, it has no effect on the Zero Page location inside the      brackets, unlike the first example.  
                                                                                                                           Now what happens, is that the instruction at nnn1 uses it's operand (80) to     find the locations 0080 and 0081 in Zero Page. Those two locations hold the     indirect address (1002). The instruction adds the contents of Register Y to     a copy of that indirect address (1002 + 06) to produce the final address,       (1008) which is where it carries out the instruction operation (LDA).           The end result once again, is that instruction nnn1 loads the Accumulator       with a copy of the data item "X" (code 58h) from address 1008.                                                                                                  Now that we have seen one example of each of the two types of instruction,      it might be a good time to look at a short demo routine that shows them in      action.  
                                                                                                                                                       The Demo Routine                                                                ---------------- The listing below is a simple demo of both types of Zero       Page instructions. Instruction 1019 is a Pre-Indexed LDA instruction, which     fetches an ASCII display code item from Parameter Block 1002 and instruction    101B is a Post-Indexed STA which puts that item into Oric's display screen.     The routine is intended to demonstrate the effect of Registers X and Y on       the two Zero Page instructions and has deliberately been made a little          flexible so that you can see what effect, changing the contents of the          Registers X and Y, has on the two instructions 1019 and 101B.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Oric                       Demo Routines                          28 Aug 95     ----                       -------------                          ---------     [ CALL#1010 ]--------------[ Display Lines ]--------------------------[ / ]

         ---start---      ---Parameter Block 0074 in Zero Page---                                                                                               0074:03       :   1003     : Address in Param Block 1002 for ASCII "X"          0075:10       :            :                                                                                                                                    0076:05       :   1005     : Address in Param Block 1002 for ASCII "Z"          0077:10       :            :                                                                                                                                    0078:04       :   1004     : Address in Param Block 1002 for ASCII "Y"          0079:10       :            :                                                                                                                                    007A:02       :   1002     : Address in Param Block 1002 for ASCII "W"          007B:10       :            :                                                                                                                                    007C:A8       :   BBA8     : Line 1 Address on Screen Display                   007D:BB       :            :
          ---end---

         ---start---      ---Parameter Block 1002---                            1002:57       :   "W"      :  "ASCII"                                           1003:58       :   "X"      :     Display                                        1004:59       :   "Y"      :        codes                                       1005:5A       :   "Z"      :
          ---end--- 
                                                                                                                                            [ JSR 1010 ]---------------[ Zero Page Instruction Demo ]-------------[2/2]
         ---start---                                                            1010:48       : PHA        :                                                    1011:8A 48    : TXA PHA    : Preserve Accumulator and Regs X & Y contents.      1013:98 48    : TYA PHA    :                                                                                                                                    1015:A2 02    : LDX #02    : Set Index/Register X to 02 and                     1017:A0 10    : LDX #10    :  then set Index/Register X to 10.                                                                                                  1019:A1 74    : LDA (74,X) : Fetch "ASCII" display code into Accumulator        101B:91 7C    : STA (7C),Y :  and put it into Display Screen address.

                          ---Continue or Finish ?---                            101D:C8       : INY        : Count item displayed (add 01 to Register Y)        101E:C0 20    : CPY 20     : Test - have 16 chars been put into Display ?       1020:D0 F7    : BNE"1019"  :   No - so back to fetch another display code.
                              Yes - so........

                          ---Finish---                                          1022:68 A8    : PLA TAY    :                                                    1024:68 AA    : PLA TAX    : Retrieve Regs Y & X and Accumulator contents.      1026:68       : PLA        :                                                    1027:60       : RTS        : Exit back to Basic.
          ---end---  

Enter the parameters and routine, using your favourite assembler or hex code    writing utility. I entered the hex code only, as listed in the first two        columms. CALL#1010 to run. As listed, the routine produces a short line of      16 characters on the top line. Like those Basic "Print Hello" routines, not     very exciting, but useful if you want to find out how things work.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              If you are not too clear on the subject of Zero Page instructions, you can      call the routine and use the result to see how the instructions work.                                                                                           First of all, lets look at the routine as a whole. The first five               instructions 1010-1014 inclusive, preserve the contents of the Accumulator      and the two Registers. Likewise, instructions 1022-1026 at the Finish           reverse the process and restore the Accumulator and two Registers to their      original state. This is not essential for the operation, but it is a good       habit to get into and avoids complicated foul-ups due to corrupted registers    between routines. The last instruction RTS, at 1027 simply returns you to       Basic. Having said that, we can now ignore all that lot and concentrate on      the main part of the routine.                                                                                                                                   The main part of the routine are the instructions 1015-1020. Instructions       1015 and 1017 are used to set the two Registers. Instructions 1019 and 101B     are our sample Zero Page instructions and the following three instructions      101D-1020 provide a short loop that controls the number of characters put on    the screen.                                                                                                                                                     Taking instruction 1019 first. This is the Pre-Indexed LDA, which is used to    fetch an item of code into the Accumulator. It's operand is 74, which means     that it starts with a base location of 0074 in Zero Page, to which it adds      the contents of Register X. Register X has been set to 02 by instruction        1015 so the result is that the Pre-Indexed LDA looks for an address in 0076     and 0077, which contain the final address (1005). So the Pre-Indexed LDA        fetches the item from 1005 (ASCII code "Z") and puts it into the Accumulator.                                                                                   Now if you were to change instruction 1015 so that it set Register X to 04,     the Pre-Indexed LDA at 1019 would add that to 0074, thereby using the           address in 0078 and 0079, which in this case is 1004 and the final result is    that the Accumulator would be loaded with ASCII code "Y".                                                                                                       You could also make similar changes by setting Register X to either 00 or 06.   However, for this demo, you are restricted to those four values. What           happens if you do use a value outside the range 00, 02, 04 and 06 ? Well the    Pre-Indexed LDA will simply try to make an address somehow and fetch from       that. For example if you set Register X to 07 it will look for an address in    locations 007B and 007C, which in this case will result in the cobbled up       address A810, which is not much use. The same applies to any other unlisted     value, so dont bother for this demo.                                                                                                                            Now for the Post-Indexed STA instruction at 101B. The addressing on this        works in a slightly different way. Instruction 101B operand is 7C and as a      result the instruction goes straight to locations 007C and 007D for it's        final address (BBA8). Having found that, it adds the contents of Register Y     to that address and as Register Y is initially set by instruction 1017 to 10,   it adds 10 to that final address, so the first code is put into address BBB8.   The simple loop created by instructions 101D-1020 adds 01 to Register Y and     returns to put another item into the next address. As these are screen          addresses, you get a line of display characters on the screen.                                                                                                  The instruction 101E controls the end value of Register Y, which controls       the length of the line displayed on the screen. If you increase it's value      from 20h upwards (to a maximum of FF), you will increase the length of the      line displayed. You can also change the line start using instruction 1017.                                                                                      These addressing modes apply to all eight of types of Zero Page instruction.    That just about covers it for now........................See you next month.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          


Machine Code for the Oric Atmos (Part 50)   Peter N. Bragg                      -------------------------------                                           
The Story so far                                                                ---------------- The past few issues have looked fairly intensively at the      subject of Zero Page instructions. These can be very useful instructions        that combine the operations of indexing and indirect addressing, which          allows them to be used to fetch, store or modify data in blocks or scattered    locations. The last article, included a short demo of both "Pre-Indexed"        and "Post-Indexed" Zero Page instructions together. The demo routine used       the Accumulator to fetch an item from data memory and put copies of it onto     the screen display.                                                                                                                                             Hopefully, breaking the instructions down into a number of small and simple     operations and then dealing with those separately, before building up again     to the full blown instruction operation, makes more complex instructions,       such as Zero Page, easier to grasp, in the long run.                                                                                                            We have now more or less covered the subject of Zero Page instructions. They    are probably the most complex of the Oric's 6502 machine code collection, so    if you have got those "sussed out", you are unlikely to have trouble with       any of the other machine code instructions for the Oric. 
                                                                                                       So What Now ?                                                                   ------------- This series has concentrated on explaining the Oric's 6502        Instruction Set and I must confess that it has taken a lot longer to cover      the subject than I first thought. The first few articles in particular, had     to fill in a lot of essential detail. Although such detail is common            knowledge to some of us, there are many who find the lack of know-how on the    basic elements of programming and how a computer works, a severe handicap.                                                                                      Often it is the simple things that produce the stumbling block. Way back        when I started computing, I was always stumbling over an instruction that       required an "offset" (occasionally referred to as a "displacement").                                                                                            I hadn't a clue what an "offset" was and the only explanation I could find,     appeared to be some nutty exercise in binary maths and punctuation. This        was in the early days and there was no friendly user group available for        advice and my knowledge on the subject was very sketchy. The only way to        find out, was to enter the instruction and some test values into the            computer and note the results.                                                                                                                                  Now that I am quite familiar with that instruction, it all seems so simple.     The problem instruction was the Branch and the "offset" (or "displacement)      was the value that just set the distance and direction of the relative jump,    that the Branch instruction makes, if the conditions are right. Any value       from 00 to 7F would produce a forward jump of that number of locations.         Values of FF down to 80 would do the same in the opposite direction,            starting with FF and going furthest back with value 80. It may seem simple      now, but I can well remember the frustration of trying to work out just what    it did, from the rather vague information in the manual. The manual's           description still seems difficult to comprehend, even now.                                                                                                      So why did I continue to use machine code, in view of such problems ?           Well the Basic language was an expensive extra on many of the early micros,     when I started. So like many people at the time, I made do with machine code,   which was faster and didn't need so much expensive memory. Later, Basic         became more widely available. However, it was less attractive, because it       was slow and I found the variations between different versions irritating.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      The other popular language, in the early nineteen eighties, was Pascal,         which was faster than Basic and more portable, which meant that software        written in Pascal could be run on other machines, without the need for          extensive changes, to cater for different versions.                                                                                                             That was the theory anyway. However, in practice even the commercial            software writers ran into a lot of problems with Pascal, particularly when      debugging software. From the professional users point of view, we found that    commercial software was a poor advertisement for languages such as Pascal,      which is why I continued to use the machine code/assembly language, for         writing my own software.                                                                                                                                        Other languages have also had their brief spell of popularity, some have        even been hailed as the ultimate magic language which will make writing and     debugging software an easy job. None of them have achieved that goal. The       great survivor appears to be "C" and it's variants, but nobody could call it    a simple to use and friendly language. 
                                                                                                                         Something New ?                                                                 --------------- So what has all this to do with machine code ? Well there       appears to be an interesting development on the software front, that I have     recently read about. This is an operating system called "Taos", which has       been under development for six years. From the description that I saw in a      recent copy of "Acorn User" it appears to be a new version of an old idea.                                                                                      I wonder how many remember "Basicode". Those of us who tried "Basicode" in      the mid-nineteen eighties had great fun passing Basic software on tape,         between the Apple, ZX81, BBC Micro and others. The trick was done by            installing the same Basic and filing system in all of the different             computers. The main snag was that it tended to slow the faster machines down    and for obvious reasons, the lowest common denominator prevailed, so all the    computers tended to look like the old ZX81 in operation. It was a very          clever idea for the time. There was even a version for the Oric although I      wasn't able to get hold of that one.                                                                                                                            The information that I have seen so far about "Taos" is a bit sketchy.          However, it seems that it is not so much based on a language this time, but     on a machine code system that acts as a kind of pseudo microprocessor.                                                                                          Apparently, what it does, is to install it's own machine code system as an      interface to the microprocessor currently installed. As a result, many          different types of microprocessor will be able to use exactly the same          machine code language. So it follows that the same software written for the     system will run on any machine that has the system installed and it will be     able to run on many different computers with different microprocessors.                                                                                         The advantages of a system like this, are that it can be quite small. As a      result, it is unlikely to slow down the overall computer speed. More to the     point, because it works at the microprocessor's level, it is less affected      by hardware. Computers with better performance and hardware, will not be        dragged down to a common level by less well equipped machines.                                                                                                  A single machine code language system, would affect all software including      other languages and make software writing much simpler. Snags ? Well dont       hold your breath, waiting for a 6502 version. The developers have decided       that an eight bit version is not worth developing. Never mind, it does mean     that knowledge of machine code operation could be very useful in the future,    as most microprocessors seem to have the same base functions................

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Machine Code for the Oric Atmos (Part 51)   Peter N. Bragg                      -------------------------------                                           
The Story so far                                                                ---------------- Recent issues have looked fairly intensively at the subject    of Zero Page instructions. In the last issue we had a brief bit of              speculation on the future in the shape of the system called "Taos", which       aims to provide a common interface to the centre piece of all microcomputers,   which is the microprocessor, also known as the central processing unit (CPU).
                                                                                   Cutting things down to size                                                     --------------------------- The idea behind that last article was to show       that all microprocessors have the same essential operations. They all fetch     an item of data into a storage unit, (ie. Accumulator or Register) and          modify it (ie. Add, Subtract, Rotate or Mask, etc.) and then put the result     into the required location. The actual number of these data modifying           operations is not very large. In fact, you may have noticed, if you have        been following this series for some time, that most of the instructions are     concerned with the many and various ways to fetch, copy or access data. A       prime example of this was the Zero Page instruction set, that we have been      looking at, in the last few issues.                                                                                                                             The point is that we do not necessarily need the whole microprocessor           instruction set in order to write software. I tried to illustrate this point,   by using an abreviated instruction set, very early in the series.               Oric's 6502 microprocessor uses some sixty odd instructions. In that article    (number 16), the set had been reduced to a set of little more than twenty       instructions.                                                                                                                                                   Reducing the number of instructions to a bare minimum in the first place,       makes it much easier to write software at the start. Later on, you will find    that the more complex instructions are much easier to understand and use,       because of the experience gained by using that initial core set of simple       instructions.                                                                                                                                                   Remember that simple core set of instructions again, when you eventually        move on to another machine and microprocessor and then look for their           equivalent in the new machine. This will give you a head start with             programming on the new machine. It stands to reason that if we can get to       grips with the few essential functions when using another machine with a        different microprocessor, we should be able to write software for it in the     same way as we can do for the Oric.                                                                                                                             It's really all about gaining experience. Reading about machine code            programming is useful, but you wont get far until you have actually had a go    and found that it all goes wrong and the computer hangs up in a big way.        Persist and you will get it right and then there are no limits to what you      can do. We have all been down that route. There is no harm in crashing the      computer, if there was, mine would have been spread around Surrey long ago !
                                                                                    We have other ways of making you program                                        ---------------------------------------- As I said above most instructions      are concerned with fetch, store and access operations. The reasons for the      various different types is that we usually need to operate on large amounts     of data. Single bytes are easy to access on their own, but we are much more     likely to want to deal with a whole screenful or more, as quick as possible     and it is preferable that we dont have to fetch them one at a time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             As we have seen, the usual way to deal with a large number of data items is     to count them into the Accumulator, using a second register to do the           counting. That second register ("X" or "Y" in the 6502) is called an index.     Other microprocessors use a similar system, although inevitably, they will      use a different name for each of the registers and quite likely the             instruction labels will be a bit different too. However, the principle they     use is the same as in our Oric's 6502.                                                                                                                          There are other ways of fetching or copying data bytes, that are fairly         simple and dont necessarily need to use a second register as an index.          Instructions are themselves, items of data and can be written to, just like     any other form of data. Now this technique would be frowned on in some          circles. Those of us brought up in the genteel world of the BBC Micro, have     always been forbidden to use four letter words like PEEK and POKE and anyone    POKEing the screen RAM, would face instant excommunication. The idea of         POKEing an instruction would be unthinkable. However, in the world of           minature aviation, they are made of stronger stuff and are more inclined to     ask "will it fly ?". In other words, if it works and is useful, who cares ?     Lets make good use of it. 
                                                                                                                                      The Write Way                                                                   ------------- If you look at two typical load or store instructions, the        Absolute versions of "Load Accumulator" (LDA) or "Store Accumulator" (STA)      for example, you will find that they are each made up from three hex bytes.     The first byte is always the opcode, which defines the actual instruction.      Instruction "LDA" is indicated by the hex value AD as it's first byte.          Change that hex value to 8D and the instruction will become an "STA" instead.                                                                                   That's the first byte of the instruction. Now the second and third bytes of     the instruction are the operand and they contain the data that controls the     instruction operation. In the case of our examples, "LDA" and "STA", these      two bytes hold the Absolute address where the item in the Accumulator is        either fetched from, or stored at. In the case of an Absolute address, the      two byte value makes up a full four digit address, the first of the bytes is    the lowest two digits of the address and the second of the two bytes is the     highest two digits of the address.                                                                                                                              Now, if you were to use an indexed instruction, you will find that you can      only access up to a maximum of 100hex/256decimal addresses at the most.         However if you use an ordinary Absolute instruction and alter its address by    POKEing a new address into it directly, you have no such limits and you can     literally reset it to fetch a data item from, or store an item in a location    anywhere in memory.                                                                                                                                             The way I do this, is to instal the instruction in a parameter (data) block     and call it as a subroutine. This needs four bytes in the parameter block,      one for the instruction opcode, two for operand/address and one for the         "RTS" instruction to complete the subroutine. The address is set, updated       and controlled by a couple of simple routines. One such instruction set up      like this, can be called up for many different operations, each controlled      by a different set of routines.                                                                                                                                 Yes, it is longer and slower than the Zero Page/Indexed equivalent, but it      is not limited by the space available in Zero Page, quite a useful point if     you are writing software to run on different computers. The fact that it is     a bit slower is not important in a lot of cases. This is machine code after     all, which is usually a heck of a lot faster and takes up much less space       than other languages.........................................More next time.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Machine Code for the Oric Atmos (Part 52)   Peter N. Bragg                      -------------------------------                                           
The Story so far                                                                ---------------- Recent issues have looked fairly intensively at the subject    of Zero Page instructions and in the last article we looked at another          method of fetching and storing large quantities of data. Essentially, this      technique consisted of writing to an active instruction, in a routine and       modifying it's operation while the routine is actually running.                                                                                                 We have used this technique before, very early in the series and I should       mention again, that this is not a particularly orthodox method of operation     and a large number of programmers, would consider such operations "illegal".    The expression "illegal" is silly and much mis-used by the computer trade.      The computer is a machine, Any technique that helps to make programming         easier is worth using, where needed. We will be making use of this type of      technique later on, but in the meantime, lets have another look at the two      instructions that we use to modify addresses. We have already used "Add with    Carry" (ADC) for this purpose, but not "Subtract with Carry" as yet. 
                                                                                           The Easy Number !                                                               ----------------- The great thing about using a computer, is that you don't     need to play around doing arithmetic, let the computer take care of all that.   The two main arithetic instructions "Add with Carry" and "Subtract with         Carry" operate using the Accumulator and are therefore restricted to a          maximum value of one byte. In the past we have used "Add with Carry", so we     can start by refreshing our memory about that one.                                                                                                              For example, if you want to move about on the Text screen display, you make     the Oric add a number to the screen address you wish to start from. If you      add "1", or more correctly 01 in hex, to that address, you will move one        character space to the right on the screen. Start with an address that is       the beginning of a line and continue to add 01 to the address and you will      eventually reach the right hand end of the line and then move down to the       first address on the the next line and so on. Continue to add 01 and you        will move across and eventually down the screen, line by line.                                                                                                  If you use the hex value 28h instead of the value 01h, you will move            vertically down the Text screen, because the Oric has forty character spaces    on each line and the hex code for 40 decimal is 28h, so each addition           of 28h, will take you down one line on the screen.                                                                                                              (The reason for using the screen area for these examples, is that that it is    much easier to see the effect of any demonstration in that area of RAM, but     in fact the result will be the same anywhere in the computer memory.)                                                                                           So we can move down the screen from the top to the bottom and we have used      the addition instruction in past demos to provide the addresses which have      enabled us to fill the screen from top to bottom with all sorts of rubbish.                                                                                     OK, so we can go one way, that is down the screen display but we haven't        done it the other way, from the bottom of the Oric's screen display, back up    to the top. So how do you do that ? Simple, start from the bottom address       and subtract the value from that screen address, instead of adding it.          That will move the screen address to the left, along the line and back up       the screen. This is where we need to change from an addition instruction to     a subtraction instruction. The two instructions are very similar, but there     is a difference in the way that they make use of the Carry.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     You will probably remember that when using the addition instruction ADC, you    need to clear the Carry Flag (to "0") first. This was done by instruction       CLC, which stands for CLear Carry. This is necessary because the Carry Flag     is included in the addition operation and if it happens to be already set       (to "1") by some previous unconnected operation, it will obviously introduce    an error into the addition result.                                                                                                                              The reason why the Carry is included in the instruction operation is quite      simple. As noted above, the addition and subtraction operations are carried     out, using the Accumulator, which as you may recall is limited to a maximum     value of one byte. That is a value in the range 0 to 255 in decimal or up to    a maximum of FF in hexadecimal.                                                                                                                                 Obviously, a value that small is a bit limited, particularly if you consider    that even addresses are two bytes each. This is where the Carry comes in. 
                                                                                      Back to Skule ?                                                                 --------------- Usually, when we add a couple of numbers together, we start     with the lowest two digits and add those together. If the result is larger      than one digit (ie. 10 or above), we write the lowest digit into the result     and make a note to "carry" the overflow digit. Now when we add the next two     digits together, we also include the "carry" in the addition and we repeat      this operation until we have added all the digits in both numbers and if        there is still a "carry" left over, we add that to "0" and write it in as       the highest digit in the result.                                                                                                                                Subtraction is very similar, the only difference is that we "borrow" from       the next digit up if we need to subtract a high value digit from a low value    digit. In effect, the "borrow" is a "carry" of minus one and if you add that    to the next digit up, you will reduce it's value by one.
                                                                                                        A Quick Byte                                                                    ------------ OK, so thats the way we did it in school and that is also the      way the Oric does it. Instead of digits the Oric's 6502 chip can add or         subtract single bytes, so if you have a two byte address, you deal with the     lowest two bytes first and then the next two higher bytes. The state of the     Carry Flag is always added, so it must be correct state before the first two    bytes are added or subtracted. However, once that has been done, it can be      left alone for the rest of the calculation and you can go on to deal with       any pair of values, providing you do it byte by byte. After the first pair      of bytes have been dealt with, the Carry operation is completely automatic.     So there really is no limit to the size of the two values that you can add      or subtract.                                                                                                                                                    The Carry Flag does have other uses apart from arithmetic. It is unlikely       that you will know what state it is in, when you need it, so you might as       well clear or set it to the condition you require before you make use of it.                                                                                    When you use the "Add with Carry" instructions (ADC), you should clear the      Carry Flag first, using the "CLear Carry" (CLC code 18h) instruction.           Likewise the "Subtract with Carry" instructions (SBC) need to be started off,   by setting the Carry Flag (to "1") using "SEt Carry" (SEC code 38h).                                                                                            A routine to update addresses in the way described above, is a lot simpler      than it sounds and can be very useful for moving things about. We will have     a look at that next time...................................................

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Machine Code for the Oric Atmos (Part 53)   Peter N. Bragg                      -------------------------------                                           
The Story so far                                                                ---------------- The last couple of issues have looked in turn at the           subjects of writing to instructions in an operating program and also the        operation of the "Carry" in Addition and Subtraction instructions.                                                                                              Now we can look at some practical examples. We have used Addition quite a       bit in the past, but rarely used Subtraction for anything, so lets rectify      that omission here.                                                                                                                                             First, we take as an example the Absolute instruction "Store Accumulator".      We know that it consists of three bytes, first of which is the instruction      byte (opcode) plus two other bytes for the address. Using a specific example    ie. STA #BFDF, for which the hex code is 8D DF BF, we know that this            instruction will store (copy) the contents of the Accumulator into the last     location on the Oric's display screen, because the address #BFDF is the last    address in the screen display RAM, which runs from #BBA8 to #BFDF. This can     be demonstrated by loading the Accumulator with something (ie. "X" code 58)     and then using STA #BFDF, as shown in the brief listing below -
                                                                                                 1010:A9 58    : LDA# "X"   : Load Accumulator with hex value 58 for "X"         1012:8D DF BF : STA BFDF   :  and store (copy) it to location BFDF on screen.   1015:60       : RTS        : Finish/Exit back to Basic. 
                                                                                                        Write it into memory as shown and then call it. The result will be an "X" in    the bottom right hand corner of the Oric's display screen. Providing we do      not allow the screen to scroll, the result of that call will always be the      same. However, if we now subtract "1" (or 01) from the address it will make     the instruction 8D DE BF. A call to the routine will result in the "X" being    moved one location to the left on the screen. 
                                                                                                                  The Great "Takeaway"                                                            -------------------- If we wanted to continue moving the displayed item on      the screen, it's obviously not practical to stop and alter the instruction      address, between each call. So make the computer do it. We can try a simple     decrementing instruction, which in effect, subtracts 01 from the address low    byte. So now we add that instruction to our listing -
                                                                                                           1010:A9 58    : LDA# "X"   : Load Accumulator with hex value 58 for "X"         1012:8D DF BF : STA BFDF   :  and store (copy) it to location BFDF on screen.   1015:CE 13 10 : DEC 1013   : Update instruct 1012 by subtracting 01 from the
                              low byte of its a address.                        1018:60       : RTS        : Finish/Exit back to Basic. 
                                                                                                        OK so far and it works, but there is a snag, which you will find, when the      address eventually drops below BF00. At this point, you will find that the      address has become BFFF, which is off the screen ! This is because the DEC      instruction is a single byte only operation which wraps round at 00 and         continues downwards from FF again, which is not at all what we want.                                                                                            That result shows that we need to update both of the address bytes in the       instruction, starting with the low byte in 1013 and then the high byte in       1014. So lets try again, this time using the "Subtract with Carry" (SBC)        instruction. This will enable us to "carry" the result of any subtraction       over from the low address byte to the high address byte, so that when the       address drops below BF00, it will go on to BEFF and continue on downwards       in the correct order. 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          The listing is now a bit longer, as shown below -  
                                                                                                             1010:A9 58    : LDA# "X"   : Load Accumulator with hex value 58 for "X"         1012:8D DF BF : STA BFDF   :  and store (copy) it to location BFDF on screen.
                          ---Update Instruction 1012 Address---                 1015:38       : SEC        : Set Carry (to "1") ready for subtract operation.   1016:AD 13 10 : LDA 1013   : Fetch contents of 1013 and                         1019:E9 01    : SBC #01    :  then subtract 01 from them                        101B:8D 13 10 : STA 1013   :  and return the result to location 1013. 
                                                                                          101E:AD 14 10 : LDA 1014   : Fetch contents of 1014 and                         1021:E9 00    : SBC #00    :  then subtract the "Carry" from them               1023:8D 14 10 : STA 1014   :  and return the result to location 1014.
                          ---Finish---                                          1026:60       : RTS        : Exit back to Basic.
                                                                                                                Now we have a routine that works. Each time that you CALL#1010, it will put     an "X" on the display and then update the instruction address so that the       next call will put the "X" in the next location down in memory. The effect      on the screen, is that the displayed item "X" moves with each call to the       routine, one location leftwards and eventually upwards on the display screen.                                                                                   Of course, while this works, it's not the only way to do it. We can slightly    shorten and simplify the above routine, as shown in the listing below - 
                                                                                        1010:A9 58    : LDA# "X"   : Load Accumulator with hex value 58 for "X"         1012:8D DF BF : STA BFDF   :  and store (copy) it to location BFDF on screen.
                          ---Update Instruction 1012 Address---                 1015:38       : SEC        : Set Carry (to "1") ready for subtract operation.   1016:AD 13 10 : LDA 1013   : Fetch contents of 1013 and                         1019:E9 01    : SBC #01    :  then subtract 01 from them                        101B:8D 13 10 : STA 1013   :  and return the result to location 1013.
                                                                                           101E:B0 03    : BCS"1023"  : Test - If Carry set ("1"), skip to "Finish" now.   1020:CE 14 10 : DEC 1014   :  Carry clear ("0") subtract 01 from loc. 1014.
                          ---Finish---                                          1023:60       : RTS        : Exit back to Basic. 
                                                                                                               There is a small difference in the two routines, although they produce          exactly the same end result. The routines are the same, up to and including     instruction 101B. From then on the operation is slightly different, in the      way that they deal with the Carry result from instruction 1019.                                                                                                 The first routine deals with the Carry, by including it in a second             subtraction of zero value (instruct 1021). If the Carry is set ("1"),           nothing is changed by the "zero" subtraction. However, if the Carry has been    cleared (to "0") by the SBC #01 at 1019, it indicates that a "borrow" was       required and as a result, the "zero" subtraction, reduces the value in          location 1014 by 01.                                                                                                                                            The second routine simply uses the Branch instruction BCS, to control the       "borrow" operation. Branch instruction BCS, means "Branch if Carry Set".        Providing the Carry is still set after the first subtraction, the Branch        (BCS) ensures that instruction 1020 is skipped. If on the other hand the        Carry is cleared, the BCS instruction is disabled and as a result, the DEC      instruction 1020 operates to reduce the value in location 1014 by 01.           Hopefully, these examples have illustrated sufficently how subtraction and      decrementation operations work in practice...............See you next month.


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Machine Code for the Oric Atmos (Part 54)   Peter N. Bragg                      -------------------------------                                           
The Story so far                                                                ---------------- It has been some time since our last session of machine        code programming for the Oric and in the meantime we have had a couple of       flights of fantasy, looking at the future for Oric and for computing in         general. Of course, the views expressed in those two "Crystal Gazing"           articles, were my own personal views and inevitably are biased, by personal     interests and experience. There are others who may not necessarily share all    of those views. However, the two articles were intended to provide a change     and some food for thought. I hope that they were interesting too.                                                                                               Back to the last "Machine Code" article. As this appeared three issues back,    it might be an idea to refresh the memory of what that article was about.                                                                                       In the first place we were writing to instructions, inside a running program,   in order to change their operation during that program. This trick allows       us to extend the capabilities of instructions and makes them more useful.                                                                                       To illustrate this, we used a simple store Accumulator contents instruction     (STA) and changed it's address, each time it was used. This allowed us to       write a lot of data to an area of memory, using a single instruction to         actually place that data. The instruction's address was changed (updated),      by subtracting the value "1", each time the instruction was used.                                                                                               A simple routine did the "updating" by subtracting 01h from the address.        We could have just as easily used addition and written to the area, starting    from the the lowest address. However, starting at the highest address and       working downwards gave us the opportunity to make use of subtraction and        decrementation instructions, which up to now, have not figured very much in     this series. Hopefully, the examples gave an insight into how subtraction       and decrementation work and also illustrated the difference between the two     operations as well. However the main aim was modifying instructions.                                                                                            Of course all instructions can be modified, by writing to them while they       are in use. There are no laws in computing to stop you from using               instructions anyway you wish, despite what some people may think. Of course,    it is best to be sure of what you are doing. Always try something you are       not sure of, in a small test routine first, to see that you have got it         right before you commit yourself to using it in a large software project.                                                                                       Altering instructions, by writing to them, while the program is running, is     a useful trick, but it is not such a good idea if the instruction you are       using, is located somewhere in the middle of a long listing. While this is      unlikely to be a problem if the program is a "one off" job, you might come      back at a later date to modify and perhaps relocate some of your program.       This is where it is easy to forget odd items such as "writable instructions".                                                                                   Obviously a good descriptive listing helps to avoid problems. However, you      could make life easier, by putting such "writable instructions" in a place      where they are less likely to be forgotten. The ideal place for such items      is the parameter block, so let's have a look at those.                                                                                                          You may recall, that during this series, that I have recommended and used       the technique of dividing the programming area up into "Pages", which are       blocks of 100hex bytes each. In order to cater for all Oric versions, the       programming examples shown in this series, have all been located in the         "Page10" block, that is to say, locations #1000 to #10FF inclusive.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             You may also recall, that in most of the programming examples shown in this     series, the example program routines, normally start and are called from        location #1010. The area preceding that, which is location #1000 to location    #100F inclusive, is usually earmarked as the parameter block, used for          storing any data required by the example programs.                                                                                                              By necessity, example programs in this series have all been too short to        require more than one "Page", but in fact if you were to look at my own         programming efforts, some of which run to many "Pages", you would find that     most of those "Pages" are kept to the same format with the first sixteen        bytes of each "Page" being reserved as a parameter block for data,              irrespective of whether or not, it is fully utilised.                                                                                                           The point of these small "parameter blocks", is that they not only provide a    regular structure and format, which makes programming in machine code a lot     easier, they also provide a fairly stable area for odd items such as the        "writable instruction" mentioned above.                                                                                                                         Looking back to the last article in the series (Part 53), we used three         small routines to illustrate how a "writable instruction" works. In each        routine, the instruction, STA BFDF, was placed in location #1012. In fact,      it would have been better to have placed that instruction in the Page10         Parameter Block at say #100C and follow it, with an "RTS" instruction           (ie 100C:8D DF BF 60). This could then be called from the original routine,     or indeed from anywhere else, by a simple JSR 100C instruction. Yes, it is a    tiny routine in an area reserved for data, but then, half of it is data,        which is being written to anyway, so it is not really out of place there.                                                                                       The only drawback to this idea, is a slight loss of speed, due to the extra     "JSR" instruction, but of course, that is not important in many operations      and in any case, the overall speed advantage of machine code/assembly           language far outweighs any small loss incurred by useful techniques such as     this. I have certainly found that this is a very useful trick and have made     a lot of use of it over the years.                                                                                                                              Another example of an instruction that I have used and modified in this way,    is a conditional Branch instruction. Conditional Branch instructions consist    of two bytes. The first one is the opcode, which defines the condition that     activates the Branch. The second byte controls how far the Branch will jump.                                                                                    Once again that second byte can be written to. I have used one of these         Branch instructions like a selector switch to direct a stream of mixed data     to a number of different routines in turn, each of which then is able to        deal with its own specific type of data. In this case, the whole operation      was controlled by altering the value of the Branch instruction operand          (second byte), which would set the Branch "jump" to go to whichever routine     had been selected.                                                                                                                                              Strictly speaking, these techniques are a bit way out for those who are new     to machine code programming. However, most of it is quite simple and has the    advantage of not being restricted to a single area of memory, as was the        case for the Zero Page instructions, that we looked at a little while back.                                                                                     As I have said before, you don't have to know all the instructions in detail    in order to program successfully. You can start with just a few and use them    to gain experience and confidence. Building up with small routines and good     descriptive listings are the key to successful programming. Experiments and     some crashes are also essential ingredients..............See you next month.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Machine Code for the Oric Atmos (Part 55)   Peter N. Bragg                      -------------------------------                                           
The Story so far                                                                ---------------- The last few issues have looked at some of the programming     techniques, which I have found useful, in the past. In particular, we looked    at a technique of modifying instructions, while the software is running.        This time we will have a look at something different.  
                                                                                                         Getting it taped                                                                ---------------- The first thing that any machine code programmer learns, is    to make sure that all work is saved on to disk or tape. The temptation to       try a new routine always ends in tears, if you haven't saved it first. You      can usually get away with it in Basic, but untested machine code/assembly       software, is a sure fire route to a crash.                                                                                                                      Saving, is an easy task for those with disk systems and many of us use          Sedoric for our software storage. However, it appears that there are still      some who need to use cassette tape for storage and most of us have acquired     software on tape, which needs to loaded, before it can be put on disk, so       there is always going to be a time when we need to dust off that old            cassette recorder and enjoy the reappearance of the "Errors found" legend.                                                                                      In the June '96 edition of OUM, there was a very interesting article on the     tape system, by Fabrice Frances, which inspired this article. I don't intend    to get all "technical" about it. Fabrice can obviously make a better job of     that than I can. Like most users in the early days, I made a lot of use of      cassette tape storage. It might be worth looking at a couple of the things      that helped to keep problems to a minimum.
                                                                                                                      Alternative Systems                                                             ------------------- On the whole, I found that, like the Oric, Tangerine's      original Microtan and Acorn's BBC Micro, were fairly reliable for saving and    reloading software tapes. On the other hand, the Sinclair ZX81 was a lot        less reliable and could be a real pain at times.                                                                                                                I already had the BBC Micro before the Oric and it's tape system is worth a     brief look. The BBC Micro saved and loaded at 1200 baud, which was half the     speed of the Oric and it seemed dreadfully slow. In fact, it took three         times as long as the Oric, to save and load from tape, at the fastest rate.                                                                                     To be fair, the BBC Micro used a slightly different system. This loaded and     saved software in separate blocks of 100 bytes each. Although this is a         slower process, it can make life a lot easier. If a large piece of software     fails to load properly, it is possible to get a progress/error report, which    indicates the block(s) that failed to load correctly.                                                                                                           The printer can be turned on, while loading very long programs, to get a        hard copy of the progress/error report (to prevent it being lost when the       display scrolls). The blocks can also be loaded individually, which means       that you don't have to reload the entire program again, if one block fails.                                                                                     The main reason for mentioning the BBC Micro's tape system, is that a           similar system might be useful for the Oric and it might also be possible to    implement it, using simple Basic software.                                                                                                                      I also found it useful to be able to listen in on the tape saving process, but  this needed constant fiddling with the volume control. Hence, the next item.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    The "Squeaker"                                                                  -------------- Most of the tape recorders I used, needed different settings     for saving and loading. This was a bit of a nuisance and occasionally lead      to an embarassing uproar, if I forgot to set the recorder speaker to the        correct volume, particularly when "burning the midnight oil".                                                                                                   So I plugged one of those little earphones, that are used for private           listening on transistor radios, into the tape recorder output. That cut out     the main speaker. The earphone was then left on the table. It didn't make a     lot of noise, but it was clear enough to monitor the loading and saving         process without having to fiddle with the recorder volume control. A simple     but useful item. The earphone is a few years old, but I have seen them          around. A cheap "walkman headphone" would probably be just as effective. If     you try this, do not put the earphone in your ear, because it can be very       loud and your head will probably go off like an Arianne rocket !! 
                                                                                              Test Card                                                                       --------- How do you adjust your cassette recorder to get the optimumm          settings for reliable saving and loading. By lengthy trial and error in a       lot of cases. Instead of typing in Load and Save etc, and waiting with bated    breath, try a simpler method. Make up a special test tape with your own "test   card", which you can use when you get problems.                                                                                                                 First of all, the "Test Card". Essentially, this boils down to saving the       screen area to tape and reloading it again. The advantage of using the          display on the screen, is that you can see precisely what is happening, as      it happens. You don't have to wait for the end of loading message and then      have to go and check it out.                                                                                                                                    Initially, I filled the screen with rows of the letter "U" (hex code 55),       because of the sequence of bits (ie 01010101). However, this did not seem to    matter much so I changed it for character "+" to give an easy visual display.   This produces a grid like display, which highlights the smallest error.                                                                                         Sparing no expense, here are two Basic routines. The first, "Test Card",        produces the display on a yellow background and saves ten copies on tape.       The second routine, "Test Tape Loading", tests the loading by repeatedly        loading the "Test Card" files. Set the tape to the first "Test Card" file       and it will load it. Tap a key and it will                                      clear the screen and load the next "Test                                        Card" file, each time leaving sufficent room                                    for any error report to appear without                                          scrolling the display. It will continue to                                      to do this until you run out of the files,                                      or press key "Q" for quit. The routines                                         could be improved, for example by displaying                                    the error counter and there is no need to                                       limit the Test Card to just ten files, you                                      could fill a tape.                                                                                                                                              All this made it quick and easy for me, to                                      run through all the combinations of tone and                                    two volume settings, to get the best                                            possible setting and also make the                                              occasional check to see that the tape                                           recorder was up to scratch. Well that's it                                      for this month. I hope that you found it                                        interesting and useful....See you next month.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  