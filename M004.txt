          Machine Code for the Oric Atmos (Part 17)   Peter N. Bragg
          -------------------------------                                       

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming on the Oric. Last time in Part 16 of the series, all that we have   seen so far was summarised and put together, to provide a small, simple         machine code programming kit. This consisted of an Instruction Subset, that     is a list of just five essential instruction types, plus two Operating System   calls that make it possible to read the keyboard and write to the display       screen. Also included, was a reference columm to locate information on the      various items, if required.                                                                                                                                     

Back to the Drawing Board                                                       ------------------------- A couple of issues ago, back in Part 15 of the        series, we looked at the Operating System call "VDU" which can display codes    put into Register "X". A short demonstration routine was shown which would      load and display three codes one after another, pausing between each, to        allow you to see what effect each one had.                                                                                                                      As I pointed out at the time, the routine worked well enough, but could         hardly be considered a good program. For those who do not have Part 15 of the   series handy this moment, I will recap briefly. Essentially, each item was      displayed using four seperate instructions, (1) to fetch the item (2) display   it (3) read the keyboard and (4) wait for a key to be pressed. Instructions     (3) and (4) created the pause for observation. These four instructions were     repeated each and every time a new code was fetched for display. This meant     that no less than twelve instructions were needed to display just three codes.                                                                                  It should be obvious that if the routine was extended in the same way to        display many more items, it would soon become enormous and clumsy and waste a   lot of your time and Oric's memory.                                                                                                                             Now if you look at that original routine, you will see that only the "fetch"    instruction changed, the remaining instructions (2), (3) and (4), which         display the item and provide the pause, are exactly the same for each item      displayed. It would be far better to make those three into a short subroutine,  which could then be called up with a single instruction. After all, that is     what we would we would do if we were writing Basic.                                                                                                             This precisely what has been done in the new listing presented here. You can    enter it into the Oric using an assembler, or in hex code form, using the       "Hexload" program from Part 7. Once again, to use it, just CALL#1010 and then   tap the Space Bar a few times to display the contents of Parameter Block 1001   at the cursor. The display codes used in this sample, illustrate how the        "Newline" operation is done, but of course, you can try other combinations in   the Parameter Block, to see how the "VDU" call handles them.                                                                                                    

Why make changes ?                                                              ------------------ The main point of this article was to show how programming   can be made easier, in this case by using a subroutine. For a start you have    less writing to do and there is a saving of memory space. More important, it    should make the program easier to understand as well.                                                                                                           Of course this "Display Operation" is only a small demo program and the         improvement is small too. Most of our demo programs need to be small so that    they can be accompanied by an explanation of what actually is being             demonstrated. Even so this version displays twice as many items as the          original version, for only a small increase in size.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Using subroutines for repetitive operations in programs, will considerably                                       reduce the program size, particularly when larger programs are being written. However, more useful to us at this moment, is how a subroutine like this can also be used to simplify the programming.                                                                                                                                       This new version of "Display Operation" now only needs two instructions for each                                        code item displayed and furthermore, the essential description for each item has                                         been cut down too. A good program description is essential, but it is best                                        to keep it as small as possible. The "Display & Pause" operation is described                                        in the subroutine and need not be repeated elsewhere. When the subroutine is called into use, we only need to note briefly how it is being used, which is easier. This of course applies to all subroutines, they only have to be described in detail once, any instruction that calls one, only needs  a brief note of how that subroutine is being used, which makes the program easier to write and understand.                                                                                                                                        While this version of "Display Operation" is an improvement on the original shown in Part 15, I should of course point out that it is far from perfect and could still be improved upon. However, that is not the point of the excercise. The aim was to show that some improvements can be quite easy to make.                                                                                                                                                   It is well worth looking at your program with a critical eye, with the aim of                                            making some improvements, but dont expect to write super efficent programs all the time and if you are just starting out on machine code programming, dont even bother to try for perfection, it isn't worth the effort. The most important thing to concentrate on when writing machine code programs, is to make it work first.                                             Cleverly written programs are useless if they dont work. Once you have a working                                         program and have saved it, you can then try improving on that. Stick to making                                          simple improvements like the one shown here, usually they are the most effective,                                      anyway. If you are too clever, you will have a heck of a job when you want to                                           update and improve your software later.                                                                      Next time will not be next time, it'll be the month after, if you see what I mean !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   

Oric - Demo        Display Operation         8 Apr 92                           -----------        -----------------         --------                           [ CALL#1010 ]------------[ DISPLAY SIX ITEMS ]-------
                   
                        ---Parameter Block 1001---                              1001:41       : "A"      :                                                      1002:42       : "B"      :  Six ASCII code                                      1003:0A       : <LF>     :   items for the                                      1004:44       : "D"      :     display.                                         1005:0D       : <CR>     :                                                      1006:46       : "F"      :                                                                                                                                               

         ---start---    ---Pause to check screen---                             1010:20 43 10 : JSR 1043 : Wait for a keypress.

                        ---Display Item 1 ---                                   1013:AE 01 10 : LDX 1001 : Load item 1 into Reg "X"                             1016:20 40 10 : JSR 1040 : and display it, then
                           pause to check screen.                                                                                                                                      

                        ---Display Item 2 ---                                   1019:AE 02 10 : LDX 1002 : Load item 2 into Reg "X"                             101C:20 40 10 : JSR 1040 : and display it, then
                           pause to check screen.                                                                                                                                      

                       ---Display Item 3 ---                                   101F:AE 03 10 : LDX 1003 : Load item 3 into Reg "X"                             1022:20 40 10 : JSR 1040 : and display it, then
                           pause to check screen.                                                                                                                                      

                        ---Display Item 4 ---                                   1025:AE 04 10 : LDX 1004 : Load item 4 into Reg "X"                             1028:20 40 10 : JSR 1040 : and display it, then
                           pause to check screen.
            
                        ---Display Item 5 ---                                   102B:AE 05 10 : LDX 1005 : Load item 5 into Reg "X"                             102E:20 40 10 : JSR 1040 : and display it, then 
                           pause to check screen.

                        ---Display Item 6 ---                                   1031:AE 06 10 : LDX 1006 : Load item 6 into Reg "X"                             1034:20 40 10 : JSR 1040 : and display it, then
                           pause to check screen.

                        ---Finish---                                            1037:60       : RTS      :  Exit back to Basic.
          ---end---

[ JSR 1040 ]-------------[ DISPLAY ITEM & PAUSE ]----
         ---start---     : Enter with item in Reg "X"                           1040:20 7C F7 : JSR F77C : Use OS "VDU" to display
                           contents of Register "X".
                        ---Pause to check screen---                             1043:20 78 EB : JSR EB78 : Wait for keypress (GTORKB)                           1046:10 FB    : BPL 1043 :  read keyboard until then.                           1048:60       : RTS      : Return to calling routine.
          ---end---


             Machine Code for the Oric Atmos (Part 18)   Peter N. Bragg
             -------------------------------                                          

It ain't what you do, it's the way that you do it !                             --------------------------------------------------- and this time we are        going to do something different. So far these articles have concentrated on     the programming instructions, what they do and how they work. This is           essential at first, because obviously it is neccesary to have something         which can be used for programming, before we start looking at programming       techniques, particularly as I know that many of us are baffled by machine       code (or assembly)programming. However, this months article may well be of      more general interest. As this is to be an extended issue, I decided to use     the opportunity to look at one of the programming techniques that I have        found very useful over the years.                                                                                                                               First of all, the usual brief recap. We have looked at the basic                requirements for machine code programming on the Oric. In Part 16 of the        series, what has been covered so far was summarised and put together, to        provide a small programming kit. It consisted of an Instruction Subset, in      this case, a list of five essential instruction types, plus two Operating       System calls to read the keyboard and write to the display screen. In Part      17, we had a brief look at the use of sub-routines, using a short display       routine as an example.                                                                                                                                          

So How Do You Write Software ?                                                  ------------------------------ Like many things in life, programming isn't      just a case of reading the instructions. If you are familiar with Basic or      any other language you will know by now, that a lot depends on the technique    that you use, when programming. Just like Basic, machine code programming       can be made a lot easier, if you go about it in the right way.                                                                                                  Of course everyone has their own ideas about the "right way" to do things.      If you are a beginner you may find this a little confusing at first, but if     you are prepared to have a go and keep to fairly small projects at the start,   you will soon find that it is not half as difficult as you thought. Have a      good look at other peoples programs. One thing, that particularly applies to    programming is that there are often several different ways of doing the same    thing. If they get the right results, they are all correct, so use the          method that you find most suits you.                                                                                                                            I made the point in previous articles that it is better to break up any         program that you intend to write into a series of small operations or           routines, because it is much easier to write and test several small routines    individually, than one large one. Obviously, the longer the routine, the        more mistakes there are likely to be in it. The more errors you have, the       more difficult it is to find them. You can safely say that two errors are       four times as difficult to correct as one error and it gets far worse if you    add even more errors.                                                                                                                                           Small routines are much easier to write and test and once they are working      it is easy to link them up, using JSR instructions so that they can all be      called up as one large routine. That routine itself, can then be called up      by other routines and so on. It is like the the old saying "Big fleas have      little fleas and so on ad infinitum".                                                                                                                           We have covered this point before, but it appears to have a snag. What about    very large programs ? If we want to write a super game or database, how do      we keep track of dozens of small routines, some of which, may call others ?     In fact, there is an easy solution and that is what we are going to look at.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

Organising Memory                                                               ----------------- With a memory like mine, chance would be a fine thing !!      However, this is not personal memory, it is the silicon variety installed in    the Oric. For most of us, it consists of some forty eight thousand bytes        worth. Some of this has been organised for us already by the Oric's             manafacturers and by the original 6502 chip designers, but this still leaves    plenty of room for our own programs and devices.                                                                                                                You will find that computer designers and manafacturers have a tendency to      organize memory in blocks of 256 bytes. However odd the value 256 may seem      in decimal, it soon becomes a nice round figure of 100 bytes in hexadecimal.    Most human beings prefer to use round numbers, rather than odd values like      256 or 128 and this helps to make the hex numbering system easier to use. We    have already met hexadecimal in our machine code instructions and have also     used it for the instruction address/locations.                                                                                                                  Main reason given for using hex, up to now, has been that it makes the          program instructions easier to write. In fact it also makes a lot of other      things easier too. A block of 100 hex bytes is quarter of a "K", so four        blocks are exactly 1K of memory. These blocks of 100 bytes each are usually     referred to as "Pages" and they always start from the first address in the      memory, which of course is address 0000 and go on upwards from there. This      system of dividing the memory up into "Pages" is quite common particularly      in machines using the 6502 chip.                                                                                                                                

It works like this -                                                                "Page 00" runs from address 0000 to address 00FF,                               "Page 01" runs from address 0100 to address 01FF,                               "Page 02" runs from address 0200 to address 02FF and so on ........
               all the way through the available memory.
                                                                                                    Because the memory is divided up in this way, it is easy to dedicate certain    "Pages" to specific purposes. The 6502 microprocessor designers themselves      earmarked "Page 00" and "Page 01" for use with certain instructions and this    applies to all computers that use the 6502 chip, whatever the machine.                                                                                          Oric's manafacturers have also reserved certain "Pages" for specific            purposes. For example, "Page 02" and "Page 04" are mainly used for Operating    System and Basic purposes and "Page 03" is dedicated to the Input/Output        facilities. The "user memory" starts on "Page 05" and this, of course, is       where the Basic programs normally start from.                                                                                                                   Now the "user memory area" is quite large and uncommitted and is normally       free for you to use in any way you wish. The usual way this is used is to       start from one end and carry on writing until the software is finished. This    puts a large slab of miscellaneous code into memory which can be a bit          incomprehensible in that form. OK, so you may have a listing, but surely        we can do something to make things a bit easier than that.                                                                                                      I personally, am not keen on the idea of lots of rigid organisation for         everything, particularly with respect to programming. However, a small          amount of organisation can be a great help, but it must be flexible enough      to cope with a lot of different types of program and even more important, it    must be easy to use or you will find that you cant be bothered to use it.                                                                                       The system of dividing the computer memory up into "Pages" fits the bill in     both these respects for my own programming so I have borrowed the idea for      my own use.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

One from the "Beeb"                                                             ------------------- A simple trick that I picked up from the BBC Micro, is      to start by clearing the whole "user memory", by setting every location's       contents to 00. Every "Page" start location is then marked by setting the       contents of that address to FF. The original BBC "B" also did this every        time it was switched on and to give credit where it is due, the                 manufacturers, Acorn, really had the "Page" system down to a fine art. I        found this such a useful idea that it was one of the first things to be         installed in the Oric, when I got that. This is now done automatically by a     small routine in the Oric's boot file. It is not absolutely neccesary, but I    found that it is very useful, particularly if you use a toolkit utility         which shows the memory contents in ASCII character form.                                                                                                        

Write from the start                                                            -------------------- I never set out to write the whole program from start      to finish, so it isn't really neccesary to do a lot of detailed planning at     the start. Instead, I sketch out the idea in brief and then work out what       essential operations I need to get started. Operations such as - clear the      screen, set up the display, read the keyboard, etc, are obviously going to      be needed for any program, but some of these only consist of a few simple       instructions and in my case some may have been written already for earlier      software projects.                                                                                                                                              Inevitably, some essential operations will need something new and these are     usually tackled first. The idea is to get the smallest and most vital           part of the software working first and then build up around that. This is       much easier than trying to tackle the whole project in one go.                                                                                                  As the project progresses, quite a collection of small routines builds up,      but this is no problem, because this is where the "Page" system becomes         useful. I aim to put as many routines on a "Page" as possible, although I       try to leave at least three bytes between each routine when writing them. I     also try to put related routines together. For example, one "Page" might        hold display routines and another would be for control routines. This makes     it easy to give the "Page" a meaningful label in addition to its Page Number.                                                                                   The idea behind all this is to break up the program and it's listing, into      small packages, which are then much easier label and handle. Once all the       routines in a "Page" have been written and and tested to make sure that they    are operating correctly, they can be used as "fit and forget" packages, for     the program being written. Not only that, but they are also readily             available for other software projects too, which can save a lot of time in      the future.                                                                                                                                                     If you ever thought that all machine code/assembly programming has to be        done bit by bit and byte by byte, forget it. Just like any other language,      if you go about it in the right way, you can build up a library of routines     which can be used again and again, in future software projects. The great       advantage of such a library of machine code routines is that you can design     them to suit yourself, knowing that they are likely to be far better in         that respect than software designed by someone else.                                                                                                            

Fitting it all in                                                               ----------------- Obviously, some routines will require storage for data        (variables). I usually make the first 16 bytes (00 - 0F) of a "Page" into a     parameter block for data and start the first routine at address 10 of that      "Page".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         For example, if you look at most of the programs that have been used so far,    in this series, you will see that they start on "Page 10" at address 1010       and any data required is put into a block in the area 1000 - 100F. Another      thing, I usually reserve first location after the "Page Marker", that is the    address ..01 for immediate input, for example an item from the keyboard,        although I do try to avoid making too many hard and fast rules.                                                                                                 A "Page" of 100 bytes (256 decimal) is usually sufficent to hold several        routines and all the data (variables) required, but of course there will        always be the exception to the rule. This is why any system used for            programming must be flexible. For example, some routines may turn out to be     very much larger than a "Page". The answer is simple, just combine two or       more "Pages" to provide as much room as you require. The same applies to        data, if you have a large amount, use the whole "Page" or even combine          several "Pages" if you need the space.                                                                                                                          There is one example of a routine which might require more than one "Page".     In Part 13 of the series, we looked at a routine called "Control Select"        which sorted out commands, from the key board. We only used four keys in        that demo routine, but as I pointed out at the time the number of keys that     could be used is only limited by the keyboard and your imagination. One         piece of software that I have written, used this routine to sort nearly         thirty key commands. Two "Pages" were combined to provide the room. This        might appear to go against the advice to "keep it small", but in fact if you    look at the routine in Part 13, you will find that it essentially consists      of successive repeats of the same set of four instructions. Only the key        code and instruction addresses change.                                                                                                                          

Getting it down on Paper                                                        ------------------------ Much of the above will be a waste of time if you       dont have a good way of making and storing hardcopy (paper) listings,           because if you are going to make use of your "library" of useful routines,      you will find it much easier to check out the listings on paper, than on the    screen, when you need to refer to them.                                                                                                                         I dont list the whole program in one go, instead I use a seperate listing       for each "Page". Each "Page" has a single sheet which lists all the main        routines in it. Any program is therefore just a collection of its "Pages",      so those lists of routines, when put together, are in fact the program          listing. This makes it a lot easier to follow than say a Basic listing. The     real trick is to provide a good label for each routine, using no more than      three or four words.                                                                                                                                            The complete "Page" listing pack is simply made up from seperate sheets of      5" x 7" notepaper (203mm x 127mm), held together with a paper clip. As          several of these can fit into a small notecase, I dont end up awash in a sea    of fanfold paper, when programming away from home.                                                                                                              Using seperate sheets makes it easy to remove or modify parts of listing and    I should emphasise that all listings are made on one side of the paper only,    so that the listings can also be spread out for easier reading. All this is     done in order to build up a collection of useful software instead of having     to start from scratch each time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                The individual listing sheets are often written in pencil, some are             dis-assembled onto the Oric printer with pencilled in descriptions and some     are written and printed out using the smaller "Elite" characters on the dot     matrix printer.                                                                                                                                                 Every sheet in the listing pack is headed by three items of information.        These are the "Page" label, the date the software was started and the           computer it was written for. That last item is required because a lot of my  888BBC Micro software was written on the Oric (and vice versa), likewise some      for the Apple 2e. This prevents mix-ups and the instruction addresses also      indicate in which order the sheets are clipped together.                                                                                                        So thats it, how to keep that mass of code readable and save having to write    the same old routines again and again. Now for something very different.....                                                                                    

RGB Monitor Adaptor                                                             ------------------- As mentioned above, I use more than one type of computer    and it is not unusual for me to swap from the Oric to another machine and       back again, several times in a few hours. In order to save a lot of messing     about at the back of the RGB monitor, I have made up a small inline adaptor     which changes the Oric's RGB socket into a BBC Micro socket. This means that    I can use a standard BBC Micro RGB lead (either type, DIN or Scart) into a      BBC compatable RGB monitor.                                                                                                                                     Accessories for the BBC Micro are easier to obtain than those for the Oric,     so the adaptor may well be of interest to other Oric users. A wiring diagram    for it is shown below and the illustration shows the soldered side of the       Oric plug and BBC socket. An "inline" socket is the best for the BBC end,       but if you cant get one, you could use the board mounted type.                                                                                                                                                                                  

Pin Numbers   (1) Red                                                           -----------   (2) Green
              (3) Blue
              (4) Sync
              (5) 0v (Ground)
              (6) Not used.                                                                                                                                                                                                                                                                                                     The monitors I use are the Philips 8533 and the Philips 8833. There are many versions of these also with badges for Commodore, Atari and Acorn computers to name just a few. There are also at least three case styles.                                                        In general the 8833 tends to be a bit cheaper and has two speakers. The 8533 has one speaker, but it also has composite video input, useful if you have a camcorder.                                                                                                                                 With regard to other monitors, I am told that the BBC Micro can be plugged straight into the Amstrad CPC 464 colour monitor, which suggests that it too could be used with the Oric, but I have no experience of that one.                                                                                              

Next time.................we shake a few more bytes out onto the carpet !!

                                                                                                                         		Machine Code for the Oric Atmos (Part 19)   Peter N. Bragg                      		-------------------------------                                          

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming on the Oric. In Part 16 of the series, what had been covered so     far, was summarised and put together to provide a small, simple machine code    programming kit. This consisted of a small Instruction Subset, basically, a     few essential instructions, plus a couple of Operating System calls to read     the keyboard and write to the display screen. A reference columm was            included to locate information on the various items, if required. Since then    we have had a brief look at the use of sub-routines and also how to organise    our programs in order to make them easier to write.                                                                                                             

Now for some clever bits !                                                      -------------------------- Up to now, the series has concentrated on            providing a very basic kit of machine code instructions for simple              programming. Because such a "kit" is so basic it makes some programming a       little bit clumsy and long-winded. Now that hopefully, we all understand a      bit more, we can start to add some useful extras to our instruction "kit".                                                                                      

Counting on it                                                                  -------------- The ability to add 01 (Increment) or subtract 01 (Decrement)     from a value can be very useful if you are thinking of producing a counter      or timer, so this time we will have a look at instructions with this in mind.   Obviously timers and counters are useful for games software and they also       have many other uses too. Let's have a look at simple counters first and how    they can be made to count up or down.                                                                                                                           The first item that we can look at is the Accumulator. Strictly speaking,       the Accumulatator cannot be incremented or decremented directly with a          single instruction, or at least, not on the standard Oric.                                                                                                      There are some versions of the 6502 microprocessor, with extra instructions,    including some that do increment and decrement the Accumulator contents.        I have heard that it is possible to fit one of these 6502's to the Oric, but    of course there is a snag. If you do this and then use any of those extra       instructions in a program, it will automatically become incompatible with       the majority of machines, that use the 6502 microprocessor. For me, that        compatibility with all 6502 machines is one of the advantages of using          machine code and is worth more than a small increase in efficiency, but of      course this is a matter of personal choice.                                                                                                                     Probably, the best way to increment or decrement the Accumulator contents,      is to use the ADC and SBC instructions, which we met back in Part 6 of the      series.                                                                                                                                                         However, the Accumulator is the most useful register in the Oric's 6502 and     it would be a bit of a waste to tie it up, with a simple counting operation.                                                                                    There are two other registers that we can use for this purpose. These are       Register X and Register Y.                                                                                                                                      

Register X                                                                      ---------- We met Register X back in Part 15 of the series, when we were        looking at the Operating System display call "VDU". Register X, was used by     that particular call. Up to now, the series has used Register X just for        storage purposes. In fact Register X is far more useful doing other things,     rather than just providing simple storage.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

Register Y                                                                      ---------- This is essentially the twin brother of Register X, described        above. In many respects, Register X and Register Y are very similar to each     other in operation. Register Y also holds one byte which can be loaded and      stored in the similar fashion to the Accumulator and Register X. For            Register Y, the loading and storing instructions are LDY and STY.               Hopefully by now, you should be able to see what those abbreviations mean,      by comparing them with those for Register X.                                                                                                                    

"Counter X" and "Counter Y"                                                     -------------------------- One advantage of both Registers, is that either      of them can be incremented or decremented by using the appropiate single        byte instruction. This is very useful and makes it very easy to set up          either or both Registers as simple counters.                                                                                                                    One thing you should remember is that they can only hold one byte each, so      they can only count up to a maximum of 256 decimal or FF in hex. This means,    for example, that if Register X contains FF and you increment it (add 01),      it's contents will go to 00. Likewise, if Register X contains 00 and you        decrement it (subtract 01), the contents will go to FF. So if you               continually increment the one byte value, it will eventually reach the stage    where it goes FD, FE, FF, 00, 01, 02 and so on. If you decrement it instead,    it will go the other way ie. 02, 01, 00, FF, FE, FD etc. This effect is         known as wraparound and happens to both hex and decimal values.                                                                                                 The usual thing is to have some way of testing the value in the Register        that you are using as a counter, so that you know when it reaches the           required value. There are two ways of doing this. You can either start at       zero (00) and increment and test until it reaches the required value, or you    can load the required value into the Register and decrement it until it         reaches zero (00). The second option is usually favourites, because it can      use the Zero Flag in the Status Register to produce a Branch jump at the        appropiate time, without the need to test for the zero value.                                                                                                   The two instructions for incrementing and decrementing Register X are INX       and DEX, which are abbreviations for INcrement X and DEcrement X. These are     single byte instructions and their instruction opcodes are E8 for INX and CA    for DEX. Likewise, the instruction, INY (opcode C8) increments the contents     of Register Y and the instruction, DEY (opcode 88) will decrement them.                                                                                         

Thanks for the memory !                                                         ----------------------- The registers are not only thing that can be used as    a counter. You can also use the contents of a memory location. In this case,    the increment and decrement operation needs a three byte instruction each.      The first byte is the instruction opcode as usual and of course the other       two bytes are the address of the memory location that you are using for a       counter. As each memory location only holds one byte, the same rules apply      as for Registers X and Y. Once again, the value wraps around from FF to 00      when incrementing and vice versa, when decrementing.                                                                                                            

Lots and Lots !                                                                 --------------- A one byte value of 256dec/100hex may not sound much, but of    course, you can always couple two or more counters together in order to         multiply that value. With two counters for example, you can count from 00 to    FF on one counter and increment a second counter once for each time the         first counter goes from 00 to FF. This pairing will count up to                 65536dec/FFFFhex and of course the more one byte counters that you couple       together in this way, the higher they will count.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

We appologise to passengers for the short delay !                               ------------------------------------------------- Essentially, a timer          (or clock) works by producing a short but accurate time delay period,           repeating it over and over again and recording those repeats, by                incrementing (or decrementing) a counter. The time delay period in a clock      can be produced in many ways, by vibrating a crystal or swinging a lump of      lead (I know of one or two people who can do that too !!). The Oric has a       crystal which provides very accurate timing for instructions, but this          produces one million ticks a second. (I hope that there are no cattle           farmers reading this !!). One the simplest timing routines is the one shown     below, which works by using Registers X and Y to count up the number of         times that a short sequence of instructions is used.                                                                                                            Oric                       Demo Routine                           19 Sep 92     ----                       ------------                           ---------     [ CALL#1010 ]--------------[ TIME DELAY LOOP ]------------------------[ / ]                                                     

         ---start---      ---Starting Gun---                                    1010:20 B5 FA : JSR FAB5   : Fire ! they're off !!

                          ---Set X and Y Counters---                            1013:A2 FF    : LDX# 256   : Set X          Set both for                        1015:A0 FF    : LDY# 256   : Set Y        maximum time period.

                          ---Countdown Y---                                     1017:88       : DEY        : Decrement Y (-01) then                             1018:D0 FD    : BNE "1017" : if Y not zero - back to Decrement Y again.
                             if Y  is zero - continue on to.......
                          ---Countdown X---                                     101A:CA       : DEX        : Decrement X (-01) then                             101B:D0 FA    : BNE "1017" : if X not zero - back to Decrement Y again.
                             if X  is zero too - finish.....

                          ---Finish---                                          101D:20 B5 FA : JSR FAB5   : Shoot again to mark the finish.                    1020:60       : RTS        : Exit.
          ---end---
                                                                                                                                                                                                                             The above routine is in fact two counters or loops. The "Countdown Y" is the    short one and "Countdown X" is the long one, with respect to time. Like a       small gear wheel in a clock, Register Y whizzes round, through the complete     range of one byte values. whereas the Register X is slower and only moves       one notch for each complete cycle of Register Y. The start and finish are       marked by one of the Oric's sound effects. The delay produced by the two        counters is about quarter of a second, during which, they count up to 65536 !
         -----------------------------------------------------                 It was great to be there at the 1992 Oric meet in July and nice to be able      to talk to other Oric users face to face and meet people who are usually        just names in the pages of O.U.M. I now have an Oric badge to wear at "Acorn    User Show". There was much to see and hear about. There were useful tips on     self defence from Judy Simms and an interesting chat with Jim Patterson all     the way from Scotland, not too mention the Daves D & W, Jon H and Allan,        some interesting software from Jonathon Bristow and much more. I was            surprised at the interest in the ancient Microtan, pity the tape loading was    temporarily on the blink ! If you missed it all, make a date for next year      and join the fun. To Dave and others who put it all together, thanks a lot !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

		Machine Code for the Oric Atmos (Part 20)   Peter N. Bragg                      		-------------------------------                                          

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming on the Oric. In Part 16 of the series, what had been covered far,   was summarised and put together to provide a small, simple machine code         programming kit. This consisted of a small Instruction Subset, basically, a     few essential instructions, plus a couple of Operating System calls to read     the keyboard and write to the display screen. Since then we have had a brief    look at the use of sub-routines and also how to organise our programs in        order to make them easier to write. Last time, we looked at some new            instructions and used a few of them to write a short delay loop routine.                                                                                        If you had a go at last months demo routine, you should have managed to get     Scotland Yards Anti-Terrorist squad off your doorstep, by now !! In the         routine as listed, there should have been about quarter of a seconds delay      between the two gun shots, which marked the start and end of the delay loop.    Changing the value of Register Y, should make no noticeable difference to       the delay time, but changing Register X will do so, although you can only       reduce the time delay. That is because the routine had Register X set to the    maximum value. If you need to increase the time delay, you will need to use     a third counter. In this case, the only practical option is to use a memory     location as the third counter.                                                                                                                                  The instructions, we looked at last month, were mainly concerned with           incrementing (add 01) and decrementing (subtract 01) operations. While I        concentrated on their use for counters and timers, this was only done for       demonstration purposes. The incrementing and decrementing instructions are      also very useful for other kinds of programming operations, as you will see,    later on. If you use Basic, you only need to think of how useful operations     such as LET X=X+1 or LET N=N-1 are, when programming in that language.                                                                                          Something else mentioned last time, was the fact that you can also increment    or decrement the contents of any location in RAM, in the same way as            Registers X and Y. The instructions that do this are three bytes long, as       they obviously need to contain the address of the location that is used. To     demonstrate this, you will find that the "Time Delay Program" used last time    has been extended in this issue to include a third counter, which makes use     of a single memory location for that additional counter. Let's have a look      at how it works.                                                                                                                                                

"Timed Delay" Demo Routine                                                      -------------------------- The program has now become two routines. A           slightly modified version of the routine used last time is now used as a        sub-routine, but it is still the same operation as the original "Time Delay     Loop", so we we can look at this first. This routine has now been relocated     to start at location 1030. The two "gun shot" markers have been removed and     transferred into the the new calling routine instead, so that they can also     be used to mark the effect of the third counter as well.                                                                                                        One or two improvements have been made. The routine now uses "Absolute"         instructions (in 1030 and 1033) to set Registers X and Y, instead of the        "Immediate" instructions previously used, so we can now set Registers X and     Y from locations 1004 and 1005 in the Parameter Block 1000.                                                                                                     As the third counter is set in location 1003, it alows the delay period to      be set to anything from a few micro-seconds to over a minute and a half, by     simply adjusting the values in Parameters 1003, 1004 and 1005.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  The operation of the "Time Delay Loop" routine is exactly the same as last      time. Registers X and Y are set and then Register Y is repeatedly               decremented by the operation of instructions 1036 and 1037, until it reaches    zero. That then sets the Zero Flag in the Status Register which disables the    BNE Branch instruction at 1037 breaking the loop that is decrementing           Register Y. This allows the computer to procede to the next operation, which    is to decrement and test Register X. However, that is done once only and if     Register X is not zero the routine will branch back to reset and restart        decrementing Register Y again. So the effect is that, every time the            contents of Register X are reduced by 01, Register Y has to go through a        complete cycle of being set and then decremented to zero again, until           eventually the contents of Register Y and Register X are both zero.                                                                                             One other small modification to this routine. The aim here, is to allow         Register Y to be controlled by any value that you wish to set in Parameter      1005. So in this version, the second Branch needs to go back to reset that      value each time before starting to decrement it again. otherwise Register Y     would always reset to FF irrespective of any value set in Parameter 1005.                                                                                       In the previous version of "Time Delay Loop", the second Branch instruction     looped straight back to decrement Register Y, as that routine was intended      to make use of a fixed value (FF) for Register Y. This worked fine, because     subtracting 01 from Register Y, when it contains zero (00) automatically        makes its contents FF again, which was just what we needed. If this is still    not too clear, have another look in the last issue at what was said about       "wraparound" and then look again at both versions of this routine.                                                                                              As it stands the routine can be operated on its own, by using CALL#1030 or      alternatively, it can be incorporated into a program, by using the              instruction JSR 1030. By itself, it just produces a silent delay of about       quarter of a second, as set up. However we now have the second routine,         "Timed Delay" CALL#1010 which makes use of it to demonstrate a third counter    using a memory location in Parameter Block at 1002.                                                                                                             Once again, this new routine is started and ended with a "gun shot" sound       effect. For the counter, we could of course, just decrement the value loaded    into Parameter 1003, but this would make the routine a once only operation,     which is not very useful, so instead the first operation (at 1013 and 1016)     is to copy the value set in Parameter 1003 into the location that we are        going to use as our third counter, that is Parameter 1002.                                                                                                      Instructions 1019 to 101E fetch and test a copy of the third counter to see     if it is zero. If it is not zero, it is decremented by instruction 1020 and     then the "Time Delay Loop" JSR 1030 is called up to produce a preset short      time delay. After that the routine jumps back to test the counter again. So     each time the third counter is decremented, there is a short preset time        delay and the third counter controls the number of short time delay periods     which make up the whole time period between the two "gun shot" markers. Note    that the BEQ Branch instruction is disabled and has no effect at all, on        these operations, until the third counter's contents match the value tested     for by the CMP instruction at 101C. When that happens, the Zero Flag is set     and the BEQ Branch becomes active and the routine branches off to the finish.                                                                                   Notice too, that the Branch instruction here is a BEQ which works the           opposite way round to the BNE Branches used in instructions 1037 and 103A.      Setting the Zero Flag (to "1") disables BNE instructions and activates BEQ      instructions. Clearing the Zero Flag (to "0") disables BEQ instructions and     activates BNE instructions.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  In fact this is not the only way of doing this operation,but it is probably the best wayto demonstrate how it works. As you saw with "Time Delay Loop" it is not always neccesary to fetch an item to check it for a zero value, but instructions, 1010 to 102C, hopefully make it easier to follow.                                                                           Of course, if we wanted to use Registers X and Y for another purpose, we could make all three counters use locations in memory instead, in the same way                                                 as has been done here with the third counter only. However, the main reason for using Registers X and Y here, was to demonstrate the three differentinstructions, for decrementing a value. Incrementing works in the same way, it simply adds 01 to the value instead of subtracting it. We will be seeing this in action, fairly soon.                                                                                                                                                           Incidentally, while this timer routine was only intended as a demonstration of the decrementing (and incrementing)instructions, I should perhaps mention, that this type ofcounter/timer is fairly accurate and quite useful. It can be influenced slightly by the Oric's Operating System operations. However, for most                                                   purposes, the effects of that are hardly noticeable.                                                                Oh well, so much for the rifle practice......................................next time we look at the real target !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

Oric                  "Timed Delay" Demo Routine                   3 Oct 92     ----                   ------------------------                    --------     [ CALL#1010 ]--------------[ DATA ]-----------------------------------[ / ]

         ---start---      ---Parameter Block 1000---                            1000:FF       :            : "Page" marker (optional Ref. Part 18)              1001:00       :            :                                                    1002:00       :            : 3rd Counter                                        1003:10       :  16 dec    : Delay Value setting for the third counter          1004:FF       : 255 dec    : Setting for Register X                             1005:FF       : 255 dec    : Setting for Register Y
          ---end--- 
                                                                                                                                            [ JSR 1010 ]---------------[ TIMED DELAY ]----------------------------[ / ]
   
         ---start---      ---Starting Gun---                                    1010:20 B5 FA : JSR FAB5   : Shoot, they're off !!

                          ---Set Counter in Reg 1002---                         1013:AD 03 10 : LDA 1003   : Fetch Delay Value setting (Param 1003) and         1016:8D 02 10 : STA 1002   :   put it into the 3rd Counter (Param 1002)

                          ---Continue or Finish ?---                            1019:AD 02 10 : LDA 1002   : Fetch Counter (Param 1002)                         101C:C9 00    : CMP# 00    :  Test - is it at zero yet ?                        101E:F0 09    : BEQ"1029"  :   Yes - so skip to finish now.
                               No - so continue....

                          ---Update Counter/Make Brief Delay---                 1020:CE 02 10 : DEC 1002   : Decrement Counter (subtract 01 from it)            1023:20 30 10 : JSR 1030   :  then wait for one Timed Delay Loop period.        1026:4C 19 10 : JMP 1019   : Now go back to test Timer Counter again.

                          ---Finish---                                          1029:20 B5 FA : JSR FAB5   : Shoot again to mark the finish.                    102C:60       : RTS        : Exit.
          ---end---

[ JSR 1030 ]---------------[ TIME DELAY LOOP ]------------------------[ / ]
                          ---Set X and Y Counters---                            1030:AE 04 10 : LDX 1004   : Set X using contents of Param 1004                 1033:AC 05 10 : LDY 1005   : Set Y using contents of Param 1005

                          ---Countdown Y---                                     1036:88       : DEY        : Decrement Y (subtract 01 from it) then             1037:D0 FD    : BNE "1036" : if Y not zero - back to Decrement Y again.
                             if Y  is zero - continue on to.......

                         ---Countdown X---                                     1039:CA       : DEX        : Decrement X (subtract 01 from it) then             103A:D0 F7    : BNE "1033" :  if X not zero - back to set Y countdown again.
                              if X  is zero too - finish.....
                         ---Finish---                                          103C:60       : RTS        : Exit.
          ---end---                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         