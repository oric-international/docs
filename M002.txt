		Machine Code for the Oric Atmos (Part 7)    Peter N. Bragg                      		-------------------------------                                   

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming on the Oric including the three essential registers, Accumulator,   Program Counter and Status Register. We also used a small instruction table     published in Part 5, to produce a short screen filling program. 
                                                                                                More on the Screen Fill program                                                 ------------------------------- The aim of that program was to show how small   sets of instructions can be used to build up to much larger operations. For     example the program just put crosses on the screen. However it does not take a  great stretch of imagination to realise that only slight changes are needed to  alter the program so that it would fetch a copy of all the items on the screen, instead. This could form the basis of a screen dump program.                                                                                                    Hopefully the program also illustrated the reasoning behind the use of hex code rather than decimal values. It was not necessary to do any calculations or      conversions, we only needed the start and end addresses, the Oric did the       calculating for us. Using hex only, cuts out the need for lots of different     values pre-fixed with various $, & and # signs, particularly the last one which can be confused with the widely recognised "Immediate" symbol.                                                                                                  

Conversion                                                                      ---------- Inevitably there are times when we need to convert hex into decimal  or binary etc, or back again. These conversions can be made on the computer,    using PRINT #value, PRINT HEX$(value) etc, if not listed in the manual already. If I need to convert a value, I use a table on a crib card.                                                                                                     

A bit of Cheating                                                               ----------------- This brings me to Crib Cards. I have used these right from    the time I started computing and they are one of the most useful programming    aids that I can think of. I have three cards, which were made up using the      wordprocessor on the Oric. The cards are small enough to tuck neatly away       inside a notebook.                                                                                                                                              It is amazing how much information can be printed on them using a wordprocessor and an Oric MCP 40 (or Tandy) Printer. The cards I use are 5" x 4" with a       printout on both sides and they fit neatly into a transparent film sleeve. Of   course any size card and any transparent plastic bag would be OK.                                                                                               Each 5" x 4" card can hold at least 100 lines of 80 columms of print, using     Size "0" print. This is more than enough for simplified versions of conversion  tables, essential computer systems information, plus two complete Instruction   Sets. However, the really useful thing about them is that information can be    tailored precisely to suit personal requirements and it is easy and quick to    update the cards as more experience is gained. So even when I am far away from  any computer, I can still write programs using little more than a notebook and  pencil, as all the really essential information is there on the cards.                                                                                          

Quick Peek & Poke                                                               ----------------- One requirement for machine code programming is a simple      means to read and write data and instructions in memory. On the next page, you  will find an updated version of the HexLoader program that was originally       published in Part 2 of the series. If you already have the earlier version, you can update it simply by adding lines 41 and 42, plus all of lines 300 to 390.   If you have an assembler and/or dis-assembler and prefer to use them, thats OK. Hexloader is intended for those people who have no easy access to Oric's memory

HexLoader II                                         BASIC LISTING              ------------ One of the instructions we                                         looked at and used was the Branch          
10 A=0:B=0:C=0:M=#1000:':Program to: instruction in its various forms. This     30 GOSUB 410:'          :Read/Write: can produce a relative jump, which can     40 GET B$:B=ASC(B$):'   : HexCode  : be very useful. However the jump needs     41 IF B=82 THEN GOTO 310          to be set correctly, unexpected arrivals   42 IF R=82 THEN GOTO 315          may start digital aggro !! It is fairly    45 IF B=81 THEN END                  simple to set a relative jump by just      50 IF B=13 THEN A=A-1:GOTO 30        counting, however it is much better to     55 IF B=32 THEN A=A+1:GOTO 30        get Oric to do it for you. This is the     60 IF B=72 THEN M=M+256:GOTO 30      reason for the updated version of          70 IF B=76 THEN M=M-256:GOTO 30      HexLoader, presented here.                 75 IF B<48 THEN GOTO 40 
80 IF B<58 THEN B=(B-48)*16:GOTO 190 Enter the program as listed and save it.   90 IF B<65 THEN GOTO 40              The value of "M" in line 10 sets the       95 IF B<71 THEN B=(B-55)*16:GOTO 190 first address, which should be suitable    110 GOTO 40                          for both 16K and 48K Orics. However you    190 GET C$:C=ASC(C$)                 can change the value, if you wish to       200 IF C<48 THEN GOTO 40             start at another address. If you try to    210 IF C<58 THEN GOTO 260            access memory that the Oric does not       220 IF C<65 THEN GOTO 40             have, the program will drop out. In this   230 IF C>70 THEN GOTO 40             case, just restart with RUN again.         240 C=C-55          
250 GOTO270                          The control keys are the same as before    260 C=C-48                           with three additions. When you run the     270 LET D=C+B:POKE(M+A),D            program, you will find that the first      290 PRINT CHR$(11);:GOSUB 410        thing that it displays is the memory       295 A=A+1:GOTO 30                    location at address #1000 and its          300 '---Show-Branch-destination---' 
contents. The SPACE BAR will move you on   
310 R=B:GOTO 340                     to the next address at #1001 and will      315 IF B=44 THEN E=E-1:GOTO 340      allow you to step through the memory,      320 IF B=46 THEN E=E+1:GOTO 340      showing the contents of each address in    325 IF B=81 THEN END                 succession. The RETURN Key will return     330 IF B=32 THEN R=0:GOTO 55         you to the previous address in the same    335 GOTO 40                          way, counting down, #1001, #1000, #9FF     340 IF E>255 THEN E=0                etc. This way you can scan backwards or    345 IF E<0 THEN E=255                forwards through the Oric's memory         350 POKE(M+A),E                      contents. If this is too slow and you      355 IF E>127 THEN GOTO 365           want to go to another part of the Oric's   360 K=M+A+E+1:GOTO 370               memory, far more quickly, press Key H to   365 E=255-E:K=M+A-E                  go higher, or Key L to go lower, in        370 PRINT CHR$(11);:GOSUB 410;       jumps of 100 hex bytes at a time.          375 PRINT TAB(11);CHR$(11);
380 PRINT"<--Relative Jump to ";     Key R will show the Relative Jump          385 PRINT HEX$(K);CHR$(11)           Destination of any value in memory and     390 GOTO 30                          can be used to check any Branch            400 '---Print Addr & Contents-----' instruction operand setting. Adjustments   410 PRINT HEX$(M+A);":";             to the setting can be made using the       420 E=PEEK(M+A):IF E<16 THEN GOTO440 "Comma" and "Full Stop" Keys, or           430 PRINT HEX$(E):RETURN             unshifted "<" and">". The two adjustment   440 PRINT" ";HEX$(E);                keys, if held down, will eventually        450 PRINT CHR$(8);CHR$(8);CHR$(8);   rotate through the entire range of         460 PRINT"#0":RETURN:'--Finish----' settings for that specific relative jump.                                       

The SPACE BAR will take you back to the read/write facility again. Apart from   the seven control keys, there is one other, which is Key Q, to quit the program.                                                                                That deals with Relativity.....next time, how to produce instant Black Holes !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               


		Machine Code for the Oric Atmos (Part 8)    Peter N. Bragg                      		-------------------------------                                   

The Story so far                                                                ---------------- Last month saw an updated version of the Hexloader program.    Prior to that we had looked at three of the Oric's 6502 Registers, A small      subset of just fourteen instructions was then described and tried out with a    display routine (in Part 6) which produced a fly's eye view of a fly swat.                                                                                        

Design Critic                                                                   ------------- If you look back to that Screen Fill routine in Part 6, you will  find that although it satisfies the essential requirement in that it works as   intended, it is rather limited by the way data is loaded into it.                                                                                               Curiously enough, most machine code programs I have seen, fall down badly in    this respect. My personal feeling is that it is essential to make machine code  programs easy to follow, even if it costs a few extra bytes to do so.                                                                                           

Data Access                                                                     ----------- Most programs need data to set up and control program operation.    For Basic programs, the data can be provided by using strings and variables.                                                                                    Immediate instructions are just one of several ways to provide the required     data for machine code programs. They consist of two bytes each. These are, the  operation code (opcode), immediately followed by a data byte (operand). The     data byte is normally used for the same purpose as a Basic "Variable".                                                                                          The data controlling the above mentioned Screen Fill program was essentially    the two addresses and one display character. These were loaded by Immediate     instructions. This works well enough in small compact routines, where the       operation is fairly easy to follow.                                                                                                                             However, when it comes to large routines and programs, involving a lot of data, it is obviously going to make life much easier, if it can all be gathered up    into a few specific data blocks. Using lots of scattered Immediate instructions each one, with its own data byte, can make large programs difficult to follow,  particularly if you want to make modifications to the program at a later date.                                                                                  This is where the "Absolute" instruction becomes useful. The Absolute           instruction consists of an opcode again, but this time it is followed by a two  byte address. The address is set in reverse order, low byte then high byte. The instruction will then operate on the contents of that address. For example, the Absolute LDA instruction will fetch one byte from the address and the Absolute  CMP will compare the contents of the address, with those of the Accumulator.    Absolute instructions can be set to operate anywhere in memory.                                                                                                 

Parameter Blocks                                                                ---------------- The data items that control the program operation, can be      grouped together in specific data blocks, when we use Absolute instructions for access. These data blocks can then be put anywhere we wish, for easy control.                                                                                   We need identifying labels for these blocks of data. The most popular labels    used for this purpose appear to be parameters, registers or tables etc. Early   publications, prompted me to use the second of those labels, but that could be  confusing in a series like this, so it would be better to use the term          "parameters", which often appears in Oric literature and which can also be      abbreviated to "params" if required.                                                                                                                            First, a useful demonstration of the above points. After that, how it all works.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

Oric                  Demonstration Copy Routine           15 Sept 1991         ----                  --------------------------           ------------                                                                                         Addr...Code.......Data...........Description....       "VARIABLES"                                       				  PARAMETER BLOCK 1002          -----------              1002:   A8        BBA8   :Lo: Start Address     :    "Fetch Addresses"          1003:   BB               :Hi:                   : The start and end of the                                                      								 :   area from which items       1004:   E0        BFE0   :Lo: End Address       :       are fetched.            1005:   BF               :Hi:                   :                                                                                     									 "Copy Address"            1006:   00        3000   :Lo: Start Address     : The start of the storage      1007:   30               :Hi:                   :   area for copied items.
                                                                                                                                                                      Addr...Code.....Assembly.........Description..............   COPY ROUTINE                                				  SET UP FETCH & COPY INSTRUCTIONS    ------------       1010:AD 02 10   LDA  1002: Lo : Addr for                                        1013:8D 29 10   STA  1029:    : "Fetch"         : Set the address of            1016:AD 03 10   LDA  1003: Hi : instruct        : instruction 1028 from         1019:8D 2A 10   STA  102A:    :..........       : Params 1002 and 1003                                                          								 :       and                     101C:AD 06 10   LDA  1006: Lo : Addr for        : set the address of            101F:8D 2C 10   STA  102C:    :  "Copy"         : instruction 102B from         1022:AD 07 10   LDA  1007: Hi : instruct        : Params 1006 and 1007.         1025:8D 2D 10   STA  102D:    :.......... 
                                                                                                                                               				 FETCH & COPY ITEMS TO STORAGE AREA                     1028:AD 00 00   LDA  0000: Fetch an item into Accumulator : Instruct addrs are  102B:8D 00 00   STA  0000:    Copy it into new area.      : preset by routine.                                                                                                           

				 UPDATE COPY INSTRUCT ADDRESS                           102E:18         CLC      :  Clear Carry Flag to "0"       : Sets next address   102F:AD 2C 10   LDA  102C:  Fetch 102C contents and       : in new area, for    1032:69 01      ADC# 01  :     add 01 to them, then       : next item to be     1034:8D 2C 10   STA  102C:       put them back.           :     copied.         1037:AD 2D 10   LDA  102D:  Fetch 102D contents and       : This is done by     103A:69 00      ADC# 00  :  add Carry (if any) then       : adding 01 to the    103C:8D 2D 10   STA  102D:      put them back.            : instruct 102B addr.                                                                                                          

				 UPDATE FETCH INSTRUCT ADDRESS                          103F:18         CLC      :  Clear Carry Flag to "0"       : Sets next address   1040:AD 29 10   LDA  1029:  Fetch 1029 contents and       : in old area, for    1043:69 01      ADC# 01  :     add 01 to them, then       : next item to be     1045:8D 29 10   STA  1029:       put them back.           :     fetched.        1048:AD 2A 10   LDA  102A:  Fetch 102A contents and       : Again, done by      104B:69 00      ADC# 00  :  add Carry (if any) then       : adding 01 to the    104D:8D 2A 10   STA  102A:      put them back.            : instruct 1028 addr.                                                                                                          

				 LAST ITEM COPIED YET ?                                 1050:CD 05 10   CMP  1005:  Are 102A contents same as 1005,  : Test the address 1053:D0 D3      BNE  1028:      back to Fetch & Copy if not. : of instruct1028.
1055:AD 29 10   LDA  1029:  Fetch 1029 contents and test,    : If it is Fetch   1058:CD 04 10   CMP  1004:    are 1029 contents same as 1004,: End Addr(Params) 105B:D0 CB      BNE  1028:      back to Fetch & Copy if not. : then finish/exit.                                                                                                         
                        FINISH                                                 
105D:60         RTS      :  Exit, back to Basic.  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Copy Routine Demo                                                               ----------------- The routine is an all purpose copy routine. For testing, it   has been set up so that it will copy (dump) the text screen contents into the   memory at 3000 to 3437 address. It is also easy to set up for copying anywhere  in memory. Very useful, but avoid copying over program area, or you will crash.                                                                                 Enter the routine into the computer using your favourite method (eg. Assembler).If you are using Hexloader (O.U.M. Sept 91 for update), you only need to put in the codes at the locations shown. Locations 1000, 1001 and 1008 to 100F can be  set to 00 and ignored. All codes and addresses are in hex as usual.                                                                                             To test it, have a nice cluttered up screen display then CALL#1010. To retrieve the copy, just change the addresses around in the Parameter Block, clear the    screen and CALL#1010 again. The addresses in the Parameter Block should be      changed so that the addresses of the copy area (3000 - 3437) are now used as    "Fetch Addresses" and the Screen Start (BBA8) is used as the "Copy Address".                                                                                    Notice that we are still using that same small subset of fourteen instructions  from Part 5 of the series. The operations here are similar to those used in the Screen Fill routine in Part 6. This routine is just an extended version.        To aviod too much repetition, I will keep this description fairly brief and     will concetrate on the main changes made.                                                                                                                       

What makes it tick ?                                                            -------------------- Once again the actual routine starts at location 1010, but this time it has been preceded by a small Parameter Block, starting at location 1002, which holds the controlling items (addresses).                                                                                                            

SET UP FETCH & COPY INSTRUCTIONS                                                -------------------------------- Absolute LDA instruction at 1010 copies the    low part of the "Fetch Address" from Param 1002 into the Accumulator. The STA   instruction at 1013 then puts a copy of that into location 1029. This operation is repeated by instructions 1016 and 1019, to put the high part of the address  into location 102A, all of which sets the "Fetch" instruction at 1028.                                                                                          A repeat of that operation in 101C to 1025 sets the "Copy" instruction at 102B.                                                                                 

FETCH & COPY ITEMS                                                              ------------------ This is the main operation. Once the operands (addresses)    of instructions 1028 and 102B have been set up, the LDA and STA operation will  copy one byte from one address to the other, via the Accumulator.                                                                                               

UPDATE COPY (& FETCH) INSTRUCTION ADDRESS                                       ----------------------------------------- The operands of instructions 1028 and 102B, must be updated after each "Fetch & Copy" operation, for next pair of     addresses. The two operations 102E - 103C and 103F -104D are identical. They    are also the same as that used in the earlier Screen Fill routine. They set the next pair of addresses in "Fetch & Copy" by simply adding 01 to each of the     operands. The operations are unlikely to benefit much from a change to Absolute operation so they are still using Immediate (#) instructions as in Screen Fill.                                                                                 

LAST ITEM COPIED YET ?                                                          ---------------------- This uses Absolute CMP instructions and the Accumulator. It compares the address in "Fetch" instruction 1028, one byte at a time, with   the "End Address" in Params 1004 and 1005. A match results in Exit from routine,otherwise the routine returns to "Fetch & Copy" for the next item.                                                                                              More on this next time...Meanwhile, copy ROM to Screen RAM, to see DD's shorts!!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              


          Machine Code for the Oric Atmos (Part 9)    Peter N. Brag                                                    .         -------------------------------                                   

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming using the Oric. In Part 5 of the series, we looked at a small set   of fourteen instructions consisting of just four different types. We then used  two short routines, "Screen Fill" (in Part 6) and "Copy Routine" last month, to illustrate the operation of most of those instructions. The description of the  "Copy Routine", was somewhat abreviated, so lets fill in some of the gaps.                                                                                      

The Copy Routine                                                                ---------------- This was initially set up to copy the contents of the Text     display screen into memory. The screen contents were dumped into the area of    RAM starting at location 3000 hex. To re-display that screen dump copy was easy.We simply swapped the addresses over in the Parameter Block and then copied the screen dump back on to the screen by using the same routine again.                                                                                              However, I should point out that the Copy Routine is not restricted to the      screen area, that was only used for demonstration purposes. You can use the     Copy Routine to copy from any area in memory (ROM or RAM), to any area in RAM.                                                                                  

Do-it-Yourself Hyperspace                                                       ------------------------- Of course this all versatility can produce a few      "interesting" effects, although nothing permanent or disasterous. If you copy   into the area below address 0500, for example, you will overwrite Oric's        workspace, which will annoy our little wedge shaped friend immensely. Likewise  if you copy program code (ie the ROM) straight on to the screen display, you    will find that the result is not a pretty sight, particularly on the morning    after the night before. In these cases RESET, or if that fails, pull the plug   on it all, to restore "normal service".                                                                                                                         The reason for the weird display effects is simple. Program code is made up of  individual bytes of values in the range 00 to FF (0 to 256 dec). Of these, the  values in the range 20 to 7F produce display characters and cause no problems,  but many of the remainder are also used to produce the special display effects  for text and graphics, hence the psychedelic display.                                                                                                           Copying any normal screen display into and out of memory is quite easy, as      everything is already set up for display anyway. Obviously doing this enables   you to examine various screen displays and try out your own modifications and   experiments in a more controlled way, using Hexloader or similar code writing   utility.                                                                                                                                                        The Copy Routine itself can be quite useful. For example, you could produce     simple animation by putting several copy dumps of different screen displays     into different areas and then copying them back to the screen display in the    required sequence. This could be done by using a simple Basic routine to POKE   the necessary addresses into Parameter Block 1002 followed by CALL£1010 for     each display. Of course all this can be applied to the HIRES screen display too which is located in the area A000 to BF3F.                                                                                                                      

How it works                                                                    ------------ The Routine started by using Absolute LDA instructions to set up   a "Fetch & Copy" operation using addresses from a simple Parameter Block. These operations were covered sufficently last time.                                                                                                                  The "Fetch and Copy" operation is a one shot affair and the two instruction     addresses need updating after each byte copied. Lets have a look at that here.  

Updating "Fetch" (& Copy) Instruction Address                                   --------------------------------------------- The addresses are updated by two  separate operations, but as both operations are the same, we will concentrate   on the "Fetch" update in 103F to 104D. This uses two ADC£ instructions to add   the value 01 to the address held in 1029 and 102A. Last months listing is       repeated here in minature, in case you do not have it handy.                                                                                                    NOTE - A correction to last months routine. Owing to a slight hiccup in         printing, the ADC appeared with a pound sign, it should have printed as ADC£.   My fault really, but how do I get boot marks off the printer ??                                                                                                                                                 

Addition operations must start with a CLC instruction to CLear the Carry (to 0), before the first ADC instruction, because the ADC instruction always includes the Carry Flag and adds 01 to any addition result, if the Flag starts at "1".                                                                                                                                      The address to be updated is a two byte operand, so the addition is done in two parts. First, the low part of the address is fetched into the Accumulator from location 1029 and the value 01 is added to it.                                                The result is saved back into location 1029. Any result that is larger than one byte will also set the Carry Flag to "1" as well. next, the high part of theaddress is fetched into the Accumulator from location 102A and the value 00 is added to it. As the Carry Flag is included in the addition process any surplus from the previous addition, will be added to the  
high part of the address, which is now saved back into location 102A. In fact   the sole reason for adding 00 to the high part of the address in this           particular operation, is to allow the Carry Flag to carry over any surplus from the addition to the low part of the address, into the high part of the address.                                                                                 Updating the "Copy" instruction address is carried out in exactly the same way  as the above "Fetch" update. The earlier "Screen Fill" routine also used this   method of updating. All we are doing here is simply incrementing the two        addresses each time after using them and so there was little point in changing  to Absolute operation for this operation.  


Last Item Copied Yet ?                                                          ---------------------- This operation makes use of the Fetch "End" address in   the Parameter Block to terminate the routine when all the required memory area  has been copied. For this particular routine, the Fetch "End" address is the    first location after the area to be copied. The routine is stopped when the     address used by instruction 1028 matches Fetch "End" in the Parameter Block.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    The main reason for the Copy routine was to show how the controlling data could be accessed from a simple Parameter (data) block by using Absolute instructions,instead of being scattered around the routine.                                                                                                                  This is where the CMP operation used here differs from that in the Screen Fill  routine. Unlike the CMP£ instruction previously encountered, these Absolute CMP instructions do not include the data item for testing, instead they use the     contents of an address in memory as data and compare that with the Accumulator  contents. Here in the Copy Routine, the required data (Fetch "End" address) is  located in the Parameter Block at 1004 and 1005.                                                                                                                The Absolute CMP operand is the address (in reverse order) of the location      where the test data can be found. The two Absolute CMP instructions here, are   used to test for the "End" address which is needed to terminate the copy        operation.                                                                                                                                                      For example, the instruction CMP 1005, located at 1050, will compare the        contents of the Accumulator with those of location 1005 in Parameter Block. At  this point the Accumulator already contains the high part of the "Fetch"        address as the end result of updating "Fetch" instruction 1028. This means that the CMP instruction at 1050 will be comparing it with the high part of the      Fetch "End" address in 1005, which is just what we want.                                                                                                        The two byte address is tested one byte at a time. The low part of the "Fetch"  address is copied into the the Accumulator by instruction 1055 and is then      compared with the contents of 1004 in the Parameter Block by instruction 1058.                                                                                  The two CMP instructions set the Zero Flag according to the result of their     comparison tests. A match will set the Zero Flag to "1". If the data does not   match, the Zero Flag will be cleared to "0".                                                                                                                    The two CMP instructions are also paired up with two BNE Branch instructions.   BNE Branches are active when the Zero Flag is cleared to "0". The instruction   label "BNE" means "Branch when result is Not Equal", or in other words, when    data tested, does not match, causing CMP to clear the Zero Flag to "0".                                                                                         The copy routine will always Branch (loop) back to "Fetch & Copy", providing at least one of the BNE Branches remain active. The only condition that will stop  this happening, is when both CMP instructions result in the Zero Flag being set to "1". That will only happen when the address in instruction 1028, matches     that in the Parameter Block at locations 1004 and 1005. At that point both BNE  instructions are disabled and the copy operation will then Finish and Exit.                                                                                     

The Score so far                                                                ---------------- The routine was intended to illustrate two points. First,      the program layout can be arranged to make programming and operation easier.    The Copy routine would have worked just as well with the address/data scattered throughout the routine, but gathering the address/data up into a Parameter      Block makes changing those addresses far easier, which in turn makes the        routine more adaptable and useful. This will become even more obvious when you  write larger programs. Second point illustrated, is that useful routines can be produced, using just a few simple instructions. You do not have to have a vast  expertise covering the whole 6502 Instruction Set. So far all of the            instructions used, have come from the small subset given in Part 5 of the       series. There are better versions of this Copy Routine, but the first objective here, is to show how the instructions actually work.                                                                                                            Thats it for this month's "SYNTAX ERRORS".....Next month's may make you jump !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               


          Machine Code for the Oric Atmos (Part 10)   Peter N. Bragg
          -------------------------------                                   

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming on the Oric. Part 5 of the series looked at a small subset of       fourteen instructions, made up of just four different types. We then went on to use some of those instructions, first with a simple "Screen Fill" program and   then in the last two issues, we have concentrated on the instructions and       programming required to produce a Copy routine.                                                                                                                 It is interesting to note that it was possible to produce two modestly useful   routines with just eight different instructions. While we have not so far, made use of all the instructions in our small subset, we have at least looked at one sample from each type.                                                                                                                                          We have only used one Branch instruction (BNE) and have yet to use the Subtract (SBC) instruction in any of our forays into the realm of Oric machine code.     This will be rectified shortly, however, if you have managed to follow most of  what has been covered so far, you should have no problems. Most of the          remaining instructions on the list are very similar to those already used.                                                                                      For instance SBC operates in the same way as the ADC instruction, that we have  already used. The only difference is that the Carry Flag is set to "1", before  the (SBC) subtraction operation, instead of being cleared as for (ADC) addition.The Copy and Screen Fill routines used ADC instructions to count upwards. They  would work just as well using SBC to count downwards, if the Start and End      addresses were swapped over. However, dont worry if you are still not too sure  about the SBC instruction, all will be explained when we get round to using it.                                                                                 

Take a Running Jump !!                                                          ---------------------- Before we continue our look at the small subset of       instructions , I am going to add one more type of instruction to it. This is    one of the most useful of all and is known as the Jump instruction. There are   in fact, four jump instructions for the Oric's 6502. However, I am going to     ignore one of them for the moment and concentrate on the other three, because   they are the most useful to us at this point in time.                                                                                                           If you have written Basic programs, you almost certainly will be familiar with  the instructions GOSUB, RETURN and if you really don't care, the dreaded GOTO.  If you have a lot of experience with Basic you wont need me to tell you how     useful these instructions are, particularly the first two. When it comes to     machine code programming, you will find that there are three instructions, that provide equivalents to those three Basic instructions and operate in a very     similar way.                                                                                                                                                    GOSUB and RETURN can be used to simplify a Basic program's structure. Jump      instructions can do the same for machine code. In addition they can also be     used to access routines in the Oric's Operating System. As fans of Jon's        "Rambling in the ROM" and the "Advanced User Guide" already know, there is a    large number of useful ready made routines, already present in the Operating    System. These can be called up by using nothing more than a simple three byte   instruction, which is much easier than having to write everything yourself.                                                                                     Once again, we will look at our small subset of 6502 Instructions. This time,   it has the three Jump instructions added to it. The complete table so far, is   shown here. The other instructions are those we have been using for the last    few months, have a look at the last few issues if you are not too sure how they operate.                                                                                                  

                         6502 Instruction Subset                                                                                                                                       
                         ----------------------                                    
Accumulator Instructions        Absolute            Immediate                                                        .                           instruct   code       instruct  code
                    
Load  Accumulator             LDA  AD xx yy       LDA£  A9 xx                   Store Accumulator             STA  8D xx yy                                                                                                                     Add with Carry                ADC  6D xx yy       ADC£  69 xx                   Subtract with Carry           SBC  ED xx yy       SBC£  E9 xx                                                                                                   Compare Accumulator           CMP  CD xx yy       CMP£  C9 xx                                                                                                 

Flag Instructions                                                                                                .                    instruct  code                                         Clear Carry Flag to 0         CLC  18      no operand/data                      Set   Carry Flag to 1         SEC  38      no operand/data                                                                                                    

Conditional Branch Instructions                                                                                                                                       .   Condition             instruct code    Flag set by -                        Branch if Carry Flag = 0      BCC  90 xx   No Carry                             Branch if Carry Flag = 1      BCS  B0 xx   Carry                                                                                                                Branch if Zero Flag = 0       BNE  D0 xx   Result Not Zero                      Branch if Zero Flag = 1       BEQ  F0 xx   Result Zero                                                                                                          Branch if Negative Flag = 0   BPL  10 xx   Result Plus                          Branch if Negative Flag = 1   BMI  30 xx   Result Minus                                                                                                       

Jump Instructions                                                                                          .                     instruct  code                                         Jump                          JMP  4C xx yy  (address yyxx)                                                                                                     Jump saving return address    JSR  20 xx yy  (address yyxx)                                                                                                     Return/jump from SubRoutine   RTS  60        no operand/data                                                                                            

IMMEDIATE (£) instructions supply the required data byte as the operand "xx".                                                                                   

ABSOLUTE instructions on the other hand don't include the data byte, instead    they give the address of a memory location which holds it. The addresses are    written in reverse order, low part in "xx" and high part in "yy".                                                                                               

Jump Instruction Information                                                    ---------------------------- All three have equivalents in Basic programming.   The equivalents are JSR for GOSUB, RTS for RETURN and finally JMP for GOTO.                                                                                     If you have been following this series for a while, you will have already met   the RTS instruction and it's similarity to Basic's RETURN may well be obvious,  both are used to terminate a routine and return the operation to the original   "calling" instruction.                                                                                                                                          As usual the labels JSR, RTS and JMP are initials that describe the             instruction's operation. What they actually mean is also described below.                                                                                       

JMP                                                                             --- Let us look at this instruction first. Surprise, surprise ! the label is an     abbreviation of the word "Jump".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                The JMP instruction consists of an opcode (4C), followed by a two byte          operand for the address. The address as usual, is set in reverse order,         just as in all the Absolute instructions we have already met.                                                                                               The Basic GOTO is followed by a value for line number and the JMP instruction   is followed by an address, which in fact is more or less the same thing, as     both can be used to jump to a new location in a program.                                                                                                        For example, if you wanted to make your program jump to location 12AB, you need to set the instruction as JMP 12AB, which would be written in code as 4C AB 12. The program would instantly jump to the location 12AB, on encountering that     instruction and then continue running the program from there.                                                                                                   

JSR                                                                             --- This is an abbreviation for "Jump and Save Return address". The opcode for      this instruction is 20h, but otherwise the operation of the instruction is      exactly the same as the previously mentioned JMP instruction. For example       the instruction JSR 12AB, would be set as 20 AB 12. Once again the result,      would be a jump to the location 12AB and the program would then continue to     run from that address.                                                                                                                                          So what is the essential difference that makes the JSR instruction so           useful ? The answer to that is, it's ability to save a return address. This     means that it can be used in the same way as Basic's GOSUB, which brings us     very nicely to the third and last jump instruction, RTS.                                                                                                    

RTS                                                                             --- This label is an abbreviation for "ReTurn (jump) from Subroutine".              RTS retrieves the return address saved by the JSR and then jumps to that        address. It is a single byte instruction (code 60h), that is used in            exactly the same way as RETURN in Basic. It provides for the "return" from      any subroutine called by the JSR instruction.                                                                                                               So just like GOSUB and RETURN, the instructions JSR and RTS need to be used as  a pair and just like their Basic equivalents, they can be "nested" to provide   more subroutines inside subroutines. Just as in Basic, routines called by a JSR need to be terminated by an RTS instruction (or at least have some arrangement  made to dispose of the "return address" saved by the JSR instruction).                                                                                          I should perhaps mention that although we use the word "jump" to describe all   of these operations, strictly speaking what really happens is, that a Jump      instruction modifies the Program Counter (register). We have met the Program    Counter before,in Part 3. It holds the address of the next instruction to be    fetched. Jump instructions simply change that address, to produce what is in    effect, a jump to anywhere in the program, backwards or forwards.                                                                                               

Break it up Small                                                               ----------------- One way to clear a space around you at any gathering is to    start talking in a loud voice about programming structure. Even dedicated       drinkers will abandon the bar and some have been known to hide under the carpet.Fear not, in spite of anything you may have heard, structured programming is    simple. Instead of writing your program in one large monolithic lump, you first break it up into a series of much smaller and simpler operations, which are     easier to write and test as seperate units. Once this has been done the JSR and RTS jump instructions can be used to link them together as a complete program.                                                                                  Hope Santa is loaded up with lots of Oric goodies for you this year.......................not just loaded !!.........A very Happy Christmas and New Year to all.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              


          Machine Code for the Oric Atmos (Part 11)   Peter N. Bragg
          -------------------------------                                   

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming on the Oric. In the last issue we added another type of instruction to our small subset of machine code instructions. We now have just five         different types of instruction, a total of sixteen instructions all of which    appeared in the table, published in the last issue.                                                                                                             

Wake up the Oric                                                                ---------------- The issue in particular, looked at machine code jumps, with    emphasis on those that could be used to access routines from Oric's own built   in software in the Operating System ROM.                                                                                                                        Let us have a look at one of the routines built into the ROM. The obvious       choice is the one which is used to read the keyboard. After all the keyboard is the first thing we use when starting up. We always need to bash a few keys to   get the Oric to pay attention and do what it is told. We will now look at a     short routine that will read the keyboard for us and tell us which key has been pressed. The routine we need for this is located at the address EB78 in the     Atmos and is called "Go TO Read KeyBoard" or, GTORKB for short.                                                                                                 Being poor as a church mouse (but somewhat larger of course), I dont possess an Oric-1 (sob !), unlike these rich people who have dozens. However, Dave Dick    tells me that the equivalent to the GTORKB routine in the Oric-1 is located at  location E905, so if you are using Oric-1 substitute E905 for EB78.                                                                                             

Wait a Bit !                                                                    ------------ If we simply call this routine, the chances are that the only      result we would get is a big fat zero. The reason for this is quite simple.     The Oric whizzes off to read the keyboard and is back in a flash, long before   you have decided which key, you were going to press.                                                                                                            However this is no great problem. All we need to do is to persuade the Oric to  keep going back to look at the keyboard, until a key has actually been pressed. The question is how do we know when a key has been pressed. In fact there is a  simple indicator provided by the Operating System. This uses the Negative Flag  in our old friend the Status Register. When the Oric reads the keyboard it will clear the Negative Flag to "0" if no key has been pressed. If a key has been    pressed, the Negative Flag will be set to "1".                                                                                                                  So all we need to do is to arrange a routine so that the Oric will keep on      returning to look at the keyboard if the Negative Flag is "0", which in fact is just a simple loop routine.                                                                                                                                     If you have our little 6502 Instruction Subset (table) handy, you will find     that the Branch instruction BPL, will fit the bill for this job. The BPL Branch is only active if the Negative Flag is "0", so it can be used to provide the    required loop action.                                                                                                                                           Once a key has been pressed, it's ASCII code will be put into the Accumulator,  ready for use.                                                                                                                                                  The required routine is quite short and simple to enter. Use Hexload II from    Part 7 of the series, or similar assembler/code writing utility, to enter the   the code below into the addresses as shown -                                      Address 1001:00 and then address 1010:20 78 EB 10 FB 8D 01 10 60 finishing up   at address 1018. So whats all that lot about ? Lets look at the listing.      

Oric                  DEMONSTRATION ROUTINE                           15 Dec 91 ----                  ---------------------                           --------- [ CALL#1010 ]-------[ Fetch Item from Keyboard ]-------------------------------                                                         Notes                       
    -        ---storage---                      -       -----                               .   :                   ---Parameter 1001       : This is used to store the     1001:  (00)   :          :  "none yet"          :  ASCII code of key pressed.          .   -                                           -                                                                                                                   .   -        ----start----                      -                                         .   :                   ---Read Keyboard        :                               1010:20 78 EB : JSR  EB78: Call "GTORKB"        : Test Keyboard for key pressed.    .   :         :          :                      :                               1013:10 FB    : BPL  1010: Back to instruct 1010: Back to test keyboard again       .   :         :          :  if Neg Flag is "0". :  if key not pressed.              .   :                                           :                                   :                   ---Save Key Press Result:                               1015:8D 01 10 : STA  1001: Copy Accu into 1001. : Save the ASCII code for the       .   :         :          :                      :  key pressed in Param 1001.       .   :                                           :                                   .   :                   ---Finish               :                               1018:60       : RTS      :  Exit, back to Basic.:                                                                                                               -   -        -----end----- 
                     -                             -                                                                                                                                                                 The above listing is perhaps a bit more detailed than really necessary, but     hopefully this will enable those who are new to machine code to understand what is going on. You will notice that the listing is split into four columms, plus  an additional columm for notes, on the far right.                                                                                                               The first two columms on the left contain the addresses and the same hex code   that was shown above, but this time, it has been split up into specific items   (eg. Instructions).                                                                                                                                             The third columm contains the assembly instruction labels.                                                                                                      The fourth columm tells us what the instruction is doing as far as the computer is concerned and the last columm of notes on the right, tells us how all the    operations done by the instructions, fit in with our program (ie. What we want  the machine to do). These last two columms are the most important of all, in    any program. They are used to explain what is actually happening.                                                                                               You will notice that a copy of the Accumulator contents are preserved in        location 1001. It is not essential to do this if you are going to use them      straight away. However, it is a good policy to save input for possible later    use or even fault finding. There will be times when you will be glad you did so.                                                                                If you now CALL#1010 to run this routine, you will find that the Oric will stop and wait for you to press a key. Once you have done so, you can then look at    the contents of location 1001. The original contents of 1001 will now have      replaced by the ASCII code of the key that you pressed. Key "A" will produce    code 41 and Key "Z" will produce code 5A. Your manual should have the full list.                                                                                This is all very well, but how can we use it. Obviously we need some way to     sort out specific keys and this is the next thing we will look at.                                                                                              Thats input....Next time output and how to annoy your neighbour's neighbours !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               


         Machine Code for the Oric Atmos (Part 12)   Peter N. Bragg
         -------------------------------                                   

The Story so far                                                                ---------------- We have looked at the basic requirements for machine code      programming on the Oric and now have a small table (subset) of sixteen useful   instructions. In the last issue we looked at a very short routine which made    use of Oric's own built-in routines to read a key press from the keyboard.                                                                                      Each of the keys on the keyboard has a specific code (ASCII code). The program  that we used, was started by CALL#1010. This made the Oric stop and wait for a  key press. When a key was pressed, its code was put into the Accumulator.       We also included an extra instruction which would put a copy of that code into  location 1001 as well, to preserve it. The Accumulator gets used for many       things and this ensures that we do not lose the input key code, if we go on to  do something else with the Accumulator before using the input code.                                                                                             So far so good, but how can we use this ? Well, irrespective of what we are     going to use the Oric for, one thing is certain, we will probably use the       keyboard to control the operation. We have seen that we can get a different     code value for each of the keys (well most of them anyway), but how can we make individual keys select different operations ? How do we link each key to it's   own particular action ? That is what we are going to look at next.                                                                                              The best way to show how to do this, is to write a simple program which uses    three different keys to call up three different actions. The action that each   key calls up, is not important at this stage, so to save time, we can make use  of three routines from the Oric's Operating System ROM instead of having to     write our own. Probably the three easiest ROM routines to use, are ZAP, SHOOT   and EXPLODE, each of which can be called up, using a simple "JSR" instruction.  We met the "JSR" instruction in the small 6502 Instruction Subset in Part 10 of the series. It is being used here to simplify our programming.                                                                                                  The program can be split up into two main parts (routines). This makes it       easier to produce, as each part can be written and tested separately. The first routine fetches a key (command) input from the keyboard. The second routine     sorts the input and produces the action required for each key.                                                                                                  The first routine, which fetches the key input, should be easy as we have       already dealt with part of that operation in the last issue and we only need to extend that routine slightly to make use of it here.                                                                                                            That routine was limited because it only fetched one key and then made an exit  back to Basic. Most software needs far more in the way of commands from the     keyboard than a single key press, hence the need for a small extension.                                                                                         To obtain full control, we will want the routine to deal with each key press    and then loop back to read the keyboard again for another key press. This is    easy enough to arrange, but it does raise a question. How do we escape from the program, when we eventually need to do so ? The answer is that we were going to use three keys for our commands anyway, so we might as well add a fourth key to provide the program with a proper escape route, back to Basic.                                                                                                  Of course you can just use the RESET button to make your exit, but there are    times when this is not convenient or practical. While most keys could be used   to make an exit, obviously some are more appropriate than others. For example,  we could use "X" for Exit, or "Q" for Quit, but my own preference is to use the "ESC" Key for Escape. However, once you have seen how the operation works, you  will be able to make your own choice of keys. Now, lets look at the program.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

Oric                  KEYBOARD CONTROL DEMO (Routine 1)                8 Jan 92 ----                  ---------------------                            -------- [ CALL#1010 ]-------[ Fetch Item from Keyboard ]-------------------------------                                                                       .                                                  Notes                            .   -        ---storage---                         -----                      -           .   :                   ---Parameter 1001         Storage for copy of           1001:  (00)   :          :  "none yet"          ASCII code of key pressed.            .   -                                                                         -                                                                                     .   -        ----start----                                                    -                         .                       ---Read Keyboard---                                     1010:20 78 EB : JSR  EB78: Call "GTORKB" to test Keyboard for key pressed.          .   :         :          :                                                      1013:10 FB    : BPL  1010: If key NOT pressed, back to 1010 again. (Neg Flag 0)     .   :         :          : If key IS  pressed, do next instruct.   (Neg Flag 1)                                                                                                         .                       ---Save Key Press Input---                              1015:8D 01 10 : STA  1001: Copy Accu into Param 1001 to preserve the input.         .   :         :          :       (Input is ASCII code of the key pressed)                                                                                                                   .                       ---Continue or Stop ?---                                1018:C9 1B    : CMP "ESC": Test - Was Key "ESC" pressed ? (Code for "ESC" is 1B)    .   :         :          :                                                      101A:F0 06    : BEQ  1022: If "Yes" skip to Finish (at instruct 1022).              .   :         :          : If "No" continue on to test and use input.               .   :         :          :  (Zero Flag at "1" for "Yes" or "0" for "No")                                                                                                                  .                       ---Test and use input---                                101C:20 2D 10 : JSR  102D: Go and test input for Command Keys                       .   :         :          :    and take any action that may be required,         101F:4C 10 10 : JMP  1010:  then jump back to 1010 to get another key press.                                                                                                             .                       ---Finish---                                            1022:60       : RTS      :  Exit, back to Basic                                                                                                                 -            -----end-----                                                    -                                                                                 

Loading the Program in                                                          ---------------------- The program can be entered as usual using an assembler,  or if you are using Hexload II from Part 7 of the series, you can use the brief listings below as they are the same thing. Dont forget to save it, too !!                                                                                          

Address 1010:20 78 EB 10 FB 8D 01 10 C9 1B F0 06 20 2D 10 4C 10 10 60 .                                                                                      

The line above is for routine (1) and     Address 102D:AD 01 10                 the four short lines on the right are     Address 1030:C9 5A D0 04 20 E1 FA 60  the listing for routine (2), which is     Address 1038:C9 53 D0 04 20 B5 FA 60  listed in more detail, below.             Address 1040:C9 45 D0 03 20 CB FA 60                                                                                  

Oric-1 Users                                                                    ------------ Your ROM is slightly different, so change the addresses of the     four instructions in the listing that call on the Operating System.                                                                                               These are -   GTORKB  at  E905   so change instruction   1010: 20 05 E9                       ZAP     at  FAC7      ..         ..        1034: 20 C7 FA                       SHOOT   at  FA9B      ..         ..        103C: 20 9B FA                       EXPLODE at  FAB1      ..         ..        1044: 20 B1 FA                                                                                       .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

Oric                  KEYBOARD CONTROL DEMO (Routine 2)                8 Jan 92 ----                  ---------------------                            -------- [ JSR 102D ]--------[ Sort & Use Command Keys ]--------------------------------                                                         .                                                       Notes                       .   -        ----start----                      -       -----                       .   :                   ---Input copy to Accumulator---                         102D:AD 01 10 : LDA  1001: Fetch copy of input code produced by key press           .   :                    :   (from Params 1001 into Accumulator).                                                                                                                                                                                                       

.                       ---Test Input for "Zap" key---                          1030:C9 5A    : CMP  "Z" : Test - Was Key "Z" pressed ?  (Code for "Z" is 5A)                                                                                   1032:D0 04    : BNE  1038: If "No"  Skip to next test at instruct 1038.             .   :         :          : If "Yes" do next instruction  (Zero Flag 0=No 1=Yes)                                           .                                         which is                              1034:20 E1 FA : JSR  FAE1: go to Oric's "Zap" routine    (at addr FAE1)                                              .                                   and then after that                         1037:60       : RTS      : return for another Key press  (via instruct 101F).                                                                                                                                                                                           

.                       ---Test Input for "Shoot" key---                        1038:C9 53    : CMP  "S" : Test - Was Key "S" pressed ?  (Code for "S" is 53)                                                                                   103A:D0 04    : BNE  1040: If "No"  Skip to next test at instruct 1040.             .   :         :          : If "Yes" do next instruction                                                                   .                                         which is                              103C:20 B5 FA : JSR  FAB5: go to Oric's "Shoot" routine  (at addr FAB5)                                             .                                   and then after that                         103F:60       : RTS      : return for another Key press  (via instruct 101F).                                                                                                                                                                                           

.                       ---Test Input for "Explode" key---                      1040:C9 45    : CMP  "E" : Test - Was Key "E" pressed ?  (Code for "E" is 45)                                                                                   1042:D0 03    : BNE  1047: If "No"  Input not recognized so return for another.     .   :         :          : If "Yes" do next instruction                                                                   .                                         which is                              1044:20 CB FA : JSR  FACB: go to Oric's "Explode routine (at addr FACB)                                             .                                   and then after that                         1047:60       : RTS      : return for another Key press  (via instruct 101F).                                                                                   -            -----end-----                      -                             -                                                                                 

It's a Racket !!                                                                ---------------- Place the Oric by an open window, CALL#1010 and then press     keys "Z", "S" or "E". The result should shift the squirrels off the bird table. A little more amplification will tell you, which of your neighbours are at home.                                                                                The program is intended to show how the keyboard can be used to control         software, using a few simple instructions. It also shows that you can make use  of the Oric's built-in software for your own machine code programs.                                                                                             Space is running out, so we will continue on this theme next time. In the       meantime, note that "PING" is at FA9F (Oric-1 at FA85). How could it be added   to the program ? If you do have a try at that, note the "booby trap" in 1043.                                                                                   Thats it for this month's keyboard accident.....More machinespeak next month !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 